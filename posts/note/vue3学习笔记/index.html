<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Vue3学习笔记 | Binb&#39;s Blog</title>
<meta name="keywords" content="Vue">
<meta name="description" content="参考链接： 一个 Java 猿眼中 Vue3 和 Vue2 的差异 （建议收藏）Vue3 对比 Vue2.x 差异性、注意点、整体梳理，与React hook比又如何？（面试热点） Vue2升级">
<meta name="author" content="chance7bin">
<link rel="canonical" href="https://chance7bin.github.io/posts/note/vue3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.be81eec981a615a87a88f121642d7eebde74d033438693944db2fd6b827284ff.css" integrity="" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.acb54fd32bbc1982428b8850317e45d076b95012730a5936667e6bc21777692a.js" integrity=""
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://chance7bin.github.io/img/%E7%BE%8E%E9%98%9F.jpg">
<link rel="icon" type="image/png" sizes="16x16" href="https://chance7bin.github.io/img/%E7%BE%8E%E9%98%9F.jpg">
<link rel="icon" type="image/png" sizes="32x32" href="https://chance7bin.github.io/img/%E7%BE%8E%E9%98%9F.jpg">
<link rel="apple-touch-icon" href="https://chance7bin.github.io/img/%E7%BE%8E%E9%98%9F.jpg">
<link rel="mask-icon" href="https://chance7bin.github.io/img/%E7%BE%8E%E9%98%9F.jpg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Vue3学习笔记" />
<meta property="og:description" content="参考链接： 一个 Java 猿眼中 Vue3 和 Vue2 的差异 （建议收藏）Vue3 对比 Vue2.x 差异性、注意点、整体梳理，与React hook比又如何？（面试热点） Vue2升级" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://chance7bin.github.io/posts/note/vue3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-09-14T00:00:00+00:00" />
<meta property="article:modified_time" content="2022-09-14T00:00:00+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Vue3学习笔记"/>
<meta name="twitter:description" content="参考链接： 一个 Java 猿眼中 Vue3 和 Vue2 的差异 （建议收藏）Vue3 对比 Vue2.x 差异性、注意点、整体梳理，与React hook比又如何？（面试热点） Vue2升级"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "📚 文章",
      "item": "https://chance7bin.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "👨🏻‍💻 我的笔记",
      "item": "https://chance7bin.github.io/posts/note/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Vue3学习笔记",
      "item": "https://chance7bin.github.io/posts/note/vue3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Vue3学习笔记",
  "name": "Vue3学习笔记",
  "description": "参考链接： 一个 Java 猿眼中 Vue3 和 Vue2 的差异 （建议收藏）Vue3 对比 Vue2.x 差异性、注意点、整体梳理，与React hook比又如何？（面试热点） Vue2升级",
  "keywords": [
    "Vue"
  ],
  "articleBody": " 参考链接：\n一个 Java 猿眼中 Vue3 和 Vue2 的差异\n（建议收藏）Vue3 对比 Vue2.x 差异性、注意点、整体梳理，与React hook比又如何？（面试热点）\nVue2升级到Vue3到底是不是一个正确的选择？(尤雨溪亲自回复解读)\n选项式API和组合式API 选项式 API (Options API) 使用选项式 API，我们可以用包含多个选项的对象来描述组件的逻辑，例如 data、methods 和 mounted。选项所定义的属性都会暴露在函数内部的 this 上，它会指向当前的组件实例。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 \u003cscript\u003e export default { // data() 返回的属性将会成为响应式的状态 // 并且暴露在 `this` 上 data() { return { count: 0 } }, // methods 是一些用来更改状态与触发更新的函数 // 它们可以在模板中作为事件监听器绑定 methods: { increment() { this.count++ } }, // 生命周期钩子会在组件生命周期的各个不同阶段被调用 // 例如这个函数就会在组件挂载完成后被调用 mounted() { console.log(`The initial count is ${this.count}.`) } } \u003c/script\u003e \u003ctemplate\u003e \u003cbutton @click=\"increment\"\u003eCount is: {{ count }}\u003c/button\u003e \u003c/template\u003e 组合式 API (Composition API) 通过组合式 API，我们可以使用导入的 API 函数来描述组件逻辑。在单文件组件中，组合式 API 通常会与 ",
  "wordCount" : "11336",
  "inLanguage": "zh",
  "datePublished": "2022-09-14T00:00:00Z",
  "dateModified": "2022-09-14T00:00:00Z",
  "author":[{
    "@type": "Person",
    "name": "chance7bin"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://chance7bin.github.io/posts/note/vue3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Binb's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://chance7bin.github.io/img/%E7%BE%8E%E9%98%9F.jpg"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://chance7bin.github.io/" accesskey="h" title="Binb&#39;s Blog (Alt + H)">
                <img src="https://chance7bin.github.io/img/%E7%BE%8E%E9%98%9F.jpg" alt="" aria-label="logo"
                    height="35">Binb&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://chance7bin.github.io/search" title="🔍搜索 (Alt &#43; /)" accesskey=/>
                    <span>🔍搜索</span>
                </a>
            </li>
            <li>
                <a href="https://chance7bin.github.io/" title="🏠 主页">
                    <span>🏠 主页</span>
                </a>
            </li>
            <li>
                <a href="https://chance7bin.github.io/archives/" title="⏱️ 时间轴">
                    <span>⏱️ 时间轴</span>
                </a>
            </li>
            <li>
                <a href="https://chance7bin.github.io/posts" title="📚 文章">
                    <span>📚 文章</span>
                </a>
            </li>
            <li>
                <a href="https://chance7bin.github.io/tags" title="🔖 标签">
                    <span>🔖 标签</span>
                </a>
            </li>
            <li>
                <a href="https://github.com/chance7bin" title="GitHub">
                    <span>GitHub</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://chance7bin.github.io/">🏠 主页</a>&nbsp;»&nbsp;<a href="https://chance7bin.github.io/posts/">📚 文章</a>&nbsp;»&nbsp;<a href="https://chance7bin.github.io/posts/note/">👨🏻‍💻 我的笔记</a></div>
    <h1 class="post-title">
      Vue3学习笔记
    </h1>
    <div class="post-meta">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css">


<style>
    i[id*="post_meta_style"] {
        display: flex;
        align-items: center;
        margin: 0 0 10px 0;
    }

    .parent-post-meta {
        display: flex;
        flex-wrap: wrap;
        opacity: 0.8;
    }
</style>

<span class="parent-post-meta">
    <span id="post_meta_style_1">
        <span class="fa fa-calendar-check-o"></span>
        <span>2022-09-14
            &nbsp;&nbsp;
        </span>
    </span>
    
    
    
    
    
    
    
    <span id="post_meta_style_3">
        <span class="fa fa-file-word-o"></span>
        <span>11336字
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_4">
        <span class="fa fa-clock-o"></span>
        <span>23分钟
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_5">
        <span class="fa fa-user-o"></span>
        <span>chance7bin
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_6">
        <span class="fa fa-tags" style="opacity: 0.8"></span>
        <span>
            <span class="post-tags-meta">
                <a href="https://chance7bin.github.io/tags/vue/" style="color: var(--secondary)!important;">Vue</a>
            </span>
        </span>
    </span>

    
</span>


      
      
      
      
      
      
      
          
          
          
              
              
              
              
          
      
    </div>
  </header>
   <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">目录</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#%e9%80%89%e9%a1%b9%e5%bc%8fapi%e5%92%8c%e7%bb%84%e5%90%88%e5%bc%8fapi" aria-label="选项式API和组合式API">选项式API和组合式API</a><ul>
                            
                    <li>
                        <a href="#%e9%80%89%e9%a1%b9%e5%bc%8f-api-options-api" aria-label="选项式 API (Options API)">选项式 API (Options API)</a></li>
                    <li>
                        <a href="#%e7%bb%84%e5%90%88%e5%bc%8f-api-composition-api" aria-label="组合式 API (Composition API)">组合式 API (Composition API)</a></li>
                    <li>
                        <a href="#%e5%8c%ba%e5%88%ab" aria-label="区别">区别</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e5%93%8d%e5%ba%94%e5%bc%8f" aria-label="响应式">响应式</a><ul>
                            
                    <li>
                        <a href="#setup" aria-label="setup()">setup()</a></li>
                    <li>
                        <a href="#reactive" aria-label="reactive">reactive</a></li>
                    <li>
                        <a href="#torefs" aria-label="toRefs">toRefs</a></li>
                    <li>
                        <a href="#ref" aria-label="ref">ref</a></li>
                    <li>
                        <a href="#reactive-vs-ref" aria-label="reactive vs ref">reactive vs ref</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e8%ae%a1%e7%ae%97%e5%b1%9e%e6%80%a7" aria-label="计算属性">计算属性</a><ul>
                            
                    <li>
                        <a href="#%e8%ae%a1%e7%ae%97%e5%b1%9e%e6%80%a7%e7%bc%93%e5%ad%98-vs-%e6%96%b9%e6%b3%95" aria-label="计算属性缓存 vs 方法">计算属性缓存 vs 方法</a></li>
                    <li>
                        <a href="#%e5%8f%af%e5%86%99%e8%ae%a1%e7%ae%97%e5%b1%9e%e6%80%a7" aria-label="可写计算属性">可写计算属性</a></li>
                    <li>
                        <a href="#%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5" aria-label="最佳实践">最佳实践</a><ul>
                            
                    <li>
                        <a href="#%e8%ae%a1%e7%ae%97%e5%87%bd%e6%95%b0%e4%b8%8d%e5%ba%94%e6%9c%89%e5%89%af%e4%bd%9c%e7%94%a8" aria-label="计算函数不应有副作用">计算函数不应有副作用</a></li>
                    <li>
                        <a href="#%e9%81%bf%e5%85%8d%e7%9b%b4%e6%8e%a5%e4%bf%ae%e6%94%b9%e8%ae%a1%e7%ae%97%e5%b1%9e%e6%80%a7%e5%80%bc" aria-label="避免直接修改计算属性值">避免直接修改计算属性值</a></li></ul>
                    </li></ul>
                    </li>
                    <li>
                        <a href="#%e6%9d%a1%e4%bb%b6%e6%b8%b2%e6%9f%93" aria-label="条件渲染">条件渲染</a><ul>
                            
                    <li>
                        <a href="#v-if-%e5%92%8c-v-for" aria-label="v-if 和 v-for"><code>v-if</code> 和 <code>v-for</code></a></li></ul>
                    </li>
                    <li>
                        <a href="#%e5%88%97%e8%a1%a8%e6%b8%b2%e6%9f%93" aria-label="列表渲染">列表渲染</a><ul>
                            
                    <li>
                        <a href="#%e7%bb%84%e4%bb%b6%e4%b8%8a%e4%bd%bf%e7%94%a8-v-for" aria-label="组件上使用 v-for">组件上使用 <code>v-for</code></a></li>
                    <li>
                        <a href="#%e5%b1%95%e7%a4%ba%e8%bf%87%e6%bb%a4%e6%88%96%e6%8e%92%e5%ba%8f%e5%90%8e%e7%9a%84%e7%bb%93%e6%9e%9c" aria-label="展示过滤或排序后的结果">展示过滤或排序后的结果</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e4%ba%8b%e4%bb%b6%e5%a4%84%e7%90%86" aria-label="事件处理">事件处理</a><ul>
                            
                    <li>
                        <a href="#%e5%9c%a8%e5%86%85%e8%81%94%e4%ba%8b%e4%bb%b6%e5%a4%84%e7%90%86%e5%99%a8%e4%b8%ad%e8%ae%bf%e9%97%ae%e4%ba%8b%e4%bb%b6%e5%8f%82%e6%95%b0" aria-label="在内联事件处理器中访问事件参数">在内联事件处理器中访问事件参数</a></li>
                    <li>
                        <a href="#%e4%ba%8b%e4%bb%b6%e4%bf%ae%e9%a5%b0%e7%ac%a6" aria-label="事件修饰符">事件修饰符</a></li>
                    <li>
                        <a href="#%e6%8c%89%e9%94%ae%e4%bf%ae%e9%a5%b0%e7%ac%a6" aria-label="按键修饰符">按键修饰符</a><ul>
                            
                    <li>
                        <a href="#%e6%8c%89%e9%94%ae%e5%88%ab%e5%90%8d" aria-label="按键别名">按键别名</a></li>
                    <li>
                        <a href="#%e7%b3%bb%e7%bb%9f%e6%8c%89%e9%94%ae%e4%bf%ae%e9%a5%b0%e7%ac%a6" aria-label="系统按键修饰符">系统按键修饰符</a></li>
                    <li>
                        <a href="#exact-%e4%bf%ae%e9%a5%b0%e7%ac%a6" aria-label=".exact 修饰符"><code>.exact</code> 修饰符</a></li>
                    <li>
                        <a href="#%e9%bc%a0%e6%a0%87%e6%8c%89%e9%94%ae%e4%bf%ae%e9%a5%b0%e7%ac%a6" aria-label="鼠标按键修饰符">鼠标按键修饰符</a></li></ul>
                    </li></ul>
                    </li>
                    <li>
                        <a href="#%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f" aria-label="生命周期">生命周期</a></li>
                    <li>
                        <a href="#%e4%be%a6%e5%90%ac%e5%99%a8" aria-label="侦听器">侦听器</a><ul>
                            
                    <li>
                        <a href="#%e6%b7%b1%e5%b1%82%e4%be%a6%e5%90%ac%e5%99%a8" aria-label="深层侦听器">深层侦听器</a></li>
                    <li>
                        <a href="#%e5%8d%b3%e6%97%b6%e5%9b%9e%e8%b0%83%e7%9a%84%e4%be%a6%e5%90%ac%e5%99%a8" aria-label="即时回调的侦听器">即时回调的侦听器</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e6%a8%a1%e6%9d%bf%e5%bc%95%e7%94%a8" aria-label="模板引用">模板引用</a></li>
                    <li>
                        <a href="#%e7%bb%84%e4%bb%b6%e5%9f%ba%e7%a1%80" aria-label="组件基础">组件基础</a><ul>
                            
                    <li>
                        <a href="#%e5%a4%a7%e5%b0%8f%e5%86%99%e5%8c%ba%e5%88%86" aria-label="大小写区分">大小写区分</a></li></ul>
                    </li>
                    <li>
                        <a href="#props" aria-label="Props">Props</a><ul>
                            
                    <li>
                        <a href="#boolean-%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2" aria-label="Boolean 类型转换"><strong>Boolean 类型转换</strong></a></li></ul>
                    </li>
                    <li>
                        <a href="#%e4%ba%8b%e4%bb%b6" aria-label="事件">事件</a><ul>
                            
                    <li>
                        <a href="#%e4%ba%8b%e4%bb%b6%e6%a0%a1%e9%aa%8c" aria-label="事件校验">事件校验</a></li>
                    <li>
                        <a href="#%e9%85%8d%e5%90%88-v-model-%e4%bd%bf%e7%94%a8" aria-label="配合 v-model 使用">配合 <code>v-model</code> 使用</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e6%8f%92%e6%a7%bd" aria-label="插槽">插槽</a><ul>
                            
                    <li>
                        <a href="#%e6%8f%92%e6%a7%bd%e5%86%85%e5%ae%b9%e4%b8%8e%e5%87%ba%e5%8f%a3" aria-label="插槽内容与出口">插槽内容与出口</a></li>
                    <li>
                        <a href="#%e5%85%b7%e5%90%8d%e6%8f%92%e6%a7%bd" aria-label="具名插槽">具名插槽</a></li>
                    <li>
                        <a href="#%e4%bd%9c%e7%94%a8%e5%9f%9f%e6%8f%92%e6%a7%bd" aria-label="作用域插槽">作用域插槽</a><ul>
                            
                    <li>
                        <a href="#%e9%ab%98%e7%ba%a7%e5%88%97%e8%a1%a8%e7%bb%84%e4%bb%b6%e7%a4%ba%e4%be%8b" aria-label="高级列表组件示例">高级列表组件示例</a></li></ul>
                    </li></ul>
                    </li>
                    <li>
                        <a href="#%e4%be%9d%e8%b5%96%e6%b3%a8%e5%85%a5" aria-label="依赖注入">依赖注入</a></li>
                    <li>
                        <a href="#%e7%bb%84%e5%90%88%e5%bc%8f%e5%87%bd%e6%95%b0" aria-label="组合式函数">组合式函数</a><ul>
                            
                    <li>
                        <a href="#%e9%bc%a0%e6%a0%87%e8%b7%9f%e8%b8%aa%e5%99%a8%e7%a4%ba%e4%be%8b" aria-label="鼠标跟踪器示例">鼠标跟踪器示例</a></li>
                    <li>
                        <a href="#%e7%ba%a6%e5%ae%9a%e5%92%8c%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5" aria-label="约定和最佳实践">约定和最佳实践</a><ul>
                            
                    <li>
                        <a href="#%e5%91%bd%e5%90%8d" aria-label="命名">命名</a></li>
                    <li>
                        <a href="#%e8%be%93%e5%85%a5%e5%8f%82%e6%95%b0" aria-label="输入参数">输入参数</a></li>
                    <li>
                        <a href="#%e8%bf%94%e5%9b%9e%e5%80%bc" aria-label="返回值">返回值</a></li></ul>
                    </li></ul>
                    </li>
                    <li>
                        <a href="#%e8%87%aa%e5%ae%9a%e4%b9%89%e6%8c%87%e4%bb%a4" aria-label="自定义指令">自定义指令</a></li>
                    <li>
                        <a href="#%e8%b7%af%e7%94%b1" aria-label="路由">路由</a><ul>
                            
                    <li>
                        <a href="#%e6%8d%95%e8%8e%b7%e6%89%80%e6%9c%89%e8%b7%af%e7%94%b1%e6%88%96-404-not-found-%e8%b7%af%e7%94%b1" aria-label="捕获所有路由或 404 Not found 路由">捕获所有路由或 404 Not found 路由</a></li>
                    <li>
                        <a href="#%e8%b7%af%e7%94%b1%e7%9a%84%e5%8c%b9%e9%85%8d%e8%af%ad%e6%b3%95" aria-label="路由的匹配语法">路由的匹配语法</a><ul>
                            
                    <li>
                        <a href="#%e5%9c%a8%e5%8f%82%e6%95%b0%e4%b8%ad%e8%87%aa%e5%ae%9a%e4%b9%89%e6%ad%a3%e5%88%99" aria-label="在参数中自定义正则">在参数中自定义正则</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e7%bc%96%e7%a8%8b%e5%bc%8f%e5%af%bc%e8%88%aa" aria-label="编程式导航">编程式导航</a></li>
                    <li>
                        <a href="#%e5%91%bd%e5%90%8d%e8%a7%86%e5%9b%be" aria-label="命名视图">命名视图</a><ul>
                            
                    <li>
                        <a href="#%e5%b5%8c%e5%a5%97%e5%91%bd%e5%90%8d%e8%a7%86%e5%9b%be" aria-label="嵌套命名视图">嵌套命名视图</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e5%af%bc%e8%88%aa%e5%ae%88%e5%8d%ab" aria-label="导航守卫">导航守卫</a></li>
                    <li>
                        <a href="#%e8%b7%af%e7%94%b1%e6%87%92%e5%8a%a0%e8%bd%bd" aria-label="路由懒加载">路由懒加载</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e7%8a%b6%e6%80%81%e7%ae%a1%e7%90%86" aria-label="状态管理">状态管理</a><ul>
                            
                    <li>
                        <a href="#pinia" aria-label="Pinia">Pinia</a><ul>
                            
                    <li>
                        <a href="#%e5%ae%89%e8%a3%85" aria-label="安装">安装</a></li>
                    <li>
                        <a href="#store" aria-label="Store">Store</a></li>
                    <li>
                        <a href="#state" aria-label="State">State</a></li>
                    <li>
                        <a href="#getters" aria-label="Getters">Getters</a></li>
                    <li>
                        <a href="#actions" aria-label="Actions">Actions</a></li></ul>
                    </li>
                    <li>
                        <a href="#vuex" aria-label="Vuex">Vuex</a></li></ul>
                    </li>
                    <li>
                        <a href="#typescript-%e4%b8%8e%e7%bb%84%e5%90%88%e5%bc%8f-api" aria-label="TypeScript 与组合式 API">TypeScript 与组合式 API</a><ul>
                            
                    <li>
                        <a href="#%e4%b8%ba%e7%bb%84%e4%bb%b6%e7%9a%84-props-%e6%a0%87%e6%b3%a8%e7%b1%bb%e5%9e%8b" aria-label="为组件的 props 标注类型">为组件的 props 标注类型</a></li></ul>
                    </li>
                    <li>
                        <a href="#typescript-%e4%b8%8e%e9%80%89%e9%a1%b9%e5%bc%8f-api" aria-label="TypeScript 与选项式 API">TypeScript 与选项式 API</a><ul>
                            
                    <li>
                        <a href="#%e4%b8%ba%e7%bb%84%e4%bb%b6%e7%9a%84-props-%e6%a0%87%e6%b3%a8%e7%b1%bb%e5%9e%8b-1" aria-label="为组件的 props 标注类型">为组件的 props 标注类型</a>
                    </li>
                </ul>
                </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>
  <div class="post-content"><blockquote>
<p>参考链接：</p>
<p><a href="https://juejin.cn/post/7121596766893867016">一个 Java 猿眼中 Vue3 和 Vue2 的差异</a></p>
<p><a href="https://juejin.cn/post/6892295955844956167">（建议收藏）Vue3 对比 Vue2.x 差异性、注意点、整体梳理，与React hook比又如何？（面试热点）</a></p>
<p><a href="https://juejin.cn/post/7117525259212816414">Vue2升级到Vue3到底是不是一个正确的选择？(尤雨溪亲自回复解读)</a></p>
</blockquote>
<h2 id="选项式api和组合式api">选项式API和组合式API<a hidden class="anchor" aria-hidden="true" href="#选项式api和组合式api">#</a></h2>
<h3 id="选项式-api-options-api">选项式 API (Options API)<a hidden class="anchor" aria-hidden="true" href="#选项式-api-options-api">#</a></h3>
<p>使用选项式 API，我们可以用包含多个选项的对象来描述组件的逻辑，例如 <code>data</code>、<code>methods</code> 和 <code>mounted</code>。选项所定义的属性都会暴露在函数内部的 <code>this</code> 上，它会指向当前的组件实例。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-vue" data-lang="vue"><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">script</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="k">default</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// data() 返回的属性将会成为响应式的状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 并且暴露在 `this` 上
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">data</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">count</span><span class="o">:</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// methods 是一些用来更改状态与触发更新的函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 它们可以在模板中作为事件监听器绑定
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">methods</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">increment</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">this</span><span class="p">.</span><span class="nx">count</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 生命周期钩子会在组件生命周期的各个不同阶段被调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 例如这个函数就会在组件挂载完成后被调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">mounted</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`The initial count is </span><span class="si">${</span><span class="k">this</span><span class="p">.</span><span class="nx">count</span><span class="si">}</span><span class="sb">.`</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">template</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">&lt;</span><span class="nt">button</span> <span class="nt">@click</span><span class="s">=&#34;increment&#34;</span><span class="p">&gt;</span><span class="na">Count</span> <span class="na">is</span><span class="o">:</span> <span class="p">{{</span> <span class="na">count</span> <span class="p">}}&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;/</span><span class="nt">template</span><span class="p">&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="组合式-api-composition-api">组合式 API (Composition API)<a hidden class="anchor" aria-hidden="true" href="#组合式-api-composition-api">#</a></h3>
<p>通过组合式 API，我们可以使用导入的 API 函数来描述组件逻辑。在单文件组件中，组合式 API 通常会与 <code>&lt;script setup&gt;</code> 搭配使用。这个 <code>setup</code> attribute 是一个标识，告诉 Vue 需要在编译时进行一些处理，让我们可以更简洁地使用组合式 API。比如，<code>&lt;script setup&gt;</code> 中的导入和顶层变量/函数都能够在模板中直接使用。</p>
<p>下面是使用了组合式 API 与 <code>&lt;script setup&gt;</code> 改造后和上面的模板完全一样的组件：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-vue" data-lang="vue"><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">script</span> <span class="na">setup</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="p">{</span> <span class="nx">ref</span><span class="p">,</span> <span class="nx">onMounted</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;vue&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 响应式状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">count</span> <span class="o">=</span> <span class="nx">ref</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 用来修改状态、触发更新的函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">function</span> <span class="nx">increment</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">count</span><span class="p">.</span><span class="nx">value</span><span class="o">++</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 生命周期钩子
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">onMounted</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`The initial count is </span><span class="si">${</span><span class="nx">count</span><span class="p">.</span><span class="nx">value</span><span class="si">}</span><span class="sb">.`</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">template</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">&lt;</span><span class="nt">button</span> <span class="nt">@click</span><span class="s">=&#34;increment&#34;</span><span class="p">&gt;</span><span class="na">Count</span> <span class="na">is</span><span class="o">:</span> <span class="p">{{</span> <span class="na">count</span> <span class="p">}}&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;/</span><span class="nt">template</span><span class="p">&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="区别">区别<a hidden class="anchor" aria-hidden="true" href="#区别">#</a></h3>
<blockquote>
<p>参考链接</p>
<p><a href="https://juejin.cn/post/6966606592024576013">vue3学习（2）选项式API和组合式API的区别</a></p>
</blockquote>
<h2 id="响应式">响应式<a hidden class="anchor" aria-hidden="true" href="#响应式">#</a></h2>
<h3 id="setup">setup()<a hidden class="anchor" aria-hidden="true" href="#setup">#</a></h3>
<h3 id="reactive">reactive<a hidden class="anchor" aria-hidden="true" href="#reactive">#</a></h3>
<p><a href="https://blog.csdn.net/weixin_47886687/article/details/112918795">https://blog.csdn.net/weixin_47886687/article/details/112918795</a></p>
<h3 id="torefs">toRefs<a hidden class="anchor" aria-hidden="true" href="#torefs">#</a></h3>
<h3 id="ref">ref<a hidden class="anchor" aria-hidden="true" href="#ref">#</a></h3>
<p>在setup函数中，可以使用ref函数，用于创建一个响应式数据，当数据发生改变时，Vue会自动更新UI</p>
<blockquote>
<p>参考链接：</p>
<p><a href="https://blog.csdn.net/qq_37968920/article/details/115544694">Vue3.0 reactive()、ref()、unref()、isref()、toRefs()、computed()</a></p>
</blockquote>
<h3 id="reactive-vs-ref">reactive vs ref<a hidden class="anchor" aria-hidden="true" href="#reactive-vs-ref">#</a></h3>
<ul>
<li>reactive参数一般接受<strong>对象或数组</strong>，是深层次的响应式。ref参数一般接收<strong>简单数据类型</strong>，若ref接收对象为参数，本质上会转变为reactive方法</li>
<li>在JS中访问ref的值需要手动添加<code>.value</code>，访问reactive不需要</li>
<li>响应式的底层原理都是Proxy</li>
</ul>
<h2 id="计算属性">计算属性<a hidden class="anchor" aria-hidden="true" href="#计算属性">#</a></h2>
<h3 id="计算属性缓存-vs-方法">计算属性缓存 vs 方法<a hidden class="anchor" aria-hidden="true" href="#计算属性缓存-vs-方法">#</a></h3>
<p>你可能注意到我们在表达式中像这样调用一个函数也会获得和计算属性相同的结果：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-html" data-lang="html"><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>{{ calculateBooksMessage() }}<span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 组件中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">methods</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">calculateBooksMessage</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">author</span><span class="p">.</span><span class="nx">books</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="s1">&#39;Yes&#39;</span> <span class="o">:</span> <span class="s1">&#39;No&#39;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>若我们将同样的函数定义为一个方法而不是计算属性，两种方式在结果上确实是完全相同的，然而，不同之处在于<strong>计算属性值会基于其响应式依赖被缓存</strong>。一个计算属性仅会在其响应式依赖更新时才重新计算。这意味着只要 <code>author.books</code> 不改变，无论多少次访问 <code>publishedBooksMessage</code> 都会立即返回先前的计算结果，而不用重复执行 getter 函数。</p>
<p>这也解释了为什么下面的计算属性永远不会更新，因为 <code>Date.now()</code> 并不是一个响应式依赖：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">computed</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">now</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">Date</span><span class="p">.</span><span class="nx">now</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>相比之下，方法调用<strong>总是</strong>会在重渲染发生时再次执行函数。</p>
<p>为什么需要缓存呢？想象一下我们有一个非常耗性能的计算属性 <code>list</code>，需要循环一个巨大的数组并做许多计算逻辑，并且可能也有其他计算属性依赖于 <code>list</code>。没有缓存的话，我们会重复执行非常多次 <code>list</code> 的计算函数，然而这实际上没有必要！如果你确定不需要缓存，那么也可以使用方法调用。</p>
<h3 id="可写计算属性">可写计算属性<a hidden class="anchor" aria-hidden="true" href="#可写计算属性">#</a></h3>
<p>计算属性默认仅能通过计算函数得出结果。当你尝试修改一个计算属性时，你会收到一个运行时警告。只在某些特殊场景中你可能才需要用到“可写”的属性，你可以通过同时提供 getter 和 setter 来创建：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">export</span> <span class="k">default</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">data</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">firstName</span><span class="o">:</span> <span class="s1">&#39;John&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nx">lastName</span><span class="o">:</span> <span class="s1">&#39;Doe&#39;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl">  <span class="nx">computed</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">fullName</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// getter
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nx">get</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">firstName</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">lastName</span>
</span></span><span class="line"><span class="cl">      <span class="p">},</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// setter
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nx">set</span><span class="p">(</span><span class="nx">newValue</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 注意：我们这里使用的是解构赋值语法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">[</span><span class="k">this</span><span class="p">.</span><span class="nx">firstName</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">lastName</span><span class="p">]</span> <span class="o">=</span> <span class="nx">newValue</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>现在当你再运行 <code>this.fullName = 'John Doe'</code> 时，setter 会被调用而 <code>this.firstName</code> 和 <code>this.lastName</code> 会随之更新。</p>
<h3 id="最佳实践">最佳实践<a hidden class="anchor" aria-hidden="true" href="#最佳实践">#</a></h3>
<h4 id="计算函数不应有副作用">计算函数不应有副作用<a hidden class="anchor" aria-hidden="true" href="#计算函数不应有副作用">#</a></h4>
<p>计算属性的计算函数应只做计算而没有任何其他的副作用，这一点非常重要，请务必牢记。举例来说，<strong>不要在计算函数中做异步请求或者更改 DOM</strong>！一个计算属性的声明中描述的是如何根据其他值派生一个值。因此计算函数的职责应该仅为计算和返回该值。在之后的指引中我们会讨论如何使用<a href="https://cn.vuejs.org/guide/essentials/watchers.html">监听器</a>根据其他响应式状态的变更来创建副作用。</p>
<h4 id="避免直接修改计算属性值">避免直接修改计算属性值<a hidden class="anchor" aria-hidden="true" href="#避免直接修改计算属性值">#</a></h4>
<p>从计算属性返回的值是派生状态。可以把它看作是一个“临时快照”，每当源状态发生变化时，就会创建一个新的快照。更改快照是没有意义的，因此计算属性的返回值应该被视为只读的，并且永远不应该被更改——应该更新它所依赖的源状态以触发新的计算。</p>
<h2 id="条件渲染">条件渲染<a hidden class="anchor" aria-hidden="true" href="#条件渲染">#</a></h2>
<h3 id="v-if-和-v-for"><code>v-if</code> 和 <code>v-for</code><a hidden class="anchor" aria-hidden="true" href="#v-if-和-v-for">#</a></h3>
<blockquote>
<p>警告</p>
<p>同时使用 <code>v-if</code> 和 <code>v-for</code> 是<strong>不推荐的</strong>，因为这样二者的优先级不明显。查看<a href="https://cn.vuejs.org/style-guide/#avoid-v-if-with-v-for-essential">风格指南</a>获得更多信息。</p>
</blockquote>
<p>当 <code>v-if</code> 和 <code>v-for</code> 同时存在于一个元素上的时候，<code>v-if</code> 会首先被执行。</p>
<p>当它们同时存在于一个节点上时，<code>v-if</code> 比 <code>v-for</code> 的优先级更高。这意味着 <code>v-if</code> 的条件将无法访问到 <code>v-for</code> 作用域内定义的变量别名：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-html" data-lang="html"><span class="line"><span class="cl"><span class="c">&lt;!--
</span></span></span><span class="line"><span class="cl"><span class="c"> 这会抛出一个错误，因为属性 todo 此时
</span></span></span><span class="line"><span class="cl"><span class="c"> 没有在该实例上定义
</span></span></span><span class="line"><span class="cl"><span class="c">--&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">li</span> <span class="na">v-for</span><span class="o">=</span><span class="s">&#34;todo in todos&#34;</span> <span class="na">v-if</span><span class="o">=</span><span class="s">&#34;!todo.isComplete&#34;</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">  {{ todo.name }}
</span></span><span class="line"><span class="cl"><span class="p">&lt;/</span><span class="nt">li</span><span class="p">&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在外新包装一层 <code>&lt;template&gt;</code> 再在其上使用 <code>v-for</code> 可以解决这个问题 (这也更加明显易读)：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-html" data-lang="html"><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">template</span> <span class="na">v-for</span><span class="o">=</span><span class="s">&#34;todo in todos&#34;</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">&lt;</span><span class="nt">li</span> <span class="na">v-if</span><span class="o">=</span><span class="s">&#34;!todo.isComplete&#34;</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">    {{ todo.name }}
</span></span><span class="line"><span class="cl">  <span class="p">&lt;/</span><span class="nt">li</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;/</span><span class="nt">template</span><span class="p">&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="列表渲染">列表渲染<a hidden class="anchor" aria-hidden="true" href="#列表渲染">#</a></h2>
<h3 id="组件上使用-v-for">组件上使用 <code>v-for</code><a hidden class="anchor" aria-hidden="true" href="#组件上使用-v-for">#</a></h3>
<p>我们可以直接在组件上使用 <code>v-for</code>，和在一般的元素上使用没有区别 (别忘记提供一个 <code>key</code>)：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-html" data-lang="html"><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">MyComponent</span> <span class="na">v-for</span><span class="o">=</span><span class="s">&#34;item in items&#34;</span> <span class="na">:key</span><span class="o">=</span><span class="s">&#34;item.id&#34;</span> <span class="p">/&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>但是，这不会自动将任何数据传递给组件，因为组件有自己独立的作用域。为了将迭代后的数据传递到组件中，我们还需要传递 props：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-html" data-lang="html"><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">MyComponent</span>
</span></span><span class="line"><span class="cl">  <span class="na">v-for</span><span class="o">=</span><span class="s">&#34;(item, index) in items&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="na">:item</span><span class="o">=</span><span class="s">&#34;item&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="na">:index</span><span class="o">=</span><span class="s">&#34;index&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="na">:key</span><span class="o">=</span><span class="s">&#34;item.id&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">/&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>不自动将 <code>item</code> 注入组件的原因是，这会使组件与 <code>v-for</code> 的工作方式紧密耦合。明确其数据的来源可以使组件在其他情况下重用。</p>
<h3 id="展示过滤或排序后的结果">展示过滤或排序后的结果<a hidden class="anchor" aria-hidden="true" href="#展示过滤或排序后的结果">#</a></h3>
<p>有时，我们希望显示数组经过过滤或排序后的内容，而不实际变更或重置原始数据。在这种情况下，你可以创建返回已过滤或已排序数组的计算属性。</p>
<p>举例来说：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">data</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">numbers</span><span class="o">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">},</span>
</span></span><span class="line"><span class="cl"><span class="nx">computed</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">evenNumbers</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">numbers</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">n</span> <span class="p">=&gt;</span> <span class="nx">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-html" data-lang="html"><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">li</span> <span class="na">v-for</span><span class="o">=</span><span class="s">&#34;n in evenNumbers&#34;</span><span class="p">&gt;</span>{{ n }}<span class="p">&lt;/</span><span class="nt">li</span><span class="p">&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在计算属性不可行的情况下 (例如在多层嵌套的 <code>v-for</code> 循环中)，你可以使用以下方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">data</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">sets</span><span class="o">:</span> <span class="p">[[</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span> <span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">]]</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">},</span>
</span></span><span class="line"><span class="cl"><span class="nx">methods</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">even</span><span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">numbers</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">number</span> <span class="p">=&gt;</span> <span class="nx">number</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-html" data-lang="html"><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">ul</span> <span class="na">v-for</span><span class="o">=</span><span class="s">&#34;numbers in sets&#34;</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">&lt;</span><span class="nt">li</span> <span class="na">v-for</span><span class="o">=</span><span class="s">&#34;n in even(numbers)&#34;</span><span class="p">&gt;</span>{{ n }}<span class="p">&lt;/</span><span class="nt">li</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;/</span><span class="nt">ul</span><span class="p">&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在计算属性中使用 <code>reverse()</code> 和 <code>sort()</code> 的时候务必小心！这两个方法将变更原始数组，计算函数中不应该这么做。请在调用这些方法之前创建一个原数组的副本：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-diff" data-lang="diff"><span class="line"><span class="cl"><span class="gd">- return numbers.reverse()
</span></span></span><span class="line"><span class="cl"><span class="gd"></span><span class="gi">+ return [...numbers].reverse()
</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="事件处理">事件处理<a hidden class="anchor" aria-hidden="true" href="#事件处理">#</a></h2>
<h3 id="在内联事件处理器中访问事件参数">在内联事件处理器中访问事件参数<a hidden class="anchor" aria-hidden="true" href="#在内联事件处理器中访问事件参数">#</a></h3>
<p>有时我们需要在内联事件处理器中访问原生 DOM 事件。你可以向该处理器方法传入一个特殊的 <code>$event</code> 变量，或者使用内联箭头函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-html" data-lang="html"><span class="line"><span class="cl"><span class="c">&lt;!-- 使用特殊的 $event 变量 --&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">button</span> <span class="err">@</span><span class="na">click</span><span class="o">=</span><span class="s">&#34;warn(&#39;Form cannot be submitted yet.&#39;, $event)&#34;</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">  Submit
</span></span><span class="line"><span class="cl"><span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">&lt;!-- 使用内联箭头函数 --&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">button</span> <span class="err">@</span><span class="na">click</span><span class="o">=</span><span class="s">&#34;(event) =&gt; warn(&#39;Form cannot be submitted yet.&#39;, event)&#34;</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">  Submit
</span></span><span class="line"><span class="cl"><span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">methods</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">warn</span><span class="p">(</span><span class="nx">message</span><span class="p">,</span> <span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 这里可以访问 DOM 原生事件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">event</span><span class="p">.</span><span class="nx">preventDefault</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">alert</span><span class="p">(</span><span class="nx">message</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="事件修饰符">事件修饰符<a hidden class="anchor" aria-hidden="true" href="#事件修饰符">#</a></h3>
<p>在处理事件时调用 <code>event.preventDefault()</code> 或 <code>event.stopPropagation()</code> 是很常见的。尽管我们可以直接在方法内调用，但如果方法能更专注于数据逻辑而不用去处理 DOM 事件的细节会更好。</p>
<p>为解决这一问题，Vue 为 <code>v-on</code> 提供了<strong>事件修饰符</strong>。修饰符是用 <code>.</code> 表示的指令后缀，包含以下这些：</p>
<ul>
<li><code>.stop</code></li>
<li><code>.prevent</code></li>
<li><code>.self</code></li>
<li><code>.capture</code></li>
<li><code>.once</code></li>
<li><code>.passive</code></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-html" data-lang="html"><span class="line"><span class="cl"><span class="c">&lt;!-- 单击事件将停止传递 --&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">a</span> <span class="err">@</span><span class="na">click</span><span class="err">.</span><span class="na">stop</span><span class="o">=</span><span class="s">&#34;doThis&#34;</span><span class="p">&gt;&lt;/</span><span class="nt">a</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">&lt;!-- 提交事件将不再重新加载页面 --&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">form</span> <span class="err">@</span><span class="na">submit</span><span class="err">.</span><span class="na">prevent</span><span class="o">=</span><span class="s">&#34;onSubmit&#34;</span><span class="p">&gt;&lt;/</span><span class="nt">form</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">&lt;!-- 修饰语可以使用链式书写 --&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">a</span> <span class="err">@</span><span class="na">click</span><span class="err">.</span><span class="na">stop</span><span class="err">.</span><span class="na">prevent</span><span class="o">=</span><span class="s">&#34;doThat&#34;</span><span class="p">&gt;&lt;/</span><span class="nt">a</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">&lt;!-- 也可以只有修饰符 --&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">form</span> <span class="err">@</span><span class="na">submit</span><span class="err">.</span><span class="na">prevent</span><span class="p">&gt;&lt;/</span><span class="nt">form</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">&lt;!-- 仅当 event.target 是元素本身时才会触发事件处理器 --&gt;</span>
</span></span><span class="line"><span class="cl"><span class="c">&lt;!-- 例如：事件处理器不来自子元素 --&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">div</span> <span class="err">@</span><span class="na">click</span><span class="err">.</span><span class="na">self</span><span class="o">=</span><span class="s">&#34;doThat&#34;</span><span class="p">&gt;</span>...<span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p><strong>TIP</strong></p>
<p>使用修饰符时需要注意调用顺序，因为相关代码是以相同的顺序生成的。因此使用 <code>@click.prevent.self</code> 会阻止<strong>元素及其子元素的所有点击事件的默认行为</strong>而 <code>@click.self.prevent</code> 则只会阻止对元素本身的点击事件的默认行为。</p>
</blockquote>
<h3 id="按键修饰符">按键修饰符<a hidden class="anchor" aria-hidden="true" href="#按键修饰符">#</a></h3>
<p>在监听键盘事件时，我们经常需要检查特定的按键。Vue 允许在 <code>v-on</code> 或 <code>@</code> 监听按键事件时添加按键修饰符。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-html" data-lang="html"><span class="line"><span class="cl"><span class="c">&lt;!-- 仅在 `key` 为 `Enter` 时调用 `submit` --&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">input</span> <span class="err">@</span><span class="na">keyup</span><span class="err">.</span><span class="na">enter</span><span class="o">=</span><span class="s">&#34;submit&#34;</span> <span class="p">/&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>你可以直接使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/KeyboardEvent/key/Key_Values"><code>KeyboardEvent.key</code></a> 暴露的按键名称作为修饰符，但需要转为 kebab-case 形式。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-html" data-lang="html"><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">input</span> <span class="err">@</span><span class="na">keyup</span><span class="err">.</span><span class="na">page-down</span><span class="o">=</span><span class="s">&#34;onPageDown&#34;</span> <span class="p">/&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在上面的例子中，仅会在 <code>$event.key</code> 为 <code>'PageDown'</code> 时调用事件处理。</p>
<h4 id="按键别名">按键别名<a hidden class="anchor" aria-hidden="true" href="#按键别名">#</a></h4>
<p>Vue 为一些常用的按键提供了别名：</p>
<ul>
<li><code>.enter</code></li>
<li><code>.tab</code></li>
<li><code>.delete</code> (捕获“Delete”和“Backspace”两个按键)</li>
<li><code>.esc</code></li>
<li><code>.space</code></li>
<li><code>.up</code></li>
<li><code>.down</code></li>
<li><code>.left</code></li>
<li><code>.right</code></li>
</ul>
<h4 id="系统按键修饰符">系统按键修饰符<a hidden class="anchor" aria-hidden="true" href="#系统按键修饰符">#</a></h4>
<p>你可以使用以下系统按键修饰符来触发鼠标或键盘事件监听器，只有当按键被按下时才会触发。</p>
<ul>
<li><code>.ctrl</code></li>
<li><code>.alt</code></li>
<li><code>.shift</code></li>
<li><code>.meta</code></li>
</ul>
<p>注意</p>
<p>在 Mac 键盘上，meta 是 Command 键 (⌘)。在 Windows 键盘上，meta 键是 Windows 键 (⊞)。在 Sun 微机系统键盘上，meta 是钻石键 (◆)。在某些键盘上，特别是 MIT 和 Lisp 机器的键盘及其后代版本的键盘，如 Knight 键盘，space-cadet 键盘，meta 都被标记为“META”。在 Symbolics 键盘上，meta 也被标识为“META”或“Meta”。</p>
<p>举例来说：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-html" data-lang="html"><span class="line"><span class="cl"><span class="c">&lt;!-- Alt + Enter --&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">input</span> <span class="err">@</span><span class="na">keyup</span><span class="err">.</span><span class="na">alt</span><span class="err">.</span><span class="na">enter</span><span class="o">=</span><span class="s">&#34;clear&#34;</span> <span class="p">/&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">&lt;!-- Ctrl + 点击 --&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">div</span> <span class="err">@</span><span class="na">click</span><span class="err">.</span><span class="na">ctrl</span><span class="o">=</span><span class="s">&#34;doSomething&#34;</span><span class="p">&gt;</span>Do something<span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p><strong>TIP</strong></p>
<p>请注意，系统按键修饰符和常规按键不同。与 <code>keyup</code> 事件一起使用时，该按键必须在事件发出时处于按下状态。换句话说，<code>keyup.ctrl</code> 只会在你仍然按住 <code>ctrl</code> 但松开了另一个键时被触发。若你单独松开 <code>ctrl</code> 键将不会触发。</p>
</blockquote>
<h4 id="exact-修饰符"><code>.exact</code> 修饰符<a hidden class="anchor" aria-hidden="true" href="#exact-修饰符">#</a></h4>
<p><code>.exact</code> 修饰符允许控制触发一个事件所需的确定组合的系统按键修饰符。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-html" data-lang="html"><span class="line"><span class="cl"><span class="c">&lt;!-- 当按下 Ctrl 时，即使同时按下 Alt 或 Shift 也会触发 --&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">button</span> <span class="err">@</span><span class="na">click</span><span class="err">.</span><span class="na">ctrl</span><span class="o">=</span><span class="s">&#34;onClick&#34;</span><span class="p">&gt;</span>A<span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">&lt;!-- 仅当按下 Ctrl 且未按任何其他键时才会触发 --&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">button</span> <span class="err">@</span><span class="na">click</span><span class="err">.</span><span class="na">ctrl</span><span class="err">.</span><span class="na">exact</span><span class="o">=</span><span class="s">&#34;onCtrlClick&#34;</span><span class="p">&gt;</span>A<span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">&lt;!-- 仅当没有按下任何系统按键时触发 --&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">button</span> <span class="err">@</span><span class="na">click</span><span class="err">.</span><span class="na">exact</span><span class="o">=</span><span class="s">&#34;onClick&#34;</span><span class="p">&gt;</span>A<span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="鼠标按键修饰符">鼠标按键修饰符<a hidden class="anchor" aria-hidden="true" href="#鼠标按键修饰符">#</a></h4>
<ul>
<li><code>.left</code></li>
<li><code>.right</code></li>
<li><code>.middle</code></li>
</ul>
<p>这些修饰符将处理程序限定为由特定鼠标按键触发的事件。</p>
<h2 id="生命周期">生命周期<a hidden class="anchor" aria-hidden="true" href="#生命周期">#</a></h2>
<p>所有生命周期钩子函数的 <code>this</code> 上下文都会自动指向当前调用它的组件实例。注意：<code>避免用箭头函数来定义生命周期钩子</code>，因为如果这样的话你将无法在函数中通过 <code>this</code> 获取组件实例。</p>
<img src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202307262325140.png" alt="组件生命周期图示" style="zoom: 50%;" /> 
<p>有关所有生命周期钩子及其各自用例的详细信息，请参考<a href="https://cn.vuejs.org/api/options-lifecycle.html">生命周期钩子 API 索引</a>。</p>
<h2 id="侦听器">侦听器<a hidden class="anchor" aria-hidden="true" href="#侦听器">#</a></h2>
<h3 id="深层侦听器">深层侦听器<a hidden class="anchor" aria-hidden="true" href="#深层侦听器">#</a></h3>
<p><code>watch</code> 默认是浅层的：被侦听的属性，仅在被赋新值时，才会触发回调函数——而嵌套属性的变化不会触发。如果想侦听所有嵌套的变更，你需要深层侦听器：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">export</span> <span class="k">default</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">watch</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">someObject</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">handler</span><span class="p">(</span><span class="nx">newValue</span><span class="p">,</span> <span class="nx">oldValue</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 注意：在嵌套的变更中，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 只要没有替换对象本身，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 那么这里的 `newValue` 和 `oldValue` 相同
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="p">},</span>
</span></span><span class="line"><span class="cl">      <span class="nx">deep</span><span class="o">:</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p><strong>谨慎使用</strong></p>
<p>深度侦听需要遍历被侦听对象中的所有嵌套的属性，当用于大型数据结构时，开销很大。因此请只在必要时才使用它，并且要留意性能。</p>
</blockquote>
<h3 id="即时回调的侦听器">即时回调的侦听器<a hidden class="anchor" aria-hidden="true" href="#即时回调的侦听器">#</a></h3>
<p><code>watch</code> 默认是懒执行的：仅当数据源变化时，才会执行回调。但在某些场景中，我们希望在创建侦听器时，立即执行一遍回调。举例来说，我们想请求一些初始数据，然后在相关状态更改时重新请求数据。</p>
<p>我们可以用一个对象来声明侦听器，这个对象有 <code>handler</code> 方法和 <code>immediate: true</code> 选项，这样便能强制回调函数立即执行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">export</span> <span class="k">default</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">watch</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">question</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">handler</span><span class="p">(</span><span class="nx">newQuestion</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 在组件实例创建时会立即调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="p">},</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 强制立即执行回调
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nx">immediate</span><span class="o">:</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="模板引用">模板引用<a hidden class="anchor" aria-hidden="true" href="#模板引用">#</a></h2>
<p>挂载结束后引用都会被暴露在 <code>this.$refs</code> 之上：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-vue" data-lang="vue"><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">script</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="k">default</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">mounted</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">$refs</span><span class="p">.</span><span class="nx">input</span><span class="p">.</span><span class="nx">focus</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">template</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">&lt;</span><span class="nt">input</span> <span class="na">ref</span><span class="o">=</span><span class="s">&#34;input&#34;</span> <span class="p">/&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;/</span><span class="nt">template</span><span class="p">&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>注意，你只可以<strong>在组件挂载后</strong>才能访问模板引用。如果你想在模板中的表达式上访问 <code>$refs.input</code>，在初次渲染时会是 <code>null</code>。这是因为在初次渲染前这个元素还不存在呢！</p>
<h2 id="组件基础">组件基础<a hidden class="anchor" aria-hidden="true" href="#组件基础">#</a></h2>
<h3 id="大小写区分">大小写区分<a hidden class="anchor" aria-hidden="true" href="#大小写区分">#</a></h3>
<p>HTML 标签和属性名称是不分大小写的，所以浏览器会把任何大写的字符解释为小写。这意味着当你使用 DOM 内的模板时，无论是 PascalCase 形式的组件名称、camelCase 形式的 prop 名称还是 v-on 的事件名称，都需要转换为相应等价的 kebab-case (短横线连字符) 形式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// JavaScript 中的 camelCase
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">BlogPost</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">props</span><span class="o">:</span> <span class="p">[</span><span class="s1">&#39;postTitle&#39;</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">  <span class="nx">emits</span><span class="o">:</span> <span class="p">[</span><span class="s1">&#39;updatePost&#39;</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">  <span class="nx">template</span><span class="o">:</span> <span class="sb">`
</span></span></span><span class="line"><span class="cl"><span class="sb">    &lt;h3&gt;{{ postTitle }}&lt;/h3&gt;
</span></span></span><span class="line"><span class="cl"><span class="sb">  `</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-vue" data-lang="vue"><span class="line"><span class="cl"><span class="c">&lt;!--</span> <span class="nx">HTML</span> <span class="nx">中的</span> <span class="nx">kebab</span><span class="o">-</span><span class="k">case</span> <span class="o">--&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">blog-post</span> <span class="na">post</span><span class="nt">-title</span><span class="err">=&#34;</span><span class="na">hello</span><span class="err">!&#34;</span> <span class="nt">@update-post</span><span class="s">=&#34;onUpdatePost&#34;</span><span class="p">&gt;</span><span class="o">&lt;</span><span class="err">/blog-post&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>参考链接：</p>
<p><a href="https://cn.vuejs.org/guide/essentials/component-basics.html#dom-template-parsing-caveats">DOM 模板解析注意事项</a></p>
</blockquote>
<h2 id="props">Props<a hidden class="anchor" aria-hidden="true" href="#props">#</a></h2>
<h3 id="boolean-类型转换"><strong>Boolean 类型转换</strong><a hidden class="anchor" aria-hidden="true" href="#boolean-类型转换">#</a></h3>
<p>为了更贴近原生 boolean attributes 的行为，声明为 <code>Boolean</code> 类型的 props 有特别的类型转换规则。以带有如下声明的 <code>&lt;MyComponent&gt;</code> 组件为例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">export</span> <span class="k">default</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">props</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">disabled</span><span class="o">:</span> <span class="nb">Boolean</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>该组件可以被这样使用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-vue" data-lang="vue"><span class="line"><span class="cl"><span class="c">&lt;!--</span> <span class="nx">等同于传入</span> <span class="o">:</span><span class="nx">disabled</span><span class="o">=</span><span class="s2">&#34;true&#34;</span> <span class="o">--&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">MyComponent</span> <span class="na">disabled</span> <span class="p">/&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">&lt;!--</span> <span class="nx">等同于传入</span> <span class="o">:</span><span class="nx">disabled</span><span class="o">=</span><span class="s2">&#34;false&#34;</span> <span class="o">--&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">MyComponent</span> <span class="p">/&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="事件">事件<a hidden class="anchor" aria-hidden="true" href="#事件">#</a></h2>
<h3 id="事件校验">事件校验<a hidden class="anchor" aria-hidden="true" href="#事件校验">#</a></h3>
<p>和对 props 添加类型校验的方式类似，所有触发的事件也可以使用对象形式来描述。</p>
<p>要为事件添加校验，那么事件可以被赋值为一个函数，接受的参数就是抛出事件时传入 <code>this.$emit</code> 的内容，返回一个布尔值来表明事件是否合法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">export</span> <span class="k">default</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">emits</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 没有校验
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">click</span><span class="o">:</span> <span class="kc">null</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 校验 submit 事件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">submit</span><span class="o">:</span> <span class="p">({</span> <span class="nx">email</span><span class="p">,</span> <span class="nx">password</span> <span class="p">})</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="nx">email</span> <span class="o">&amp;&amp;</span> <span class="nx">password</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">console</span><span class="p">.</span><span class="nx">warn</span><span class="p">(</span><span class="s1">&#39;Invalid submit event payload!&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl">  <span class="nx">methods</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">submitForm</span><span class="p">(</span><span class="nx">email</span><span class="p">,</span> <span class="nx">password</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">this</span><span class="p">.</span><span class="nx">$emit</span><span class="p">(</span><span class="s1">&#39;submit&#39;</span><span class="p">,</span> <span class="p">{</span> <span class="nx">email</span><span class="p">,</span> <span class="nx">password</span> <span class="p">})</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="配合-v-model-使用">配合 <code>v-model</code> 使用<a hidden class="anchor" aria-hidden="true" href="#配合-v-model-使用">#</a></h3>
<p><a href="https://cn.vuejs.org/guide/components/events.html#usage-with-v-model">https://cn.vuejs.org/guide/components/events.html#usage-with-v-model</a></p>
<h2 id="插槽">插槽<a hidden class="anchor" aria-hidden="true" href="#插槽">#</a></h2>
<h3 id="插槽内容与出口">插槽内容与出口<a hidden class="anchor" aria-hidden="true" href="#插槽内容与出口">#</a></h3>
<p>在之前的章节中，我们已经了解到组件能够接收任意类型的 JavaScript 值作为 props，但组件要如何接收模板内容呢？在某些场景中，我们可能想要为子组件传递一些模板片段，让子组件在它们的组件中渲染这些片段。</p>
<p>举例来说，这里有一个 <code>&lt;FancyButton&gt;</code> 组件，可以像这样使用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-vue" data-lang="vue"><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">FancyButton</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">Click</span> <span class="nx">me</span><span class="o">!</span> <span class="c">&lt;!--</span> <span class="nx">插槽内容</span> <span class="o">--&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;/</span><span class="nt">FancyButton</span><span class="p">&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>而 <code>&lt;FancyButton&gt;</code> 的模板是这样的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-vue" data-lang="vue"><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">button</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;fancy-btn&#34;</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">&lt;</span><span class="nt">slot</span><span class="p">&gt;&lt;/</span><span class="nt">slot</span><span class="p">&gt;</span> <span class="c">&lt;!--</span> <span class="nx">插槽出口</span> <span class="o">--&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>&lt;slot&gt;</code> 元素是一个<strong>插槽出口</strong> (slot outlet)，标示了父元素提供的<strong>插槽内容</strong> (slot content) 将在哪里被渲染。</p>
<img src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202307262325148.png" alt="插槽图示" style="zoom: 67%;" /> 
<p>最终渲染出的 DOM 是这样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-html" data-lang="html"><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">button</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;fancy-btn&#34;</span><span class="p">&gt;</span>Click me!<span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="具名插槽">具名插槽<a hidden class="anchor" aria-hidden="true" href="#具名插槽">#</a></h3>
<p>有时在一个组件中包含多个插槽出口是很有用的。举例来说，在一个 <code>&lt;BaseLayout&gt;</code> 组件中，有如下模板：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-vue" data-lang="vue"><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;container&#34;</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">&lt;</span><span class="nt">header</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="c">&lt;!--</span> <span class="nx">标题内容放这里</span> <span class="o">--&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">&lt;/</span><span class="nt">header</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">&lt;</span><span class="nt">main</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="c">&lt;!--</span> <span class="nx">主要内容放这里</span> <span class="o">--&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">&lt;/</span><span class="nt">main</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">&lt;</span><span class="nt">footer</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="c">&lt;!--</span> <span class="nx">底部内容放这里</span> <span class="o">--&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">&lt;/</span><span class="nt">footer</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>对于这种场景，<code>&lt;slot&gt;</code> 元素可以有一个特殊的 attribute <code>name</code>，用来给各个插槽分配唯一的 ID，以确定每一处要渲染的内容：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-vue" data-lang="vue"><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;container&#34;</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">&lt;</span><span class="nt">header</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">&lt;</span><span class="nt">slot</span> <span class="na">name</span><span class="o">=</span><span class="s">&#34;header&#34;</span><span class="p">&gt;&lt;/</span><span class="nt">slot</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">&lt;/</span><span class="nt">header</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">&lt;</span><span class="nt">main</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">&lt;</span><span class="nt">slot</span><span class="p">&gt;&lt;/</span><span class="nt">slot</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">&lt;/</span><span class="nt">main</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">&lt;</span><span class="nt">footer</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">&lt;</span><span class="nt">slot</span> <span class="na">name</span><span class="o">=</span><span class="s">&#34;footer&#34;</span><span class="p">&gt;&lt;/</span><span class="nt">slot</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">&lt;/</span><span class="nt">footer</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这类带 <code>name</code> 的插槽被称为具名插槽 (named slots)。没有提供 <code>name</code> 的 <code>&lt;slot&gt;</code> 出口会隐式地命名为“default”。</p>
<p>在父组件中使用 <code>&lt;BaseLayout&gt;</code> 时，我们需要一种方式将多个插槽内容传入到各自目标插槽的出口。此时就需要用到<strong>具名插槽</strong>了：</p>
<p>要为具名插槽传入内容，我们需要使用一个含 <code>v-slot</code> 指令的 <code>&lt;template&gt;</code> 元素，并将目标插槽的名字传给该指令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-vue" data-lang="vue"><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">BaseLayout</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">&lt;</span><span class="nt">template</span> <span class="na">v</span><span class="nt">-slot</span><span class="o">:</span><span class="na">header</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="c">&lt;!--</span> <span class="nx">header</span> <span class="nx">插槽的内容放这里</span> <span class="o">--&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">&lt;/</span><span class="nt">template</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;/</span><span class="nt">BaseLayout</span><span class="p">&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>v-slot</code> 有对应的简写 <code>#</code>，因此 <code>&lt;template v-slot:header&gt;</code> 可以简写为 <code>&lt;template #header&gt;</code>。其意思就是“将这部分模板片段传入子组件的 header 插槽中”。</p>
<img src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202307262325149.png" alt="具名插槽图示" style="zoom: 67%;" />
<p>下面我们给出完整的、向 <code>&lt;BaseLayout&gt;</code> 传递插槽内容的代码，指令均使用的是缩写形式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-vue" data-lang="vue"><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">BaseLayout</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">&lt;</span><span class="nt">template</span> <span class="err">#</span><span class="na">header</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">&lt;</span><span class="nt">h1</span><span class="p">&gt;</span><span class="nx">Here</span> <span class="nx">might</span> <span class="nx">be</span> <span class="nx">a</span> <span class="nx">page</span> <span class="nx">title</span><span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">&lt;/</span><span class="nt">template</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="p">&lt;</span><span class="nt">template</span> <span class="err">#</span><span class="na">default</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span><span class="nx">A</span> <span class="nx">paragraph</span> <span class="k">for</span> <span class="nx">the</span> <span class="nx">main</span> <span class="nx">content</span><span class="p">.&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span><span class="nx">And</span> <span class="nx">another</span> <span class="nx">one</span><span class="p">.&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">&lt;/</span><span class="nt">template</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="p">&lt;</span><span class="nt">template</span> <span class="err">#</span><span class="na">footer</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span><span class="nx">Here</span><span class="err">&#39;</span><span class="nx">s</span> <span class="nx">some</span> <span class="nx">contact</span> <span class="nx">info</span><span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">&lt;/</span><span class="nt">template</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;/</span><span class="nt">BaseLayout</span><span class="p">&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>当一个组件同时接收默认插槽和具名插槽时，所有位于顶级的非 <code>&lt;template&gt;</code> 节点都被隐式地视为默认插槽的内容。所以上面也可以写成：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-vue" data-lang="vue"><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">BaseLayout</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">&lt;</span><span class="nt">template</span> <span class="err">#</span><span class="na">header</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">&lt;</span><span class="nt">h1</span><span class="p">&gt;</span><span class="nx">Here</span> <span class="nx">might</span> <span class="nx">be</span> <span class="nx">a</span> <span class="nx">page</span> <span class="nx">title</span><span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">&lt;/</span><span class="nt">template</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c">&lt;!--</span> <span class="nx">隐式的默认插槽</span> <span class="o">--&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span><span class="nx">A</span> <span class="nx">paragraph</span> <span class="k">for</span> <span class="nx">the</span> <span class="nx">main</span> <span class="nx">content</span><span class="p">.&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span><span class="nx">And</span> <span class="nx">another</span> <span class="nx">one</span><span class="p">.&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="p">&lt;</span><span class="nt">template</span> <span class="err">#</span><span class="na">footer</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span><span class="nx">Here</span><span class="err">&#39;</span><span class="nx">s</span> <span class="nx">some</span> <span class="nx">contact</span> <span class="nx">info</span><span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">&lt;/</span><span class="nt">template</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;/</span><span class="nt">BaseLayout</span><span class="p">&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>现在 <code>&lt;template&gt;</code> 元素中的所有内容都将被传递到相应的插槽。最终渲染出的 HTML 如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-html" data-lang="html"><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;container&#34;</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">&lt;</span><span class="nt">header</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">&lt;</span><span class="nt">h1</span><span class="p">&gt;</span>Here might be a page title<span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">&lt;/</span><span class="nt">header</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">&lt;</span><span class="nt">main</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>A paragraph for the main content.<span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>And another one.<span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">&lt;/</span><span class="nt">main</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">&lt;</span><span class="nt">footer</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>Here&#39;s some contact info<span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">&lt;/</span><span class="nt">footer</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="作用域插槽">作用域插槽<a hidden class="anchor" aria-hidden="true" href="#作用域插槽">#</a></h3>
<p>在上面的<a href="https://cn.vuejs.org/guide/components/slots.html#render-scope">渲染作用域</a>中我们讨论到，插槽的内容无法访问到子组件的状态。</p>
<p>然而在某些场景下插槽的内容可能想要同时使用父组件域内和子组件域内的数据。要做到这一点，我们需要一种方法来让子组件在渲染时将一部分数据提供给插槽。</p>
<p>我们也确实有办法这么做！可以像对组件传递 props 那样，向一个插槽的出口上传递 attributes：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-vue" data-lang="vue"><span class="line"><span class="cl"><span class="c">&lt;!--</span> <span class="p">&lt;</span><span class="nt">MyComponent</span><span class="p">&gt;</span> <span class="nx">的模板</span> <span class="o">--&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">&lt;</span><span class="nt">slot</span> <span class="nt">:text</span><span class="s">=&#34;greetingMessage&#34;</span> <span class="nt">:count</span><span class="s">=&#34;1&#34;</span><span class="p">&gt;&lt;/</span><span class="nt">slot</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>当需要接收插槽 props 时，默认插槽和具名插槽的使用方式有一些小区别。下面我们将先展示默认插槽如何接受 props，通过子组件标签上的 <code>v-slot</code> 指令，直接接收到了一个插槽 props 对象：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-vue" data-lang="vue"><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">MyComponent</span> <span class="nt">v-slot</span><span class="s">=&#34;slotProps&#34;</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">{{</span> <span class="na">slotProps.text</span> <span class="p">}}</span> <span class="p">{{</span> <span class="na">slotProps.count</span> <span class="p">}}</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;/</span><span class="nt">MyComponent</span><span class="p">&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这类能够接受参数的插槽被称为作用域插槽 (scoped slots)，因为它们接受的参数只在该插槽作用域内有效。</p>
<img src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202307262325153.png" alt="image-20220904142036637"  />
<h4 id="高级列表组件示例">高级列表组件示例<a hidden class="anchor" aria-hidden="true" href="#高级列表组件示例">#</a></h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-vue" data-lang="vue"><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">FancyList</span> <span class="nt">:api-url</span><span class="s">=&#34;url&#34;</span> <span class="nt">:per-page</span><span class="s">=&#34;10&#34;</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">&lt;</span><span class="nt">template</span> <span class="err">#</span><span class="na">item</span><span class="o">=</span><span class="s">&#34;{ body, username, likes }&#34;</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;item&#34;</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;{{</span> <span class="nx">body</span> <span class="p">}}&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span><span class="nx">by</span> <span class="p">{{</span> <span class="nx">username</span> <span class="p">}}</span> <span class="o">|</span> <span class="p">{{</span> <span class="nx">likes</span> <span class="p">}}</span> <span class="nx">likes</span><span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">&lt;/</span><span class="nt">template</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;/</span><span class="nt">FancyList</span><span class="p">&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 <code>&lt;FancyList&gt;</code> 之中，我们可以多次渲染 <code>&lt;slot&gt;</code> 并每次都提供不同的数据 (注意我们这里使用了 <code>v-bind</code> 来传递插槽的 props)：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-vue" data-lang="vue"><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">ul</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">&lt;</span><span class="nt">li</span> <span class="nt">v-for</span><span class="s">=&#34;item in items&#34;&gt;
</span></span></span><span class="line"><span class="cl"><span class="s">    &lt;slot name=&#34;item&#34; v-bind=&#34;item&#34;</span><span class="p">&gt;&lt;/</span><span class="nt">slot</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">&lt;/</span><span class="nt">li</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;/</span><span class="nt">ul</span><span class="p">&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>小提示：<a href="https://cn.vuejs.org/guide/essentials/template-syntax.html#dynamically-binding-multiple-attributes">没有参数的 <code>v-bind</code></a> 会将一个对象的所有属性都作为 attribute 应用到目标元素上。</p>
</blockquote>
<h2 id="依赖注入">依赖注入<a hidden class="anchor" aria-hidden="true" href="#依赖注入">#</a></h2>
<p>一个父组件相对于其所有的后代组件，会作为<strong>依赖提供者</strong>。任何后代的组件树，无论层级有多深，都可以<strong>注入</strong>由父组件提供给整条链路的依赖。</p>
<img src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202307262325156.png" alt="Provide/inject 模式" style="zoom:67%;" /> 
<h2 id="组合式函数">组合式函数<a hidden class="anchor" aria-hidden="true" href="#组合式函数">#</a></h2>
<h3 id="鼠标跟踪器示例">鼠标跟踪器示例<a hidden class="anchor" aria-hidden="true" href="#鼠标跟踪器示例">#</a></h3>
<p>如果我们要直接在组件中使用组合式 API 实现鼠标跟踪功能，它会是这样的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-vue" data-lang="vue"><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">script</span> <span class="na">setup</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="p">{</span> <span class="nx">ref</span><span class="p">,</span> <span class="nx">onMounted</span><span class="p">,</span> <span class="nx">onUnmounted</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;vue&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">ref</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">ref</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">update</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">x</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">pageX</span>
</span></span><span class="line"><span class="cl">  <span class="nx">y</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">pageY</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">onMounted</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nb">window</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">&#39;mousemove&#39;</span><span class="p">,</span> <span class="nx">update</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="nx">onUnmounted</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nb">window</span><span class="p">.</span><span class="nx">removeEventListener</span><span class="p">(</span><span class="s1">&#39;mousemove&#39;</span><span class="p">,</span> <span class="nx">update</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">template</span><span class="p">&gt;</span><span class="nx">Mouse</span> <span class="nx">position</span> <span class="nx">is</span> <span class="nx">at</span><span class="o">:</span> <span class="p">{{</span> <span class="nx">x</span> <span class="p">}},</span> <span class="p">{{</span> <span class="nx">y</span> <span class="p">}}&lt;/</span><span class="nt">template</span><span class="p">&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>但是，如果我们想在多个组件中复用这个相同的逻辑呢？我们可以把这个逻辑以一个组合式函数的形式提取到外部文件中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// mouse.js
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">import</span> <span class="p">{</span> <span class="nx">ref</span><span class="p">,</span> <span class="nx">onMounted</span><span class="p">,</span> <span class="nx">onUnmounted</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;vue&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 按照惯例，组合式函数名以“use”开头
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">export</span> <span class="kd">function</span> <span class="nx">useMouse</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 被组合式函数封装和管理的状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kr">const</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">ref</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">ref</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 组合式函数可以随时更改其状态。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kd">function</span> <span class="nx">update</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">x</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">pageX</span>
</span></span><span class="line"><span class="cl">    <span class="nx">y</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">pageY</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 一个组合式函数也可以挂靠在所属组件的生命周期上
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 来启动和卸载副作用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">onMounted</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nb">window</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">&#39;mousemove&#39;</span><span class="p">,</span> <span class="nx">update</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">  <span class="nx">onUnmounted</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nb">window</span><span class="p">.</span><span class="nx">removeEventListener</span><span class="p">(</span><span class="s1">&#39;mousemove&#39;</span><span class="p">,</span> <span class="nx">update</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 通过返回值暴露所管理的状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="p">{</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>下面是它在组件中使用的方式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-vue" data-lang="vue"><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">script</span> <span class="na">setup</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="p">{</span> <span class="nx">useMouse</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;./mouse.js&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="p">{</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">useMouse</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">template</span><span class="p">&gt;</span><span class="nx">Mouse</span> <span class="nx">position</span> <span class="nx">is</span> <span class="nx">at</span><span class="o">:</span> <span class="p">{{</span> <span class="nx">x</span> <span class="p">}},</span> <span class="p">{{</span> <span class="nx">y</span> <span class="p">}}&lt;/</span><span class="nt">template</span><span class="p">&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="约定和最佳实践">约定和最佳实践<a hidden class="anchor" aria-hidden="true" href="#约定和最佳实践">#</a></h3>
<h4 id="命名">命名<a hidden class="anchor" aria-hidden="true" href="#命名">#</a></h4>
<p>组合式函数约定用驼峰命名法命名，并以“use”作为开头。</p>
<h4 id="输入参数">输入参数<a hidden class="anchor" aria-hidden="true" href="#输入参数">#</a></h4>
<p>尽管其响应性不依赖 ref，组合式函数仍可接收 ref 参数。如果编写的组合式函数会被其他开发者使用，你最好在处理输入参数时兼容 ref 而不只是原始的值。<a href="https://cn.vuejs.org/api/reactivity-utilities.html#unref"><code>unref()</code></a> 工具函数会对此非常有帮助：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">import</span> <span class="p">{</span> <span class="nx">unref</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;vue&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">useFeature</span><span class="p">(</span><span class="nx">maybeRef</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 若 maybeRef 确实是一个 ref，它的 .value 会被返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 否则，maybeRef 会被原样返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kr">const</span> <span class="nx">value</span> <span class="o">=</span> <span class="nx">unref</span><span class="p">(</span><span class="nx">maybeRef</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果你的组合式函数在接收 ref 为参数时会产生响应式 effect，请确保使用 <code>watch()</code> 显式地监听此 ref，或者在 <code>watchEffect()</code> 中调用 <code>unref()</code> 来进行正确的追踪。</p>
<h4 id="返回值">返回值<a hidden class="anchor" aria-hidden="true" href="#返回值">#</a></h4>
<p>你可能已经注意到了，我们一直在组合式函数中使用 <code>ref()</code> 而不是 <code>reactive()</code>。我们推荐的约定是==组合式函数始终返回一个包含多个 ref 的普通的非响应式对象==，这样该对象在组件中被解构为 ref 之后仍可以保持响应性：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// x 和 y 是两个 ref
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="p">{</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">useMouse</span><span class="p">()</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>从组合式函数返回一个响应式对象会导致在对象解构过程中丢失与组合式函数内状态的响应性连接。与之相反，ref 则可以维持这一响应性连接。</p>
<p>如果你更希望以对象属性的形式来使用组合式函数中返回的状态，你可以将返回的对象用 <code>reactive()</code> 包装一次，这样其中的 ref 会被自动解包，例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">mouse</span> <span class="o">=</span> <span class="nx">reactive</span><span class="p">(</span><span class="nx">useMouse</span><span class="p">())</span>
</span></span><span class="line"><span class="cl"><span class="c1">// mouse.x 链接到了原来的 x ref
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">mouse</span><span class="p">.</span><span class="nx">x</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-vue" data-lang="vue"><span class="line"><span class="cl"><span class="nx">Mouse</span> <span class="nx">position</span> <span class="nx">is</span> <span class="nx">at</span><span class="o">:</span> <span class="p">{{</span> <span class="nx">mouse</span><span class="p">.</span><span class="nx">x</span> <span class="p">}},</span> <span class="p">{{</span> <span class="nx">mouse</span><span class="p">.</span><span class="nx">y</span> <span class="p">}}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="自定义指令">自定义指令<a hidden class="anchor" aria-hidden="true" href="#自定义指令">#</a></h2>
<p><code>directive</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-vue" data-lang="vue"><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">div</span> <span class="nt">v-color</span><span class="s">=&#34;color&#34;</span><span class="p">&gt;&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">app</span><span class="p">.</span><span class="nx">directive</span><span class="p">(</span><span class="s1">&#39;color&#39;</span><span class="p">,</span> <span class="p">(</span><span class="nx">el</span><span class="p">,</span> <span class="nx">binding</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 这会在 `mounted` 和 `updated` 时都调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">el</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">color</span> <span class="o">=</span> <span class="nx">binding</span><span class="p">.</span><span class="nx">value</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="路由">路由<a hidden class="anchor" aria-hidden="true" href="#路由">#</a></h2>
<h3 id="捕获所有路由或-404-not-found-路由">捕获所有路由或 404 Not found 路由<a hidden class="anchor" aria-hidden="true" href="#捕获所有路由或-404-not-found-路由">#</a></h3>
<p>常规参数只匹配 url 片段之间的字符，用 <code>/</code> 分隔。如果我们想匹配<strong>任意路径</strong>，我们可以使用自定义的 <em>路径参数</em> 正则表达式，在 <em>路径参数</em> 后面的括号中加入 正则表达式 :</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">routes</span> <span class="o">=</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 将匹配所有内容并将其放在 `$route.params.pathMatch` 下
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">{</span> <span class="nx">path</span><span class="o">:</span> <span class="s1">&#39;/:pathMatch(.*)*&#39;</span><span class="p">,</span> <span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;NotFound&#39;</span><span class="p">,</span> <span class="nx">component</span><span class="o">:</span> <span class="nx">NotFound</span> <span class="p">},</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 将匹配以 `/user-` 开头的所有内容，并将其放在 `$route.params.afterUser` 下
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">{</span> <span class="nx">path</span><span class="o">:</span> <span class="s1">&#39;/user-:afterUser(.*)&#39;</span><span class="p">,</span> <span class="nx">component</span><span class="o">:</span> <span class="nx">UserGeneric</span> <span class="p">},</span>
</span></span><span class="line"><span class="cl"><span class="p">]</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="路由的匹配语法">路由的匹配语法<a hidden class="anchor" aria-hidden="true" href="#路由的匹配语法">#</a></h3>
<h4 id="在参数中自定义正则">在参数中自定义正则<a hidden class="anchor" aria-hidden="true" href="#在参数中自定义正则">#</a></h4>
<p>当定义像 <code>:userId</code> 这样的参数时，我们内部使用以下的正则 <code>([^/]+)</code> (至少有一个字符不是斜杠 <code>/</code> )来从 URL 中提取参数。这很好用，除非你需要根据参数的内容来区分两个路由。想象一下，两个路由 <code>/:orderId</code> 和 <code>/:productName</code>，两者会匹配完全相同的 URL，所以我们需要一种方法来区分它们。最简单的方法就是在路径中添加一个静态部分来区分它们：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">routes</span> <span class="o">=</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 匹配 /o/3549
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">{</span> <span class="nx">path</span><span class="o">:</span> <span class="s1">&#39;/o/:orderId&#39;</span> <span class="p">},</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 匹配 /p/books
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">{</span> <span class="nx">path</span><span class="o">:</span> <span class="s1">&#39;/p/:productName&#39;</span> <span class="p">},</span>
</span></span><span class="line"><span class="cl"><span class="p">]</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>但在某些情况下，我们并不想添加静态的 <code>/o</code> <code>/p</code> 部分。由于，<code>orderId</code> 总是一个数字，而 <code>productName</code> 可以是任何东西，所以我们可以在括号中为参数指定一个自定义的正则：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">routes</span> <span class="o">=</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// /:orderId -&gt; 仅匹配数字
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">{</span> <span class="nx">path</span><span class="o">:</span> <span class="s1">&#39;/:orderId(\\d+)&#39;</span> <span class="p">},</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// /:productName -&gt; 匹配其他任何内容
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">{</span> <span class="nx">path</span><span class="o">:</span> <span class="s1">&#39;/:productName&#39;</span> <span class="p">},</span>
</span></span><span class="line"><span class="cl"><span class="p">]</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>现在，转到 <code>/25</code> 将匹配 <code>/:orderId</code>，其他情况将会匹配 <code>/:productName</code>。<code>routes</code> 数组的顺序并不重要!</p>
<blockquote>
<p>TIP</p>
<p>确保<strong>转义反斜杠( <code>\</code> )</strong>，就像我们对 <code>\d</code> (变成<code>\\d</code>)所做的那样，在 JavaScript 中实际传递字符串中的反斜杠字符。</p>
</blockquote>
<h3 id="编程式导航">编程式导航<a hidden class="anchor" aria-hidden="true" href="#编程式导航">#</a></h3>
<p>想要导航到不同的 URL，可以使用 <code>router.push</code> 方法。这个方法会向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，会回到之前的 URL。</p>
<p>当你点击 <code>&lt;router-link&gt;</code> 时，内部会调用这个方法，所以点击 <code>&lt;router-link :to=&quot;...&quot;&gt;</code> 相当于调用 <code>router.push(...)</code> ：</p>
<table>
<thead>
<tr>
<th>声明式</th>
<th>编程式</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&lt;router-link :to=&quot;...&quot;&gt;</code></td>
<td><code>router.push(...)</code></td>
</tr>
</tbody>
</table>
<p>该方法的参数可以是一个字符串路径，或者一个描述地址的对象。例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 字符串路径
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">router</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="s1">&#39;/users/eduardo&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 带有路径的对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">router</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span> <span class="nx">path</span><span class="o">:</span> <span class="s1">&#39;/users/eduardo&#39;</span> <span class="p">})</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 命名的路由，并加上参数，让路由建立 url
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">router</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span> <span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;user&#39;</span><span class="p">,</span> <span class="nx">params</span><span class="o">:</span> <span class="p">{</span> <span class="nx">username</span><span class="o">:</span> <span class="s1">&#39;eduardo&#39;</span> <span class="p">}</span> <span class="p">})</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 带查询参数，结果是 /register?plan=private
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">router</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span> <span class="nx">path</span><span class="o">:</span> <span class="s1">&#39;/register&#39;</span><span class="p">,</span> <span class="nx">query</span><span class="o">:</span> <span class="p">{</span> <span class="nx">plan</span><span class="o">:</span> <span class="s1">&#39;private&#39;</span> <span class="p">}</span> <span class="p">})</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 带 hash，结果是 /about#team
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">router</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span> <span class="nx">path</span><span class="o">:</span> <span class="s1">&#39;/about&#39;</span><span class="p">,</span> <span class="nx">hash</span><span class="o">:</span> <span class="s1">&#39;#team&#39;</span> <span class="p">})</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>注意</strong>：如果提供了 <code>path</code>，<code>params</code> 会被忽略，上述例子中的 <code>query</code> 并不属于这种情况。取而代之的是下面例子的做法，你需要提供路由的 <code>name</code> 或手写完整的带有参数的 <code>path</code> ：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">username</span> <span class="o">=</span> <span class="s1">&#39;eduardo&#39;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 我们可以手动建立 url，但我们必须自己处理编码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">router</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="sb">`/user/</span><span class="si">${</span><span class="nx">username</span><span class="si">}</span><span class="sb">`</span><span class="p">)</span> <span class="c1">// -&gt; /user/eduardo
</span></span></span><span class="line"><span class="cl"><span class="c1">// 同样
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">router</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span> <span class="nx">path</span><span class="o">:</span> <span class="sb">`/user/</span><span class="si">${</span><span class="nx">username</span><span class="si">}</span><span class="sb">`</span> <span class="p">})</span> <span class="c1">// -&gt; /user/eduardo
</span></span></span><span class="line"><span class="cl"><span class="c1">// 如果可能的话，使用 `name` 和 `params` 从自动 URL 编码中获益
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">router</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span> <span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;user&#39;</span><span class="p">,</span> <span class="nx">params</span><span class="o">:</span> <span class="p">{</span> <span class="nx">username</span> <span class="p">}</span> <span class="p">})</span> <span class="c1">// -&gt; /user/eduardo
</span></span></span><span class="line"><span class="cl"><span class="c1">// `params` 不能与 `path` 一起使用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">router</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span> <span class="nx">path</span><span class="o">:</span> <span class="s1">&#39;/user&#39;</span><span class="p">,</span> <span class="nx">params</span><span class="o">:</span> <span class="p">{</span> <span class="nx">username</span> <span class="p">}</span> <span class="p">})</span> <span class="c1">// -&gt; /user
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>当指定 <code>params</code> 时，可提供 <code>string</code> 或 <code>number</code> 参数（或者对于<a href="https://router.vuejs.org/zh/guide/essentials/route-matching-syntax.html#repeatable-params">可重复的参数</a>可提供一个数组）。<strong>任何其他类型（如 <code>undefined</code>、<code>false</code> 等）都将被自动字符串化</strong>。对于<a href="https://router.vuejs.org/zh/guide/essentials/route-matching-syntax.html#repeatable-params">可选参数</a>，你可以提供一个空字符串（<code>&quot;&quot;</code>）来跳过它。</p>
<p>由于属性 <code>to</code> 与 <code>router.push</code> 接受的对象种类相同，所以两者的规则完全相同。</p>
<p><code>router.push</code> 和所有其他导航方法都会返回一个 <em>Promise</em>，让我们可以等到导航完成后才知道是成功还是失败。我们将在 <a href="https://router.vuejs.org/zh/guide/advanced/navigation-failures.html">Navigation Handling</a> 中详细介绍。</p>
<h3 id="命名视图">命名视图<a hidden class="anchor" aria-hidden="true" href="#命名视图">#</a></h3>
<p>有时候想同时 (同级) 展示多个视图，而不是嵌套展示，例如创建一个布局，有 <code>sidebar</code> (侧导航) 和 <code>main</code> (主内容) 两个视图，这个时候命名视图就派上用场了。你可以在界面中拥有多个单独命名的视图，而不是只有一个单独的出口。如果 <code>router-view</code> 没有设置名字，那么默认为 <code>default</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-vue" data-lang="vue"><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">router-view</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;view left-sidebar&#34;</span> <span class="na">name</span><span class="o">=</span><span class="s">&#34;LeftSidebar&#34;</span><span class="p">&gt;</span><span class="o">&lt;</span><span class="err">/router-view&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">router-view</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;view main-content&#34;</span><span class="p">&gt;</span><span class="o">&lt;</span><span class="err">/router-view&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">router-view</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;view right-sidebar&#34;</span> <span class="na">name</span><span class="o">=</span><span class="s">&#34;RightSidebar&#34;</span><span class="p">&gt;</span><span class="o">&lt;</span><span class="err">/router-view&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>一个视图使用一个组件渲染，因此对于同个路由，多个视图就需要多个组件。确保正确使用 <code>components</code> 配置 (带上 <strong>s</strong>)：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">router</span> <span class="o">=</span> <span class="nx">createRouter</span><span class="p">({</span>
</span></span><span class="line"><span class="cl">  <span class="nx">history</span><span class="o">:</span> <span class="nx">createWebHashHistory</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">  <span class="nx">routes</span><span class="o">:</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">path</span><span class="o">:</span> <span class="s1">&#39;/&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nx">components</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">default</span><span class="o">:</span> <span class="nx">Home</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// LeftSidebar: LeftSidebar 的缩写
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">LeftSidebar</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 它们与 `&lt;router-view&gt;` 上的 `name` 属性匹配
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">RightSidebar</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="p">},</span>
</span></span><span class="line"><span class="cl">    <span class="p">},</span>
</span></span><span class="line"><span class="cl">  <span class="p">],</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="嵌套命名视图">嵌套命名视图<a hidden class="anchor" aria-hidden="true" href="#嵌套命名视图">#</a></h4>
<p>我们也有可能使用命名视图创建嵌套视图的复杂布局。这时你也需要命名用到的嵌套 <code>router-view</code> 组件。我们以一个设置面板为例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">/settings/emails                                       /settings/profile
</span></span><span class="line"><span class="cl">+-----------------------------------+                  +------------------------------+
</span></span><span class="line"><span class="cl">| UserSettings                      |                  | UserSettings                 |
</span></span><span class="line"><span class="cl">| +-----+-------------------------+ |                  | +-----+--------------------+ |
</span></span><span class="line"><span class="cl">| | Nav | UserEmailsSubscriptions | |  +------------&gt;  | | Nav | UserProfile        | |
</span></span><span class="line"><span class="cl">| |     +-------------------------+ |                  | |     +--------------------+ |
</span></span><span class="line"><span class="cl">| |     |                         | |                  | |     | UserProfilePreview | |
</span></span><span class="line"><span class="cl">| +-----+-------------------------+ |                  | +-----+--------------------+ |
</span></span><span class="line"><span class="cl">+-----------------------------------+                  +------------------------------+
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><code>Nav</code> 只是一个常规组件。</li>
<li><code>UserSettings</code> 是一个视图组件。</li>
<li><code>UserEmailsSubscriptions</code>、<code>UserProfile</code>、<code>UserProfilePreview</code> 是嵌套的视图组件。</li>
</ul>
<p><strong>注意</strong>：<em>我们先忘记 HTML/CSS 具体的布局的样子，只专注在用到的组件上。</em></p>
<p><code>UserSettings</code> 组件的 <code>&lt;template&gt;</code> 部分应该是类似下面的这段代码:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-vue" data-lang="vue"><span class="line"><span class="cl"><span class="c">&lt;!--</span> <span class="nx">UserSettings</span><span class="p">.</span><span class="nx">vue</span> <span class="o">--&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">&lt;</span><span class="nt">h1</span><span class="p">&gt;</span><span class="nx">User</span> <span class="nx">Settings</span><span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">&lt;</span><span class="nt">NavBar</span> <span class="p">/&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">&lt;</span><span class="nt">router-view</span> <span class="p">/&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">&lt;</span><span class="nt">router-view</span> <span class="na">name</span><span class="o">=</span><span class="s">&#34;helper&#34;</span> <span class="p">/&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>那么你就可以通过这个路由配置来实现上面的布局：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">path</span><span class="o">:</span> <span class="s1">&#39;/settings&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 你也可以在顶级路由就配置命名视图
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">component</span><span class="o">:</span> <span class="nx">UserSettings</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">children</span><span class="o">:</span> <span class="p">[{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">path</span><span class="o">:</span> <span class="s1">&#39;emails&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">component</span><span class="o">:</span> <span class="nx">UserEmailsSubscriptions</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">path</span><span class="o">:</span> <span class="s1">&#39;profile&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">components</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">default</span><span class="o">:</span> <span class="nx">UserProfile</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nx">helper</span><span class="o">:</span> <span class="nx">UserProfilePreview</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}]</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="导航守卫">导航守卫<a hidden class="anchor" aria-hidden="true" href="#导航守卫">#</a></h3>
<h3 id="路由懒加载">路由懒加载<a hidden class="anchor" aria-hidden="true" href="#路由懒加载">#</a></h3>
<p>当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就会更加高效。</p>
<p>Vue Router 支持开箱即用的<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#Dynamic_Imports">动态导入</a>，这意味着你可以用动态导入代替静态导入：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="c1">// 将
</span></span></span><span class="line"><span class="cl"><span class="c1">// import UserDetails from &#39;./views/UserDetails&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1">// 替换成
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">UserDetails</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="kr">import</span><span class="p">(</span><span class="s1">&#39;./views/UserDetails&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">router</span> <span class="o">=</span> <span class="nx">createRouter</span><span class="p">({</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">routes</span><span class="o">:</span> <span class="p">[{</span> <span class="nx">path</span><span class="o">:</span> <span class="s1">&#39;/users/:id&#39;</span><span class="p">,</span> <span class="nx">component</span><span class="o">:</span> <span class="nx">UserDetails</span> <span class="p">}],</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>component</code> (和 <code>components</code>) 配置接收一个返回 Promise 组件的函数，Vue Router <strong>只会在第一次进入页面时才会获取这个函数</strong>，然后使用缓存数据。这意味着你也可以使用更复杂的函数，只要它们返回一个 Promise ：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">UserDetails</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">({</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* 组件定义 */</span>
</span></span><span class="line"><span class="cl">  <span class="p">})</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>一般来说，对所有的路由<strong>都使用动态导入</strong>是个好主意。</p>
<h2 id="状态管理">状态管理<a hidden class="anchor" aria-hidden="true" href="#状态管理">#</a></h2>
<h3 id="pinia">Pinia<a hidden class="anchor" aria-hidden="true" href="#pinia">#</a></h3>
<blockquote>
<p>参考链接：</p>
<p><a href="https://pinia.web3doc.top/getting-started.html">https://pinia.web3doc.top/getting-started.html</a></p>
<p><a href="https://juejin.cn/post/6986847203885056036">Pinia 快速入门</a></p>
<p><a href="https://juejin.cn/post/7082905688313167903">pinia 的使用（二）—— state</a></p>
</blockquote>
<h4 id="安装">安装<a hidden class="anchor" aria-hidden="true" href="#安装">#</a></h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">npm install pinia
</span></span></code></pre></td></tr></table>
</div>
</div><p>创建一个 pinia（根存储）并将其传递给应用程序：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="line"><span class="cl"><span class="kr">import</span> <span class="p">{</span> <span class="nx">createApp</span> <span class="p">}</span> <span class="kr">from</span> <span class="s1">&#39;vue&#39;</span>
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="nx">App</span> <span class="kr">from</span> <span class="s1">&#39;./App.vue&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="p">{</span> <span class="nx">createPinia</span> <span class="p">}</span> <span class="kr">from</span> <span class="s1">&#39;pinia&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">app</span> <span class="o">=</span> <span class="nx">createApp</span><span class="p">(</span><span class="nx">App</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">createPinia</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">app</span><span class="p">.</span><span class="nx">mount</span><span class="p">(</span><span class="s1">&#39;#app&#39;</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="store">Store<a hidden class="anchor" aria-hidden="true" href="#store">#</a></h4>
<p>Store 是使用 <code>defineStore()</code> 定义的，并且它需要一个<strong>唯一</strong>名称，作为第一个参数传递：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="line"><span class="cl"><span class="kr">import</span> <span class="p">{</span> <span class="nx">defineStore</span> <span class="p">}</span> <span class="kr">from</span> <span class="s1">&#39;pinia&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// useStore 可以是 useUser、useCart 之类的任何东西
</span></span></span><span class="line"><span class="cl"><span class="c1">// 第一个参数是应用程序中 store 的唯一 id
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">export</span> <span class="kr">const</span> <span class="nx">useStore</span> <span class="o">=</span> <span class="nx">defineStore</span><span class="p">(</span><span class="s1">&#39;main&#39;</span><span class="p">,</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// other options...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">})</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个 <em>name</em>，也称为 <em>id</em>，是必要的，Pinia 使用它来将 store 连接到 devtools。 将返回的函数命名为 <em>use&hellip;</em> 是跨可组合项的约定，以使其符合你的使用习惯。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-vue" data-lang="vue"><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">script</span> <span class="na">setup</span> <span class="na">lang</span><span class="o">=</span><span class="s">&#34;ts&#34;</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="p">{</span> <span class="nx">useStore</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;@/store/demo&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">store</span> <span class="o">=</span> <span class="nx">useStore</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;store.counter:&#34;</span><span class="p">,</span> <span class="nx">store</span><span class="p">.</span><span class="nx">counter</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>请注意，<code>store</code> 是一个用<code>reactive</code> 包裹的对象，这意味着不需要在getter 之后写<code>.value</code>，但是，就像<code>setup</code> 中的<code>props</code> 一样，<strong>我们不能对其进行解构</strong>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="line"><span class="cl"><span class="kr">export</span> <span class="k">default</span> <span class="nx">defineComponent</span><span class="p">({</span>
</span></span><span class="line"><span class="cl">  <span class="nx">setup() {</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">store</span> <span class="o">=</span> <span class="nx">useStore</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ❌ 这不起作用，因为它会破坏响应式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 这和从 props 解构是一样的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kr">const</span> <span class="p">{</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">doubleCount</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">store</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">name</span> <span class="c1">// &#34;eduardo&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">doubleCount</span> <span class="c1">// 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 一直会是 &#34;eduardo&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nx">name</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 一直会是 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nx">doubleCount</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 这将是响应式的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nx">doubleValue</span>: <span class="kt">computed</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">store</span><span class="p">.</span><span class="nx">doubleCount</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>为了从 Store 中提取属性同时保持其响应式，您需要使用<code>storeToRefs()</code>。 它将为任何响应式属性创建 refs。 当您仅使用 store 中的状态但不调用任何操作时，这很有用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="line"><span class="cl"><span class="kr">import</span> <span class="p">{</span> <span class="nx">storeToRefs</span> <span class="p">}</span> <span class="kr">from</span> <span class="s1">&#39;pinia&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="k">default</span> <span class="nx">defineComponent</span><span class="p">({</span>
</span></span><span class="line"><span class="cl">  <span class="nx">setup() {</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">store</span> <span class="o">=</span> <span class="nx">useStore</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// `name` 和 `doubleCount` 是响应式引用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 这也会为插件添加的属性创建引用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 但跳过任何 action 或 非响应式（不是 ref/reactive）的属性
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kr">const</span> <span class="p">{</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">doubleCount</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">storeToRefs</span><span class="p">(</span><span class="nx">store</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">name</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nx">doubleCount</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="state">State<a hidden class="anchor" aria-hidden="true" href="#state">#</a></h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="line"><span class="cl"><span class="kr">import</span> <span class="p">{</span> <span class="nx">defineStore</span> <span class="p">}</span> <span class="kr">from</span> <span class="s1">&#39;pinia&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">useStore</span> <span class="o">=</span> <span class="nx">defineStore</span><span class="p">(</span><span class="s1">&#39;storeId&#39;</span><span class="p">,</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 推荐使用 完整类型推断的箭头函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">state</span><span class="o">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 所有这些属性都将自动推断其类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nx">counter</span>: <span class="kt">0</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;Eduardo&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nx">isAdmin</span>: <span class="kt">true</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="getters">Getters<a hidden class="anchor" aria-hidden="true" href="#getters">#</a></h4>
<p>Getter 完全等同于 Store 状态的 <a href="https://v3.vuejs.org/guide/reactivity-computed-watchers.html#computed-values">计算值</a>。 它们可以用 <code>defineStore()</code> 中的 <code>getters</code> 属性定义。 他们接收“状态”作为第一个参数<strong>以鼓励</strong>箭头函数的使用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="line"><span class="cl"><span class="kr">export</span> <span class="kr">const</span> <span class="nx">useStore</span> <span class="o">=</span> <span class="nx">defineStore</span><span class="p">(</span><span class="s1">&#39;main&#39;</span><span class="p">,</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">state</span><span class="o">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">({</span>
</span></span><span class="line"><span class="cl">    <span class="nx">counter</span>: <span class="kt">0</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="p">}),</span>
</span></span><span class="line"><span class="cl">  <span class="nx">getters</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">doubleCount</span><span class="o">:</span> <span class="p">(</span><span class="nx">state</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">state</span><span class="p">.</span><span class="nx">counter</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>大多数时候，getter 只会依赖状态，但是，他们可能需要使用其他 getter。 正因为如此，我们可以在定义常规函数时通过 <code>this</code> 访问到 <em>整个 store 的实例</em>， <strong>但是需要定义返回类型（在 TypeScript 中）</strong>。 这是由于 TypeScript 中的一个已知限制，并且<strong>不会影响使用箭头函数定义的 getter，也不会影响不使用 <code>this</code> 的 getter</strong>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="line"><span class="cl"><span class="kr">export</span> <span class="kr">const</span> <span class="nx">useStore</span> <span class="o">=</span> <span class="nx">defineStore</span><span class="p">(</span><span class="s1">&#39;main&#39;</span><span class="p">,</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">state</span><span class="o">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">({</span>
</span></span><span class="line"><span class="cl">    <span class="nx">counter</span>: <span class="kt">0</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="p">}),</span>
</span></span><span class="line"><span class="cl">  <span class="nx">getters</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 自动将返回类型推断为数字
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">doubleCount</span><span class="p">(</span><span class="nx">state</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nx">state</span><span class="p">.</span><span class="nx">counter</span> <span class="o">*</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl">    <span class="p">},</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 返回类型必须明确设置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">doublePlusOne</span><span class="p">()</span><span class="o">:</span> <span class="kt">number</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">counter</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="p">},</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>然后你可以直接在 store 实例上访问 getter：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-vue" data-lang="vue"><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">template</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span><span class="nx">Double</span> <span class="nx">count</span> <span class="nx">is</span> <span class="p">{{</span> <span class="nx">store</span><span class="p">.</span><span class="nx">doubleCount</span> <span class="p">}}&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;/</span><span class="nt">template</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">script</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="k">default</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">setup</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">store</span> <span class="o">=</span> <span class="nx">useStore</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">{</span> <span class="nx">store</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="actions">Actions<a hidden class="anchor" aria-hidden="true" href="#actions">#</a></h4>
<p>Actions 相当于组件中的 <a href="https://v3.vuejs.org/guide/data-methods.html#methods">methods</a>。 它们可以使用 <code>defineStore()</code> 中的 <code>actions</code> 属性定义，并且<strong>它们非常适合定义业务逻辑</strong>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="line"><span class="cl"><span class="kr">export</span> <span class="kr">const</span> <span class="nx">useStore</span> <span class="o">=</span> <span class="nx">defineStore</span><span class="p">(</span><span class="s1">&#39;main&#39;</span><span class="p">,</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">state</span><span class="o">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">({</span>
</span></span><span class="line"><span class="cl">    <span class="nx">counter</span>: <span class="kt">0</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="p">}),</span>
</span></span><span class="line"><span class="cl">  <span class="nx">actions</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">increment() {</span>
</span></span><span class="line"><span class="cl">      <span class="k">this</span><span class="p">.</span><span class="nx">counter</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">    <span class="p">},</span>
</span></span><span class="line"><span class="cl">    <span class="nx">randomizeCounter() {</span>
</span></span><span class="line"><span class="cl">      <span class="k">this</span><span class="p">.</span><span class="nx">counter</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">round</span><span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">    <span class="p">},</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>与 <a href="https://pinia.web3doc.top/core-concepts/getters.html">getters</a> 一样，操作可以通过 <code>this</code> 访问 <em>whole store instance</em> 并提供<strong>完整类型（和自动完成✨）支持</strong>。 <strong>与它们不同，<code>actions</code> 可以是异步的</strong>，您可以在其中<code>await</code> 任何 API 调用甚至其他操作！ 这是使用 <a href="https://github.com/posva/mande">Mande</a> 的示例。 请注意，只要您获得“Promise”，您使用的库并不重要，您甚至可以使用浏览器的“fetch”函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="line"><span class="cl"><span class="kr">import</span> <span class="p">{</span> <span class="nx">mande</span> <span class="p">}</span> <span class="kr">from</span> <span class="s1">&#39;mande&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">api</span> <span class="o">=</span> <span class="nx">mande</span><span class="p">(</span><span class="s1">&#39;/api/users&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="kr">const</span> <span class="nx">useUsers</span> <span class="o">=</span> <span class="nx">defineStore</span><span class="p">(</span><span class="s1">&#39;users&#39;</span><span class="p">,</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">state</span><span class="o">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">({</span>
</span></span><span class="line"><span class="cl">    <span class="nx">userData</span>: <span class="kt">null</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}),</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">actions</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">async</span> <span class="nx">registerUser</span><span class="p">(</span><span class="nx">login</span><span class="p">,</span> <span class="nx">password</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="p">.</span><span class="nx">userData</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">api</span><span class="p">.</span><span class="nx">post</span><span class="p">({</span> <span class="nx">login</span><span class="p">,</span> <span class="nx">password</span> <span class="p">})</span>
</span></span><span class="line"><span class="cl">        <span class="nx">showTooltip</span><span class="p">(</span><span class="sb">`Welcome back </span><span class="si">${</span><span class="k">this</span><span class="p">.</span><span class="nx">userData</span><span class="p">.</span><span class="nx">name</span><span class="si">}</span><span class="sb">!`</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">showTooltip</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 让表单组件显示错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="nx">error</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">},</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>你也可以完全自由地设置你想要的任何参数并返回任何东西。 调用 Action 时，一切都会自动推断！</p>
<p>Actions 像 methods 一样被调用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="line"><span class="cl"><span class="kr">export</span> <span class="k">default</span> <span class="nx">defineComponent</span><span class="p">({</span>
</span></span><span class="line"><span class="cl">  <span class="nx">setup() {</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">main</span> <span class="o">=</span> <span class="nx">useMainStore</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Actions 像 methods 一样被调用：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">main</span><span class="p">.</span><span class="nx">randomizeCounter</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="vuex">Vuex<a hidden class="anchor" aria-hidden="true" href="#vuex">#</a></h3>
<h2 id="typescript-与组合式-api">TypeScript 与组合式 API<a hidden class="anchor" aria-hidden="true" href="#typescript-与组合式-api">#</a></h2>
<blockquote>
<p>参考链接：</p>
<p><a href="https://cn.vuejs.org/guide/typescript/composition-api.html">https://cn.vuejs.org/guide/typescript/composition-api.html</a></p>
</blockquote>
<h3 id="为组件的-props-标注类型">为组件的 props 标注类型<a hidden class="anchor" aria-hidden="true" href="#为组件的-props-标注类型">#</a></h3>
<p>当使用 <code>&lt;script setup&gt;</code> 时，<code>defineProps()</code> 宏函数支持从它的参数中推导类型：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-vue" data-lang="vue"><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">script</span> <span class="na">setup</span> <span class="na">lang</span><span class="o">=</span><span class="s">&#34;ts&#34;</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">props</span> <span class="o">=</span> <span class="nx">defineProps</span><span class="p">({</span>
</span></span><span class="line"><span class="cl">  <span class="nx">foo</span><span class="o">:</span> <span class="p">{</span> <span class="nx">type</span><span class="o">:</span> <span class="nb">String</span><span class="p">,</span> <span class="nx">required</span><span class="o">:</span> <span class="kc">true</span> <span class="p">},</span>
</span></span><span class="line"><span class="cl">  <span class="nx">bar</span><span class="o">:</span> <span class="nb">Number</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">props</span><span class="p">.</span><span class="nx">foo</span> <span class="c1">// string
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">props</span><span class="p">.</span><span class="nx">bar</span> <span class="c1">// number | undefined
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这被称之为“运行时声明”，因为传递给 <code>defineProps()</code> 的参数会作为运行时的 <code>props</code> 选项使用。</p>
<p>然而，通过泛型参数来定义 props 的类型通常更直接：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-vue" data-lang="vue"><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">script</span> <span class="na">setup</span> <span class="na">lang</span><span class="o">=</span><span class="s">&#34;ts&#34;</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">props</span> <span class="o">=</span> <span class="nx">defineProps</span><span class="o">&lt;</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">foo</span><span class="o">:</span> <span class="nx">string</span>
</span></span><span class="line"><span class="cl">  <span class="nx">bar</span><span class="o">?:</span> <span class="nx">number</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span><span class="o">&gt;</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这被称之为“基于类型的声明”。编译器会尽可能地尝试根据类型参数推导出等价的运行时选项。在这种场景下，我们第二个例子中编译出的运行时选项和第一个是完全一致的。</p>
<p>基于类型的声明或者运行时声明可以择一使用，但是不能同时使用。</p>
<p>我们也可以将 props 的类型移入一个单独的接口中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-vue" data-lang="vue"><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">script</span> <span class="na">setup</span> <span class="na">lang</span><span class="o">=</span><span class="s">&#34;ts&#34;</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">Props</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">foo</span><span class="o">:</span> <span class="nx">string</span>
</span></span><span class="line"><span class="cl">  <span class="nx">bar</span><span class="o">?:</span> <span class="nx">number</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">props</span> <span class="o">=</span> <span class="nx">defineProps</span><span class="p">&lt;</span><span class="nt">Props</span><span class="p">&gt;()</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="typescript-与选项式-api">TypeScript 与选项式 API<a hidden class="anchor" aria-hidden="true" href="#typescript-与选项式-api">#</a></h2>
<blockquote>
<p>参考链接：</p>
<p><a href="https://cn.vuejs.org/guide/typescript/options-api.html">https://cn.vuejs.org/guide/typescript/options-api.html</a></p>
</blockquote>
<h3 id="为组件的-props-标注类型-1">为组件的 props 标注类型<a hidden class="anchor" aria-hidden="true" href="#为组件的-props-标注类型-1">#</a></h3>
<p>选项式 API 中对 props 的类型推导需要用 <code>defineComponent()</code> 来包装组件。有了它，Vue 才可以通过 <code>props</code> 以及一些额外的选项，比如 <code>required: true</code> 和 <code>default</code> 来推导出 props 的类型：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="line"><span class="cl"><span class="kr">import</span> <span class="p">{</span> <span class="nx">defineComponent</span> <span class="p">}</span> <span class="kr">from</span> <span class="s1">&#39;vue&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="k">default</span> <span class="nx">defineComponent</span><span class="p">({</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 启用了类型推导
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">props</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">name</span>: <span class="kt">String</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">id</span><span class="o">:</span> <span class="p">[</span><span class="nb">Number</span><span class="p">,</span> <span class="nb">String</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">    <span class="nx">msg</span><span class="o">:</span> <span class="p">{</span> <span class="kr">type</span><span class="o">:</span> <span class="nb">String</span><span class="p">,</span> <span class="nx">required</span>: <span class="kt">true</span> <span class="p">},</span>
</span></span><span class="line"><span class="cl">    <span class="nx">metadata</span>: <span class="kt">null</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl">  <span class="nx">mounted() {</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="c1">// 类型：string | undefined
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">this</span><span class="p">.</span><span class="nx">id</span> <span class="c1">// 类型：number | string | undefined
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">this</span><span class="p">.</span><span class="nx">msg</span> <span class="c1">// 类型：string
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">this</span><span class="p">.</span><span class="nx">metadata</span> <span class="c1">// 类型：any
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>然而，这种运行时 <code>props</code> 选项仅支持使用构造函数来作为一个 prop 的类型——没有办法指定多层级对象或函数签名之类的复杂类型。</p>
<p>我们可以使用 <code>PropType</code> 这个工具类型来标记更复杂的 props 类型：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="line"><span class="cl"><span class="kr">import</span> <span class="p">{</span> <span class="nx">defineComponent</span> <span class="p">}</span> <span class="kr">from</span> <span class="s1">&#39;vue&#39;</span>
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="kr">type</span> <span class="p">{</span> <span class="nx">PropType</span> <span class="p">}</span> <span class="kr">from</span> <span class="s1">&#39;vue&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">Book</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">title</span>: <span class="kt">string</span>
</span></span><span class="line"><span class="cl">  <span class="nx">author</span>: <span class="kt">string</span>
</span></span><span class="line"><span class="cl">  <span class="nx">year</span>: <span class="kt">number</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="k">default</span> <span class="nx">defineComponent</span><span class="p">({</span>
</span></span><span class="line"><span class="cl">  <span class="nx">props</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">book</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 提供相对 `Object` 更确定的类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="kr">type</span><span class="o">:</span> <span class="nb">Object</span> <span class="kr">as</span> <span class="nx">PropType</span><span class="p">&lt;</span><span class="nt">Book</span><span class="p">&gt;,</span>
</span></span><span class="line"><span class="cl">      <span class="nx">required</span>: <span class="kt">true</span>
</span></span><span class="line"><span class="cl">    <span class="p">},</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 也可以标记函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">callback</span>: <span class="kt">Function</span> <span class="kr">as</span> <span class="nx">PropType</span><span class="o">&lt;</span><span class="p">(</span><span class="nx">id</span>: <span class="kt">number</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="k">void</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl">  <span class="nx">mounted() {</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">book</span><span class="p">.</span><span class="nx">title</span> <span class="c1">// string
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">this</span><span class="p">.</span><span class="nx">book</span><span class="p">.</span><span class="nx">year</span> <span class="c1">// number
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// TS Error: argument of type &#39;string&#39; is not
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// assignable to parameter of type &#39;number&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">this</span><span class="p">.</span><span class="nx">callback</span><span class="o">?</span><span class="p">.(</span><span class="s1">&#39;123&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span></code></pre></td></tr></table>
</div>
</div>

  </div>

  <footer class="post-footer">
    
<nav class="paginav">
  <a class="prev" href="https://chance7bin.github.io/posts/note/%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%E5%8F%8Aspringboot%E9%9B%86%E6%88%90/">
    <span class="title">« 上一页</span>
    <br>
    <span>雪花算法详解及springboot集成</span>
  </a>
  <a class="next" href="https://chance7bin.github.io/posts/note/vue%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/">
    <span class="title">下一页 »</span>
    <br>
    <span>Vue项目搭建</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://chance7bin.github.io/">Binb&#39;s Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
