<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>程序的机器级表示 | Binb&#39;s Blog</title>
<meta name="keywords" content="csapp">
<meta name="description" content="程序编码 代码示例 mstore.c 1 2 3 4 5 6 long mult2(long, long); void multstore(long x, long y, long *dest){ long t = mult2(x,y); *dest = t; } main.c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include &lt;stdio.h&gt; void multstore(long, long, long *); int main(){ long d; multstore(2,3,&amp;d); printf(&#34;2 * 3 --&gt; %ld\n&#34;,d); return 0; } long">
<meta name="author" content="chance7bin">
<link rel="canonical" href="https://chance7bin.github.io/posts/basic/csapp/%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.be81eec981a615a87a88f121642d7eebde74d033438693944db2fd6b827284ff.css" integrity="" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.acb54fd32bbc1982428b8850317e45d076b95012730a5936667e6bc21777692a.js" integrity=""
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://chance7bin.github.io/img/%E7%BE%8E%E9%98%9F.jpg">
<link rel="icon" type="image/png" sizes="16x16" href="https://chance7bin.github.io/img/%E7%BE%8E%E9%98%9F.jpg">
<link rel="icon" type="image/png" sizes="32x32" href="https://chance7bin.github.io/img/%E7%BE%8E%E9%98%9F.jpg">
<link rel="apple-touch-icon" href="https://chance7bin.github.io/img/%E7%BE%8E%E9%98%9F.jpg">
<link rel="mask-icon" href="https://chance7bin.github.io/img/%E7%BE%8E%E9%98%9F.jpg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="程序的机器级表示" />
<meta property="og:description" content="程序编码 代码示例 mstore.c 1 2 3 4 5 6 long mult2(long, long); void multstore(long x, long y, long *dest){ long t = mult2(x,y); *dest = t; } main.c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include &lt;stdio.h&gt; void multstore(long, long, long *); int main(){ long d; multstore(2,3,&amp;d); printf(&#34;2 * 3 --&gt; %ld\n&#34;,d); return 0; } long" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://chance7bin.github.io/posts/basic/csapp/%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-13T00:00:00+00:00" />
<meta property="article:modified_time" content="2022-04-13T00:00:00+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="程序的机器级表示"/>
<meta name="twitter:description" content="程序编码 代码示例 mstore.c 1 2 3 4 5 6 long mult2(long, long); void multstore(long x, long y, long *dest){ long t = mult2(x,y); *dest = t; } main.c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include &lt;stdio.h&gt; void multstore(long, long, long *); int main(){ long d; multstore(2,3,&amp;d); printf(&#34;2 * 3 --&gt; %ld\n&#34;,d); return 0; } long"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "📚 文章",
      "item": "https://chance7bin.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "📕 计算机基础",
      "item": "https://chance7bin.github.io/posts/basic/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "CSAPP",
      "item": "https://chance7bin.github.io/posts/basic/csapp/"
    }, 
    {
      "@type": "ListItem",
      "position":  4 ,
      "name": "程序的机器级表示",
      "item": "https://chance7bin.github.io/posts/basic/csapp/%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "程序的机器级表示",
  "name": "程序的机器级表示",
  "description": "程序编码 代码示例 mstore.c 1 2 3 4 5 6 long mult2(long, long); void multstore(long x, long y, long *dest){ long t = mult2(x,y); *dest = t; } main.c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;stdio.h\u0026gt; void multstore(long, long, long *); int main(){ long d; multstore(2,3,\u0026amp;d); printf(\u0026#34;2 * 3 --\u0026gt; %ld\\n\u0026#34;,d); return 0; } long",
  "keywords": [
    "csapp"
  ],
  "articleBody": "程序编码 代码示例 mstore.c\n1 2 3 4 5 6 long mult2(long, long); void multstore(long x, long y, long *dest){ long t = mult2(x,y); *dest = t; } main.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include void multstore(long, long, long *); int main(){ long d; multstore(2,3,\u0026d); printf(\"2 * 3 --\u003e %ld\\n\",d); return 0; } long mult2(long a, long b){ long s = a * b; return s; } 使用gcc编译 1 gcc -Og -o p mstore.c main.c 首先，C预处理器扩展源代码，插入所有用#include 命令指定的文件，并扩展所有用#define 声明指定的宏。其次，编译器产生两个源文件的汇编代码，名字分别为 mstore.s 和 main.s。接下来，汇编器会将汇编代码转化成二进制目标代码文件 p1.o 和 p2.o。目标代码是机器代码的一种形式，它包含所有指令的二进制表示，但是还没有填人全局值的地址。最后，链接器将两个目标代码文件与实现库两数(例如 printf）的代码合并，并产生最终的可执行代码文件(由命令行指示符 -o p 指定的）。可执行代码是我们要考虑的机器代码的第二种形式，也就是处理器执行的代码格式。会在第 7章更详细地介绍这些不同形式的机器代码之间的关系以及链接的过程。\n1 gcc -Og -S mstore.c 产生一个汇编文件mstore.s，但是不做其他进一步的工作。\nmstore.s完整内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 .file\t\"mstore.c\" .text .globl\tmultstore .type\tmultstore, @function multstore: .LFB0: .cfi_startproc endbr64 pushq\t%rbx .cfi_def_cfa_offset 16 .cfi_offset 3, -16 movq\t%rdx, %rbx call\tmult2@PLT movq\t%rax, (%rbx) popq\t%rbx .cfi_def_cfa_offset 8 ret .cfi_endproc .LFE0: .size\tmultstore, .-multstore .ident\t\"GCC: (Ubuntu 9.3.0-17ubuntu1~20.04) 9.3.0\" .section\t.note.GNU-stack,\"\",@progbits .section\t.note.gnu.property,\"a\" .align 8 .long\t1f - 0f .long\t4f - 1f .long\t5 0: .string\t\"GNU\" 1: .align 8 .long\t0xc0000002 .long\t3f - 2f 2: .long\t0x3 3: .align 8 4: 上面代码中每个缩进去的行都对应于一条机器指令。比如，pushq 指令表示应该将寄存器 %rbx 的内容压人程序栈中。\n如果使用 “-c” 命令行选项，GCC会编译并汇编该代码：\n1 gcc -Og -c mstore.c 这就会产生目标代码文件 mstore.o，它是二进制格式的。\n从中得到一个重要的信息，即机器执行的程序只是一个字节序列，它是对一系列指令的编码。机器对产生这些指令的源代码几乎一无所知。\n查看机器代码文件的内容，反汇编器（disassembler）很有用\n1 objdump -d mstore.o 结果如下：\n1 2 3 4 5 6 7 8 0000000000000000 : 0:\tf3 0f 1e fa endbr64 4:\t53 push %rbx 5:\t48 89 d3 mov %rdx,%rbx 8:\te8 00 00 00 00 callq d d:\t48 89 03 mov %rax,(%rbx) 10:\t5b pop %rbx 11:\tc3 retq 生成实际可执行的代码需要对一组目标代码文件运行链接器，而这一组目标代码文件中必须含有一个main函数\n用如下方法生成可执行文件prog\n1 gcc -Og -o p mstore.c main.c ATT与Intel 数据格式 大多数 GCC 生成的汇编代码指令都有一个宇符的后缀，表明操作数的大小，例如，数据传送指令有四个变种：movb(传送字节）、movw(传送宇)、movI(传送双字)和movq(传送四字)。后级‘l’用来表示双字，因为32位数被看成是“长字(1ong word)”。注意，汇编代码也使用后级‘l’来表示 4 字节整数和8字节双精度浮点数。这不会产生歧义，因为浮点数使用的是一组完全不同的指令和寄存器。\n访问信息 寄存器的名字都是以%r开头，不过后面还跟着一些不同的命名规则的名字。\n​\n操作数格式 数据传送指令 源操作数指定的值是一个立即数，存储在寄存器中或者内存中。目的操作数指定一个位置，要么是一个奇存器，要么是一个内存地址。x86-64 加了一条限制，传送指令的两个操作数不能都指向内存位置。将一个值从一个内存位置复制到另一个内存位置需要两条指令——第一条指令将源值加载到寄存器中，第二条将该奇存器值写入目的位置。这些指令的寄存器操作数可以是 16个奇存器有标号部分中的任意一个，寄存器部分的大小必须与指令最后一个字符（b、w、l、q）指定的大小匹配。大多数情况中，MOV 指令只会更新目的操作数指定的那些寄存器字节或内存位置。唯一的例外是movI 指令以寄存器作为目的时，它会把该寄存器的高位4字节设置为0。造成这个例外的原因是 x86-64 采用的惯例，即任何为奇存器生成 32 位值的指令都会把该寄存器的高位部分置成 0。\n补充：当寄存器的名称放在括号中时，使用这个寄存器，不管里面存的是什么，将寄存器中的值当作地址去访问\n图 3-4 中记录的最后一条指令是处理64位立即数数据的。常规的 mova 指令只能以表示为 32 位补码数字的立即数作为源操作数，然后把这个值符号扩展得到 64位的值，放到目的位置。movabsq 指令能够以任意 64 位立即数值作为源操作数，并且只能以寄存器作为目的。\n图3-5和图3-6记录的是两类数据移动指令，在将较小的源值复制到较大的目的时使用。所有这些指令都把数据从源（在奇存器或内存中）复制到目的寄存器。MOVZ 类中的指令把目的中剩余的字节填充为 0，而MOVS 类中的指令通过符号扩展来填充，把源操作的最高位进行复制。可以观察到，每条指令名字的最后两个字符都是大小指示符：第一个字符指定源的大小，而第二个指明目的的大小。\nmovzbl 指令不仅会把 %eax 的高3个字节清零，还会把整个寄存器 %rax 的高4个字节都清零。\n补充：x86-64中的内存引用总是用四字长寄存器给出，例如%rax，哪怕操作数只是一个字节、一个字或是一个双字\nmovb $0xF,(%ebx) 错误：Cannot use %ebx as address register\n补充：何时使用零扩展，何时使用符号扩展： 当窄数据类型为：有符号数据类型时，扩展为宽数据类型时，使用符号扩展。 当窄数据类型为：无符号数据类型时，扩展为宽数据类型时，使用零扩展。\n压入和弹出栈数据（仅适用于8字节的） 将四字压入栈\n1 2 subq $8,%rsp #Decrement stack pointer movq %rbp, (%rsp) #Store %rbp on stack 将四字弹出栈\n1 2 movq (%rsp), %rax #Read %rax from stack addq $8,%rsp #Increment stack pointer 算数和逻辑操作 加载有效地址（允许的伸缩因子1、2、4和8覆盖了所有基本简单数据类型的大小） 加载有效地址（load effective address）指令 leaq 实际上是 mova 指令的变形。它的指令形式是从内存读数据到寄存器，但实际上它根本就没有引用内存。它的第一个操作数看上去是一个内存引用，但该指令并不是从指定的位置读入数据，而是将有效地址写入到目的操作数。在图3-10 中我们用 C语言的地址操作符 \u0026s 说明这种计算。这条指令可以为后面的内存引用产生指针。另外，它还可以简洁地描述普通的算术操作。例如，如果寄存器 %rdx 的值为 x，那么指令 leaq 7（%rdx,%rdx,4)，%rax 将设置寄存器 %rax 的值为 5x+7。编译器经常发现 leaq 的一些灵活用法，根本就与有效地址计算无关。目的操作数必须是一个寄存器。\n一元和二元操作 二元操作的第二个操作数既是源又是目的\n注意：当第二个操作数为内存地址时，处理器必领从内存读出值，执行操作，再把结果写回内存。\n移位操作 移位操作，先给出移位量，然后第二项给出的是要移位的数。可以进行算术和逻辑右移。移位量可以是一个立即数，或者放在单字节寄存器 %cl 中。（这些指令很特别，因为只允许以这个特定的寄存器作为操作数。)原则上来说，1个字节的移位量使得移位量的编码范围可以达到 2^8^-1=255。 x86-64 中，移位操作对w位长的数据值进行操作，移位量是由 %cl 奇存器的低m位决定的，这里2^m^=w。高位会被忽略。所以，例如当奇存器 %cl 的十六进制值为 OxFF 时，指令 salb 会移7位，salw 会移15位，sall 会移31位，而 salq 会移63位。\n特殊的算数操作 乘法指令：\nx86-64 指令集提供了两条不同的 “单操作数” 乘法指令，以计算两个64位值的全128 位乘积——一个是无符号数乘法(mulq)，而另一个是补码乘法(imulq）。这两条指令都要求一个参数必须在奇存器%rax中，而另一个作为指令的源操作数给出。然后乘积存放在奇存器%rdx（高 64 位）和%rax（低 64 位）中。虽然 imulq 这个名字可以用于两个不同的乘法操作，但是汇编器能够通过计算操作数的数目，分辨出想用哪条指令。\n除法指令：\n前面的算术运算表（图3-10）没有列出除法或取模操作。这些操作是由单操作数除法指令来提供的，类似于单操作数乘法指令。有符号除法指令idivq 将寄存器 %rdx（高 64位）和%rax（低 64 位）中的 128 位数作为被除数，而除数作为指令的操作数给出。指令将商存储在奇存器 %rax 中，将余数存储在寄存器 %rdx 中。\n对于大多数 64 位除法应用来说，被除数也常常是一个64位的值。这个值应该存放在%rax中，%rdx 的位应该设置为全0（无符号运算）或者%rax 的符号位（有符号运算）。后面这个操作可以用指令 cqto来完成。这条指令不需要操作数——它隐含读出 %rax 的符号位，并将它复制到 %rdx 的所有位。\n控制 条件码 除了整数奇存器，CPU 还维护着一组单个位的条件码(condition code)寄存器，它们描述了最近的算术或逻辑操作的属性。可以检测这些奇存器来执行条件分支指令。最常用的条件码有：\nCF(carry flag)：进位标志。最近的操作使最高位产生了进位。可用来检查无符号操作的溢出。\nZF(zero flag)：零标志。最近的操作得出的结果为 0。\nSF(sign flag)：符号称志，最近的操作得到的结果为负数。(运算结果最高有效位为1，说明结果是负数，SF会被置为1)\nOF(overflow flag)：溢出标志。最近的操作导致一个补码溢出——正溢出或负溢出。\nleaq指令不改变任何条件码，因为它是用来进行地址计算的。\nCMP指令和TEST指令只设置条件码而不改变任何其他奇存器。(想要的结果最终在%rax中)\nCMP指令根据两个操作数之差来设置条件码。除了只设置条件码而不更新目的寄存器之外，CMP 指令与 SUB 指令的行为是一样的。\nTEST指令的行为与AND指令一样，除了它们只设置条件码而不改变目的寄存器的值。典型的用法是，两个操作数是一样的（例如，testq %rax,%rax 用来检查 %rax 是负数、零，还是正数），或其中的一个操作数是一个掩码，用来指示哪些位应该被测试。 （想要的结果最终在%rax中）\n访问条件码 一条 SET指令的目的操作数是低位单字节寄存器元素(图 3-2)之一，或是一个字节的内存位置，指令会将这个字节设置成0或者1。为了得到一个 32 位或 64 位结果，我们必须对高位清零。\n跳转指令 图 3-15 列举了不同的跳转指令。jmp 指令是无条件跳转。它可以是直接跳转，即跳转目标是作为指令的一部分编码的；也可以是间接跳转，即跳转目标是从寄存器或内存位置中读出的。汇编语言中，直接跳转是给出一个标号作为跳转目标的，例如标号 “.L1”。间接跳转的写法是’*‘ ，后面跟一个操作数指示符，举个例子，指令\njmp *%rax\n用寄存器%rax中的值作为跳转目标，而指令\njmp *(%rax)\n以%rax 中的值作为读地址，从内存中读出跳转目标\n跳转指令的编码 跳转指令有几种不同的编码，但是最常用都是PC相对的(PC-relative)。也就是，它们会将目标指令的地址与紧跟在跳转指令后面那条指令的地址之间的差作为编码。这些地址偏移量可以编码为1、2或4个字节。第二种编码方法是出“绝对”地址，用4个字节直接指定目标。汇编器和链接器会选择适当的跳转目的编码。\n用条件控制来实现条件分支 用条件传送来实现条件分支 循环 1.do-while 2.while **①跳转到中间（jump to middle）：**它执行了一个无条件跳转跳转到循环结尾处的测试，以此来执行初始的测试。\n**②guarded-do：**首先用条件分支，如果初始条件不成立就跳过循环，把代码变换为do-while\n3.for循环 switch语句 switch（开关）语句可以根据一个整数索引值进行多重分支（multiway branching）。在处理具有多种可能结果的测试时，这种语句特别有用。它们不仅提高了 C 代码的可读性，而且通过使用跳转表（jump table）这种数据结构使得实现更加高效。跳转表是一个数组， 表项i是一个代码段的地址，这个代码段实现当开关索引值等于i时程序应该采取的动作。程序代码用开关索引值来执行一个跳转表内的数组引用，确定跳转指令的目标。和使用一组很长的 if-else 语句相比，使用跳转表的优点是执行开关语句的时间与开关情况的数量无关。GCC 根据开关情况的数量和开关情况值的稀疏程度来翻译开关语句。当开关情况数量比较多（例如4个以上），并且值的范围跨度比较小时，就会使用跳转表。\n\u0026\u0026：创建一个指向代码位置的指针。\n过程 mov和lea的区别 lea是“load effective address”的缩写，简单的说，lea指令可以用来将一个内存地址直接赋给目的操作数，例如： lea [ebx+8],eax 就是将ebx+8这个值直接赋给eax，而不是把ebx+8处的内存地址里的数据赋给eax。\n而mov指令则恰恰相反，例如： mov [ebx+8],eax 则是把内存地址为ebx+8处的数据赋给eax。\n栈帧 栈上用于特定call的每个内存块称为栈帧\n每一次函数的调用，都会在调用栈（call stack）上维护一个独立的栈帧（stack frame）\n每个独立的栈帧一般包括:\n函数的返回地址和参数\n临时变量: 包括函数的非静态局部变量以及编译器自动生成的其他临时变量\n函数调用的上下文\n栈是从高地址向低地址延伸，一个函数的栈帧用 %rbp 和 %rsp 这两个寄存器来划定范围。%rbp 指向当前的栈帧的底部，%rsp 始终指向栈帧的顶部;\n%rbp 寄存器又被称为帧指针(Frame Pointer);\n%rspesp 寄存器又被称为栈指针(Stack Pointer);\nret 执行ret，ret指令将始终采用栈指针指向的地址并将它作为返回地址。所以%rsp在你执行ret之前就恢复到它原来的位置是非常重要的。\n1 2 3 4 subq $16, %rsp ... addq $16, %rsp ret 在不同的函数里寄存器是共享的，而内存是隔离的 运行时栈 转移控制 将控制从函数P转移到函数Q只需要简单地把程序计数器(PC)设置为Q的代码的起始位置。不过，当稍后从Q返回的时候，处理器必须记录好它需要继续P的执行的代码位置。在x86-64 机器中，这个信息是用指令 call Q调用过程Q来记录的。该指令会把地址A压入栈中，并将PC设置为Q的起始地址。**压入的地址A被称为返回地址，是紧跟在call指令后面的那条指令的地址。**对应的指令ret会从栈中弹出地址A，并把PC设置为 A。下表给出的是call和ret指令的一般形式：\n数据传送 如果一个函数有大于6个整型参数，超出 6个的部分就要通过栈来传递：把参数 1~6 复制到对应的奇存器，把参数7~n放到栈上，而参数7位于栈顶。\n栈上的局部存储 到目前为止我们看到的大多数过程示例都不需要超出寄存器大小的本地存储区域。不过有些时候，局部数据必须在放在内在中，常见的情况包括：\n寄存器不足够存放所有的本地数据。\n对一个局部变量使用地址运算符‘\u0026’，因此必须能够为它产生一个地址。\n某些局部变量是数组或结构，因此必领能够通过数组或结构引用被访问到。\n一般来说，过程通过减小栈指针在栈上分配空间。分配的结果作为栈帧的一部分，标号为 “局部变量”\n寄存器中的局部存储空间 根据惯例，寄存器%rbx、%rbp 和%r12～%r15 被划分为被调用者保存寄存器。当过程 P调用过程Q时，Q必须保存这些寄存器的值，保证它们的值在Q返回到P时与Q被调用时是一样的。过程Q保存一个寄存器的值不变，要么就是根本不去改变它，要么就是把原始值压人栈中，改变奇存器的值，然后在返回前从栈中弹出旧值。压人寄存器的值会在栈帧中创建标号为“被保存的寄存器”的一部分，如图 3-25 中所示。有了这条惯例，P的代码就能安全地把值存在被调用者保存寄存器中(当然，要先把之前的值保存到栈上），调用Q，然后继续使用寄存器中的值，不用担心值被破坏。\n数组分配和访问 基本原则 X86-64 的内存引用指令可以用来简化数组访问。例如，假设 E 是一个 int 型的数组，而我们想计算 E[i]，在此，E的地址存放在寄存器％rdx 中，而 i 存放在寄存器％rcx 中。然后，指令\n1 movl (%rdx,%rcx,4),%eax 会执行地址计算 x~e~ + 4i 读这个内存位置的值，并将结果存放到寄存器 ％eax 中。允许的伸缩因子 1、2、4 和 8 覆盖了所有基本简单数据类型的大小。\n指针运算 嵌套的数组 这里，L 是数据类型 T 以字节为单位的大小。\n正如可以看到的那样，这段代码计算元素的地址为 x~A~ + 12i + 4j = x~A~ + 4(3i +j)，使用了X86-64地址运算的伸缩和加法特性。\n定长数组 变长数组 异质的数据结构 结构 联合 不怎么用\n数据对齐 许多计算机系统对基本数据类型的合法地址做出了一些限制，要求某种类型对象的地址必须是某个值 K（通常是 2、4 或 8）的倍数。\n如果一个结构体的成员按照不同顺序声明，可能会得到不同大小的alignment（为了内存对齐）\n如果只是把最大的东西放在开头，再依次放更小的元素，能够最大限度地减少任何浪费的空间\n对于结构体来说：\n每个结构都有对齐要求 K （K=任何元素的最大对齐）\n初始地址和结构长度必须是 K 的倍数\n（结构体中的）双精度数，它应该位于一个边界上，这样浮点数的起始地址是8的倍数\n内存、缓冲区 内存越界引用和缓冲区溢出 内存结构 00007FFFFFFFFFFF = 111 1111( * 11) = 2^47^ = 128TB\n缓冲区溢出 缓冲区是一块连续的计算机内存区域，可保存相同数据类型的多个实例。缓冲区可以是堆栈(自动变量)、堆(动态内存)和静态数据区(全局或静态)。在C/C++语言中，通常使用字符数组和malloc/new之类内存分配函数实现缓冲区。溢出指数据被添加到分配给该缓冲区的内存块之外。缓冲区溢出是最常见的程序缺陷。\n栈帧结构的引入为高级语言中实现函数或过程调用提供直接的硬件支持，但由于将函数返回地址这样的重要数据保存在程序员可见的堆栈中，因此也给系统安全带来隐患。若将函数返回地址修改为指向一段精心安排的恶意代码，则可达到危害系统安全的目的。此外，堆栈的正确恢复依赖于压栈的EBP值的正确性，但EBP域邻近局部变量，若编程中有意无意地通过局部变量的地址偏移窜改EBP值，则程序的行为将变得非常危险。\n由于C/C++语言没有数组越界检查机制，当向局部数组缓冲区里写入的数据超过为其分配的大小时，就会发生缓冲区溢出。攻击者可利用缓冲区溢出来窜改进程运行时栈，从而改变程序正常流向，轻则导致程序崩溃，重则系统特权被窃取。\n例如，对于下图的栈结构：\n若将长度为16字节的字符串赋给acArrBuf数组，则系统会从acArrBuf[0]开始向高地址填充栈空间，导致覆盖EBP值和函数返回地址。若攻击者用一个有意义的地址(否则会出现段错误)覆盖返回地址的内容，函数返回时就会去执行该地址处事先安排好的攻击代码。最常见的手段是通过制造缓冲区溢出使程序运行一个用户shell，再通过shell执行其它命令。若该程序有root或suid执行权限，则攻击者就获得一个有root权限的shell，进而可对系统进行任意操作。\n除通过使堆栈缓冲区溢出而更改返回地址外，还可改写局部变量(尤其函数指针)以利用缓冲区溢出缺陷。\n注意，本文描述的堆栈缓冲区溢出不同于广义的“堆栈溢出(Stack OverFlow)”，后者除局部数组越界和内存覆盖外，还可能由于调用层次太多(尤其应注意递归函数)或过大的局部变量所导致。\n数据读写 数据从内存要写入磁盘中时，数据会被先写入到磁盘缓冲区，磁盘缓冲区满了再把数据写入磁盘。\n磁盘缓冲区是为了平滑不同I/O设备的速度差。\n是的，磁盘是分区分块存储的。如果是机械硬盘，是分磁道和扇区的。当磁头转到一个扇区的某磁道时，开始读取数据，如果只读取了 100KB 的数据，这时操作系统就想，磁头转到这儿看不容易啊，反正来都来了，顺带多读点数据吧，万一用的着呢。\n所以，读取数据的时候也是通过缓冲区的。\n题外话：如果应用的数据存放在不同的磁道，不同的扇区，那么读取的效率是很低的，这被称为磁盘碎片，所以 windows 有个操作叫“整理磁盘碎片”。\n对抗缓冲区溢出攻击 1.栈随机化\n2.栈破坏检测\n3.限制可执行代码区域\n许多系统允许控制三种访问形式：读（从内存读数据），写（存储数据到内存）和执行（将内存的内容看作机器级代码）。以前，x86 体系结构将读和执行访问控制合并成一个1位的标志，这样任何被标记为可读的页也都是可执行的。栈必须是既可读又可写的，因而栈上的字节也都是可执行的。已经实现的很多机制，能够限制一些页是可读但是不可执行的，然而这些机制通常会带来严重的性能损失。\n最近，AMD 为它的 64 位处理器的内存保护引入了”NX“（No-Execute，不执行）位，将读和执行访问模式分开，Intel 也跟进了。有了这个特性，栈可以被标记为可读和可写，但是不可执行，而检査页是否可执行由硬件来完成，效率上没有损失。\n面向返回的编程攻击 浮点代码 浮点传送和转换操作 注：(v)cvttss2si ： Convert with Truncation Scalar Single-Precision Floating-Point Value to Integer\n浮点运算操作 在浮点代码中使用位级操作 浮点比较操作 ",
  "wordCount" : "7987",
  "inLanguage": "zh",
  "datePublished": "2022-04-13T00:00:00Z",
  "dateModified": "2022-04-13T00:00:00Z",
  "author":[{
    "@type": "Person",
    "name": "chance7bin"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://chance7bin.github.io/posts/basic/csapp/%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Binb's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://chance7bin.github.io/img/%E7%BE%8E%E9%98%9F.jpg"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://chance7bin.github.io/" accesskey="h" title="Binb&#39;s Blog (Alt + H)">
                <img src="https://chance7bin.github.io/img/%E7%BE%8E%E9%98%9F.jpg" alt="" aria-label="logo"
                    height="35">Binb&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://chance7bin.github.io/search" title="🔍搜索 (Alt &#43; /)" accesskey=/>
                    <span>🔍搜索</span>
                </a>
            </li>
            <li>
                <a href="https://chance7bin.github.io/" title="🏠 主页">
                    <span>🏠 主页</span>
                </a>
            </li>
            <li>
                <a href="https://chance7bin.github.io/archives/" title="⏱️ 时间轴">
                    <span>⏱️ 时间轴</span>
                </a>
            </li>
            <li>
                <a href="https://chance7bin.github.io/posts" title="📚 文章">
                    <span>📚 文章</span>
                </a>
            </li>
            <li>
                <a href="https://chance7bin.github.io/tags" title="🔖 标签">
                    <span>🔖 标签</span>
                </a>
            </li>
            <li>
                <a href="https://github.com/chance7bin" title="GitHub">
                    <span>GitHub</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://chance7bin.github.io/">🏠 主页</a>&nbsp;»&nbsp;<a href="https://chance7bin.github.io/posts/">📚 文章</a>&nbsp;»&nbsp;<a href="https://chance7bin.github.io/posts/basic/">📕 计算机基础</a>&nbsp;»&nbsp;<a href="https://chance7bin.github.io/posts/basic/csapp/">CSAPP</a></div>
    <h1 class="post-title">
      程序的机器级表示
    </h1>
    <div class="post-meta">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css">


<style>
    i[id*="post_meta_style"] {
        display: flex;
        align-items: center;
        margin: 0 0 10px 0;
    }

    .parent-post-meta {
        display: flex;
        flex-wrap: wrap;
        opacity: 0.8;
    }
</style>

<span class="parent-post-meta">
    <span id="post_meta_style_1">
        <span class="fa fa-calendar-check-o"></span>
        <span>2022-04-13
            &nbsp;&nbsp;
        </span>
    </span>
    
    
    
    
    
    
    
    <span id="post_meta_style_3">
        <span class="fa fa-file-word-o"></span>
        <span>7987字
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_4">
        <span class="fa fa-clock-o"></span>
        <span>16分钟
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_5">
        <span class="fa fa-user-o"></span>
        <span>chance7bin
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_6">
        <span class="fa fa-tags" style="opacity: 0.8"></span>
        <span>
            <span class="post-tags-meta">
                <a href="https://chance7bin.github.io/tags/csapp/" style="color: var(--secondary)!important;">csapp</a>
            </span>
        </span>
    </span>

    
</span>


      
      
      
      
      
      
      
          
          
          
              
              
              
              
          
      
    </div>
  </header>
   <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">目录</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#%e7%a8%8b%e5%ba%8f%e7%bc%96%e7%a0%81" aria-label="程序编码">程序编码</a><ul>
                            
                    <li>
                        <a href="#%e4%bb%a3%e7%a0%81%e7%a4%ba%e4%be%8b" aria-label="代码示例">代码示例</a></li>
                    <li>
                        <a href="#%e4%bd%bf%e7%94%a8gcc%e7%bc%96%e8%af%91" aria-label="使用gcc编译">使用gcc编译</a></li></ul>
                    </li>
                    <li>
                        <a href="#att%e4%b8%8eintel" aria-label="ATT与Intel"><code>ATT与Intel</code></a></li>
                    <li>
                        <a href="#%e6%95%b0%e6%8d%ae%e6%a0%bc%e5%bc%8f" aria-label="数据格式">数据格式</a></li>
                    <li>
                        <a href="#%e8%ae%bf%e9%97%ae%e4%bf%a1%e6%81%af" aria-label="访问信息">访问信息</a><ul>
                            
                    <li>
                        <a href="#%e6%93%8d%e4%bd%9c%e6%95%b0%e6%a0%bc%e5%bc%8f" aria-label="操作数格式">操作数格式</a></li>
                    <li>
                        <a href="#%e6%95%b0%e6%8d%ae%e4%bc%a0%e9%80%81%e6%8c%87%e4%bb%a4" aria-label="数据传送指令">数据传送指令</a></li>
                    <li>
                        <a href="#%e5%8e%8b%e5%85%a5%e5%92%8c%e5%bc%b9%e5%87%ba%e6%a0%88%e6%95%b0%e6%8d%ae%e4%bb%85%e9%80%82%e7%94%a8%e4%ba%8e8%e5%ad%97%e8%8a%82%e7%9a%84" aria-label="压入和弹出栈数据（仅适用于8字节的）">压入和弹出栈数据（仅适用于8字节的）</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e7%ae%97%e6%95%b0%e5%92%8c%e9%80%bb%e8%be%91%e6%93%8d%e4%bd%9c" aria-label="算数和逻辑操作">算数和逻辑操作</a><ul>
                            
                    <li>
                        <a href="#%e5%8a%a0%e8%bd%bd%e6%9c%89%e6%95%88%e5%9c%b0%e5%9d%80%e5%85%81%e8%ae%b8%e7%9a%84%e4%bc%b8%e7%bc%a9%e5%9b%a0%e5%ad%90124%e5%92%8c8%e8%a6%86%e7%9b%96%e4%ba%86%e6%89%80%e6%9c%89%e5%9f%ba%e6%9c%ac%e7%ae%80%e5%8d%95%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b%e7%9a%84%e5%a4%a7%e5%b0%8f" aria-label="加载有效地址（允许的伸缩因子1、2、4和8覆盖了所有基本简单数据类型的大小）">加载有效地址（允许的伸缩因子1、2、4和8覆盖了所有基本简单数据类型的大小）</a></li>
                    <li>
                        <a href="#%e4%b8%80%e5%85%83%e5%92%8c%e4%ba%8c%e5%85%83%e6%93%8d%e4%bd%9c" aria-label="一元和二元操作">一元和二元操作</a></li>
                    <li>
                        <a href="#%e7%a7%bb%e4%bd%8d%e6%93%8d%e4%bd%9c" aria-label="移位操作">移位操作</a></li>
                    <li>
                        <a href="#%e7%89%b9%e6%ae%8a%e7%9a%84%e7%ae%97%e6%95%b0%e6%93%8d%e4%bd%9c" aria-label="特殊的算数操作">特殊的算数操作</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e6%8e%a7%e5%88%b6" aria-label="控制">控制</a><ul>
                            
                    <li>
                        <a href="#%e6%9d%a1%e4%bb%b6%e7%a0%81" aria-label="条件码">条件码</a></li>
                    <li>
                        <a href="#%e8%ae%bf%e9%97%ae%e6%9d%a1%e4%bb%b6%e7%a0%81" aria-label="访问条件码">访问条件码</a></li>
                    <li>
                        <a href="#%e8%b7%b3%e8%bd%ac%e6%8c%87%e4%bb%a4" aria-label="跳转指令">跳转指令</a></li>
                    <li>
                        <a href="#%e8%b7%b3%e8%bd%ac%e6%8c%87%e4%bb%a4%e7%9a%84%e7%bc%96%e7%a0%81" aria-label="跳转指令的编码">跳转指令的编码</a></li>
                    <li>
                        <a href="#%e7%94%a8%e6%9d%a1%e4%bb%b6%e6%8e%a7%e5%88%b6%e6%9d%a5%e5%ae%9e%e7%8e%b0%e6%9d%a1%e4%bb%b6%e5%88%86%e6%94%af" aria-label="用条件控制来实现条件分支">用条件控制来实现条件分支</a></li>
                    <li>
                        <a href="#%e7%94%a8%e6%9d%a1%e4%bb%b6%e4%bc%a0%e9%80%81%e6%9d%a5%e5%ae%9e%e7%8e%b0%e6%9d%a1%e4%bb%b6%e5%88%86%e6%94%af" aria-label="用条件传送来实现条件分支">用条件传送来实现条件分支</a></li>
                    <li>
                        <a href="#%e5%be%aa%e7%8e%af" aria-label="循环">循环</a><ul>
                            
                    <li>
                        <a href="#1do-while" aria-label="1.do-while">1.do-while</a></li>
                    <li>
                        <a href="#2while" aria-label="2.while"><strong>2.while</strong></a></li>
                    <li>
                        <a href="#3for%e5%be%aa%e7%8e%af" aria-label="3.for循环">3.for循环</a></li></ul>
                    </li>
                    <li>
                        <a href="#switch%e8%af%ad%e5%8f%a5" aria-label="switch语句">switch语句</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e8%bf%87%e7%a8%8b" aria-label="过程">过程</a><ul>
                            <ul>
                            
                    <li>
                        <a href="#mov%e5%92%8clea%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="mov和lea的区别">mov和lea的区别</a></li>
                    <li>
                        <a href="#%e6%a0%88%e5%b8%a7" aria-label="栈帧">栈帧</a></li>
                    <li>
                        <a href="#ret" aria-label="ret">ret</a></li>
                    <li>
                        <a href="#%e5%9c%a8%e4%b8%8d%e5%90%8c%e7%9a%84%e5%87%bd%e6%95%b0%e9%87%8c%e5%af%84%e5%ad%98%e5%99%a8%e6%98%af%e5%85%b1%e4%ba%ab%e7%9a%84%e8%80%8c%e5%86%85%e5%ad%98%e6%98%af%e9%9a%94%e7%a6%bb%e7%9a%84" aria-label="在不同的函数里寄存器是共享的，而内存是隔离的"><strong>在不同的函数里寄存器是共享的，而内存是隔离的</strong></a></li></ul>
                        
                    <li>
                        <a href="#%e8%bf%90%e8%a1%8c%e6%97%b6%e6%a0%88" aria-label="运行时栈">运行时栈</a></li>
                    <li>
                        <a href="#%e8%bd%ac%e7%a7%bb%e6%8e%a7%e5%88%b6" aria-label="转移控制">转移控制</a></li>
                    <li>
                        <a href="#%e6%95%b0%e6%8d%ae%e4%bc%a0%e9%80%81" aria-label="数据传送">数据传送</a></li>
                    <li>
                        <a href="#%e6%a0%88%e4%b8%8a%e7%9a%84%e5%b1%80%e9%83%a8%e5%ad%98%e5%82%a8" aria-label="栈上的局部存储">栈上的局部存储</a></li>
                    <li>
                        <a href="#%e5%af%84%e5%ad%98%e5%99%a8%e4%b8%ad%e7%9a%84%e5%b1%80%e9%83%a8%e5%ad%98%e5%82%a8%e7%a9%ba%e9%97%b4" aria-label="寄存器中的局部存储空间">寄存器中的局部存储空间</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e6%95%b0%e7%bb%84%e5%88%86%e9%85%8d%e5%92%8c%e8%ae%bf%e9%97%ae" aria-label="数组分配和访问">数组分配和访问</a><ul>
                            
                    <li>
                        <a href="#%e5%9f%ba%e6%9c%ac%e5%8e%9f%e5%88%99" aria-label="基本原则">基本原则</a></li>
                    <li>
                        <a href="#%e6%8c%87%e9%92%88%e8%bf%90%e7%ae%97" aria-label="指针运算">指针运算</a></li>
                    <li>
                        <a href="#%e5%b5%8c%e5%a5%97%e7%9a%84%e6%95%b0%e7%bb%84" aria-label="嵌套的数组">嵌套的数组</a></li>
                    <li>
                        <a href="#%e5%ae%9a%e9%95%bf%e6%95%b0%e7%bb%84" aria-label="定长数组">定长数组</a></li>
                    <li>
                        <a href="#%e5%8f%98%e9%95%bf%e6%95%b0%e7%bb%84" aria-label="变长数组">变长数组</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e5%bc%82%e8%b4%a8%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84" aria-label="异质的数据结构">异质的数据结构</a><ul>
                            
                    <li>
                        <a href="#%e7%bb%93%e6%9e%84" aria-label="结构">结构</a></li>
                    <li>
                        <a href="#%e8%81%94%e5%90%88" aria-label="联合">联合</a></li>
                    <li>
                        <a href="#%e6%95%b0%e6%8d%ae%e5%af%b9%e9%bd%90" aria-label="数据对齐">数据对齐</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e5%86%85%e5%ad%98%e7%bc%93%e5%86%b2%e5%8c%ba" aria-label="内存、缓冲区">内存、缓冲区</a><ul>
                            
                    <li>
                        <a href="#%e5%86%85%e5%ad%98%e8%b6%8a%e7%95%8c%e5%bc%95%e7%94%a8%e5%92%8c%e7%bc%93%e5%86%b2%e5%8c%ba%e6%ba%a2%e5%87%ba" aria-label="内存越界引用和缓冲区溢出">内存越界引用和缓冲区溢出</a><ul>
                            
                    <li>
                        <a href="#%e5%86%85%e5%ad%98%e7%bb%93%e6%9e%84" aria-label="内存结构">内存结构</a></li>
                    <li>
                        <a href="#%e7%bc%93%e5%86%b2%e5%8c%ba%e6%ba%a2%e5%87%ba" aria-label="缓冲区溢出">缓冲区溢出</a></li>
                    <li>
                        <a href="#%e6%95%b0%e6%8d%ae%e8%af%bb%e5%86%99" aria-label="数据读写">数据读写</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e5%af%b9%e6%8a%97%e7%bc%93%e5%86%b2%e5%8c%ba%e6%ba%a2%e5%87%ba%e6%94%bb%e5%87%bb" aria-label="对抗缓冲区溢出攻击">对抗缓冲区溢出攻击</a></li>
                    <li>
                        <a href="#%e9%9d%a2%e5%90%91%e8%bf%94%e5%9b%9e%e7%9a%84%e7%bc%96%e7%a8%8b%e6%94%bb%e5%87%bb" aria-label="面向返回的编程攻击">面向返回的编程攻击</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e6%b5%ae%e7%82%b9%e4%bb%a3%e7%a0%81" aria-label="浮点代码">浮点代码</a><ul>
                            
                    <li>
                        <a href="#%e6%b5%ae%e7%82%b9%e4%bc%a0%e9%80%81%e5%92%8c%e8%bd%ac%e6%8d%a2%e6%93%8d%e4%bd%9c" aria-label="浮点传送和转换操作">浮点传送和转换操作</a></li>
                    <li>
                        <a href="#%e6%b5%ae%e7%82%b9%e8%bf%90%e7%ae%97%e6%93%8d%e4%bd%9c" aria-label="浮点运算操作">浮点运算操作</a></li>
                    <li>
                        <a href="#%e5%9c%a8%e6%b5%ae%e7%82%b9%e4%bb%a3%e7%a0%81%e4%b8%ad%e4%bd%bf%e7%94%a8%e4%bd%8d%e7%ba%a7%e6%93%8d%e4%bd%9c" aria-label="在浮点代码中使用位级操作">在浮点代码中使用位级操作</a></li>
                    <li>
                        <a href="#%e6%b5%ae%e7%82%b9%e6%af%94%e8%be%83%e6%93%8d%e4%bd%9c" aria-label="浮点比较操作">浮点比较操作</a>
                    </li>
                </ul>
                </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>
  <div class="post-content"><h3 id="程序编码">程序编码<a hidden class="anchor" aria-hidden="true" href="#程序编码">#</a></h3>
<h4 id="代码示例">代码示例<a hidden class="anchor" aria-hidden="true" href="#代码示例">#</a></h4>
<p><strong>mstore.c</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">long</span> <span class="nf">mult2</span><span class="p">(</span><span class="kt">long</span><span class="p">,</span> <span class="kt">long</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">multstore</span><span class="p">(</span><span class="kt">long</span> <span class="n">x</span><span class="p">,</span> <span class="kt">long</span> <span class="n">y</span><span class="p">,</span> <span class="kt">long</span> <span class="o">*</span><span class="n">dest</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="kt">long</span> <span class="n">t</span> <span class="o">=</span> <span class="nf">mult2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>main.c</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">multstore</span><span class="p">(</span><span class="kt">long</span><span class="p">,</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">long</span> <span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">	<span class="kt">long</span> <span class="n">d</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="nf">multstore</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="o">&amp;</span><span class="n">d</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="nf">printf</span><span class="p">(</span><span class="s">&#34;2 * 3 --&gt; %ld</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">d</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">long</span> <span class="nf">mult2</span><span class="p">(</span><span class="kt">long</span> <span class="n">a</span><span class="p">,</span> <span class="kt">long</span> <span class="n">b</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="kt">long</span> <span class="n">s</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">s</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="使用gcc编译">使用gcc编译<a hidden class="anchor" aria-hidden="true" href="#使用gcc编译">#</a></h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">gcc -Og -o p mstore.c main.c
</span></span></code></pre></td></tr></table>
</div>
</div><p>首先，C预处理器扩展源代码，插入所有用#include 命令指定的文件，并扩展所有用#define 声明指定的宏。其次，编译器产生两个源文件的汇编代码，名字分别为 mstore.s 和 main.s。接下来，汇编器会将汇编代码转化成二进制目标代码文件 p1.o 和 p2.o。目标代码是机器代码的一种形式，它包含所有指令的二进制表示，但是还没有填人全局值的地址。最后，链接器将两个目标代码文件与实现库两数(例如 printf）的代码合并，并产生最终的可执行代码文件(由命令行指示符 -o p 指定的）。可执行代码是我们要考虑的机器代码的第二种形式，也就是处理器执行的代码格式。会在第 7章更详细地介绍这些不同形式的机器代码之间的关系以及链接的过程。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">gcc -Og -S mstore.c
</span></span></code></pre></td></tr></table>
</div>
</div><p>产生一个汇编文件mstore.s，但是不做其他进一步的工作。</p>
<p>mstore.s完整内容如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">	.file	&#34;mstore.c&#34;
</span></span><span class="line"><span class="cl">	.text
</span></span><span class="line"><span class="cl">	.globl	multstore
</span></span><span class="line"><span class="cl">	.type	multstore, @function
</span></span><span class="line"><span class="cl">multstore:
</span></span><span class="line"><span class="cl">.LFB0:
</span></span><span class="line"><span class="cl">	.cfi_startproc
</span></span><span class="line"><span class="cl">	endbr64
</span></span><span class="line"><span class="cl">	pushq	%rbx
</span></span><span class="line"><span class="cl">	.cfi_def_cfa_offset 16
</span></span><span class="line"><span class="cl">	.cfi_offset 3, -16
</span></span><span class="line"><span class="cl">	movq	%rdx, %rbx
</span></span><span class="line"><span class="cl">	call	mult2@PLT
</span></span><span class="line"><span class="cl">	movq	%rax, (%rbx)
</span></span><span class="line"><span class="cl">	popq	%rbx
</span></span><span class="line"><span class="cl">	.cfi_def_cfa_offset 8
</span></span><span class="line"><span class="cl">	ret
</span></span><span class="line"><span class="cl">	.cfi_endproc
</span></span><span class="line"><span class="cl">.LFE0:
</span></span><span class="line"><span class="cl">	.size	multstore, .-multstore
</span></span><span class="line"><span class="cl">	.ident	&#34;GCC: (Ubuntu 9.3.0-17ubuntu1~20.04) 9.3.0&#34;
</span></span><span class="line"><span class="cl">	.section	.note.GNU-stack,&#34;&#34;,@progbits
</span></span><span class="line"><span class="cl">	.section	.note.gnu.property,&#34;a&#34;
</span></span><span class="line"><span class="cl">	.align 8
</span></span><span class="line"><span class="cl">	.long	 1f - 0f
</span></span><span class="line"><span class="cl">	.long	 4f - 1f
</span></span><span class="line"><span class="cl">	.long	 5
</span></span><span class="line"><span class="cl">0:
</span></span><span class="line"><span class="cl">	.string	 &#34;GNU&#34;
</span></span><span class="line"><span class="cl">1:
</span></span><span class="line"><span class="cl">	.align 8
</span></span><span class="line"><span class="cl">	.long	 0xc0000002
</span></span><span class="line"><span class="cl">	.long	 3f - 2f
</span></span><span class="line"><span class="cl">2:
</span></span><span class="line"><span class="cl">	.long	 0x3
</span></span><span class="line"><span class="cl">3:
</span></span><span class="line"><span class="cl">	.align 8
</span></span><span class="line"><span class="cl">4:
</span></span></code></pre></td></tr></table>
</div>
</div><p>上面代码中每个缩进去的行都对应于一条机器指令。比如，pushq 指令表示应该将寄存器 %rbx 的内容压人程序栈中。</p>
<p>如果使用 “-c” 命令行选项，GCC会编译并汇编该代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">gcc -Og -c mstore.c
</span></span></code></pre></td></tr></table>
</div>
</div><p>这就会产生目标代码文件 mstore.o，它是二进制格式的。</p>
<p>从中得到一个重要的信息，即机器执行的程序只是一个字节序列，它是对一系列指令的编码。机器对产生这些指令的源代码几乎一无所知。</p>
<p>查看机器代码文件的内容，反汇编器（disassembler）很有用</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">objdump -d mstore.o
</span></span></code></pre></td></tr></table>
</div>
</div><p>结果如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">0000000000000000 &lt;multstore&gt;:
</span></span><span class="line"><span class="cl">   0:	f3 0f 1e fa          	endbr64 
</span></span><span class="line"><span class="cl">   4:	53                   	push   %rbx
</span></span><span class="line"><span class="cl">   5:	48 89 d3             	mov    %rdx,%rbx
</span></span><span class="line"><span class="cl">   8:	e8 00 00 00 00       	callq  d &lt;multstore+0xd&gt;
</span></span><span class="line"><span class="cl">   d:	48 89 03             	mov    %rax,(%rbx)
</span></span><span class="line"><span class="cl">  10:	5b                   	pop    %rbx
</span></span><span class="line"><span class="cl">  11:	c3                   	retq
</span></span></code></pre></td></tr></table>
</div>
</div><p>生成实际可执行的代码需要对一组目标代码文件运行链接器，而这一组目标代码文件中必须含有一个main函数</p>
<p>用如下方法生成可执行文件prog</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">gcc -Og -o p mstore.c main.c
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="att与intel"><code>ATT与Intel</code><a hidden class="anchor" aria-hidden="true" href="#att与intel">#</a></h3>
<img src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232303.png" alt="image-20211125142907321" style="zoom:80%;" /> 
<h3 id="数据格式">数据格式<a hidden class="anchor" aria-hidden="true" href="#数据格式">#</a></h3>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232331.png" alt="image-20211104230312430"  />
</p>
<p>大多数 GCC 生成的汇编代码指令都有一个宇符的后缀，表明操作数的大小，例如，数据传送指令有四个变种：movb(传送字节）、movw(传送宇)、movI(传送双字)和movq(传送四字)。后级‘l’用来表示双字，因为32位数被看成是“长字(1ong word)”。注意，汇编代码也使用后级‘l’来表示 4 字节整数和8字节双精度浮点数。这不会产生歧义，因为浮点数使用的是一组完全不同的指令和寄存器。</p>
<h3 id="访问信息">访问信息<a hidden class="anchor" aria-hidden="true" href="#访问信息">#</a></h3>
<p>寄存器的名字都是以%r开头，不过后面还跟着一些不同的命名规则的名字。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232376.png" alt="image-20211104230347242"  />
</p>
<p>​</p>
<h4 id="操作数格式">操作数格式<a hidden class="anchor" aria-hidden="true" href="#操作数格式">#</a></h4>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232354.png" alt="image-20211104230416998"  />
</p>
<img src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232367.png" alt="image-20211015222330674" style="zoom:50%;" /> 
<h4 id="数据传送指令">数据传送指令<a hidden class="anchor" aria-hidden="true" href="#数据传送指令">#</a></h4>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232371.png" alt="image-20211104230455303"  />
</p>
<p>源操作数指定的值是一个立即数，存储在寄存器中或者内存中。目的操作数指定一个位置，要么是一个奇存器，要么是一个内存地址。x86-64 加了一条限制，传送指令的两个操作数不能都指向内存位置。<strong>将一个值从一个内存位置复制到另一个内存位置需要两条指令</strong>——第一条指令将源值加载到寄存器中，第二条将该奇存器值写入目的位置。这些指令的寄存器操作数可以是 16个奇存器有标号部分中的任意一个，寄存器部分的大小必须与指令最后一个字符（b、w、l、q）指定的大小匹配。大多数情况中，MOV 指令只会更新目的操作数指定的那些寄存器字节或内存位置。唯一的例外是movI 指令以寄存器作为目的时，它会把该寄存器的高位4字节设置为0。造成这个例外的原因是 x86-64 采用的惯例，即任何为奇存器生成 32 位值的指令都会把该寄存器的高位部分置成 0。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232139.png" alt="image-20211104230517920"  />
</p>
<p><strong>补充：当寄存器的名称放在括号中时，使用这个寄存器，不管里面存的是什么，将寄存器中的值当作地址去访问</strong></p>
<p>图 3-4 中记录的最后一条指令是处理64位立即数数据的。常规的 mova 指令只能以表示为 32 位补码数字的立即数作为源操作数，然后把这个值符号扩展得到 64位的值，放到目的位置。movabsq 指令能够以任意 64 位立即数值作为源操作数，并且只能以寄存器作为目的。</p>
<p>图3-5和图3-6记录的是两类数据移动指令，在将较小的源值复制到较大的目的时使用。所有这些指令都把数据从源（在奇存器或内存中）复制到目的寄存器。MOVZ 类中的指令把目的中剩余的字节填充为 0，而MOVS 类中的指令通过符号扩展来填充，把源操作的最高位进行复制。可以观察到，每条指令名字的最后两个字符都是大小指示符：第一个字符指定源的大小，而第二个指明目的的大小。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232157.png" alt="image-20211104230543401"  />
</p>
<p>movzbl 指令不仅会把 %eax 的高3个字节清零，还会把整个寄存器 %rax 的高4个字节都清零。</p>
<p><strong>补充：x86-64中的内存引用总是用四字长寄存器给出，例如%rax，哪怕操作数只是一个字节、一个字或是一个双字</strong></p>
<p><code>movb $0xF,(%ebx) </code>      错误：Cannot use %ebx as address register</p>
<p><strong>补充：何时使用零扩展，何时使用符号扩展：</strong>
当窄数据类型为：有符号数据类型时，扩展为宽数据类型时，使用符号扩展。
当窄数据类型为：无符号数据类型时，扩展为宽数据类型时，使用零扩展。</p>
<img src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232183.png" alt="image-20211015221825774" style="zoom:50%;" /> 
<img src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232204.png" alt="image-20211015222101234" style="zoom: 67%;" /> 
<img src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232475.png" alt="image-20211015222224916" style="zoom: 67%;" /> 
<img src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232493.png" alt="image-20211015222235611" style="zoom: 67%;" /> 
<img src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232525.png" alt="image-20211015222243835" style="zoom: 67%;" /> 
<img src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232708.png" alt="image-20211015222251056" style="zoom: 67%;" /> 
<h4 id="压入和弹出栈数据仅适用于8字节的">压入和弹出栈数据（仅适用于8字节的）<a hidden class="anchor" aria-hidden="true" href="#压入和弹出栈数据仅适用于8字节的">#</a></h4>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232731.png" alt="image-20211104230628170"  />
</p>
<p><strong>将四字压入栈</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">subq $8,%rsp  #Decrement stack pointer
</span></span><span class="line"><span class="cl">movq %rbp, (%rsp)  #Store %rbp on stack
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>将四字弹出栈</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">movq (%rsp), %rax  #Read %rax from stack
</span></span><span class="line"><span class="cl">addq $8,%rsp  #Increment stack pointer
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="算数和逻辑操作">算数和逻辑操作<a hidden class="anchor" aria-hidden="true" href="#算数和逻辑操作">#</a></h3>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232758.png" alt="image-20211104230649538"  />
</p>
<h4 id="加载有效地址允许的伸缩因子124和8覆盖了所有基本简单数据类型的大小">加载有效地址（允许的伸缩因子1、2、4和8覆盖了所有基本简单数据类型的大小）<a hidden class="anchor" aria-hidden="true" href="#加载有效地址允许的伸缩因子124和8覆盖了所有基本简单数据类型的大小">#</a></h4>
<p><em>加载有效地址</em>（load effective address）指令 leaq 实际上是 mova 指令的变形。它的指令形式是从内存读数据到寄存器，但实际上它根本就没有引用内存。它的第一个操作数看上去是一个内存引用，但该指令并不是从指定的位置读入数据，<strong>而是将有效地址写入到目的操作数</strong>。在图3-10 中我们用 C语言的地址操作符 &amp;s 说明这种计算。这条指令可以为后面的内存引用产生指针。另外，它还可以简洁地描述普通的算术操作。例如，如果寄存器 %rdx 的值为 x，那么指令 leaq 7（%rdx,%rdx,4)，%rax 将设置寄存器 %rax 的值为 5x+7。编译器经常发现 leaq 的一些灵活用法，根本就与有效地址计算无关。<strong>目的操作数必须是一个寄存器。</strong></p>
<img src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232786.png" alt="image-20211015205237211" style="zoom: 50%;" /> 
<h4 id="一元和二元操作">一元和二元操作<a hidden class="anchor" aria-hidden="true" href="#一元和二元操作">#</a></h4>
<p>二元操作的第二个操作数既是源又是目的</p>
<p>注意：当第二个操作数为内存地址时，处理器必领从内存读出值，执行操作，再把结果写回内存。</p>
<h4 id="移位操作">移位操作<a hidden class="anchor" aria-hidden="true" href="#移位操作">#</a></h4>
<p>移位操作，先给出移位量，然后第二项给出的是要移位的数。可以进行算术和逻辑右移。移位量可以是一个立即数，或者放在单字节寄存器 <code>%cl</code> 中。（这些指令很特别，因为只允许以这个特定的寄存器作为操作数。)原则上来说，1个字节的移位量使得移位量的编码范围可以达到 2^8^-1=255。 x86-64 中，移位操作对w位长的数据值进行操作，移位量是由 <code>%cl</code> 奇存器的低m位决定的，这里2^m^=w。高位会被忽略。所以，例如当奇存器 <code>%cl</code> 的十六进制值为 OxFF 时，指令 salb 会移7位，salw 会移15位，sall 会移31位，而 salq 会移63位。</p>
<h4 id="特殊的算数操作">特殊的算数操作<a hidden class="anchor" aria-hidden="true" href="#特殊的算数操作">#</a></h4>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232075.png" alt="image-20211104230845340"  />
</p>
<p><strong>乘法指令：</strong></p>
<p>x86-64 指令集提供了两条不同的 “单操作数” 乘法指令，以计算两个64位值的全128 位乘积——一个是无符号数乘法(mulq)，而另一个是补码乘法(imulq）。这两条指令都要求一个参数必须在奇存器%rax中，而另一个作为指令的源操作数给出。然后乘积存放在奇存器%rdx（高 64 位）和%rax（低 64 位）中。虽然 imulq 这个名字可以用于两个不同的乘法操作，但是汇编器能够通过计算操作数的数目，分辨出想用哪条指令。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232116.png" alt="image-20211104231118512"  />
</p>
<p><strong>除法指令：</strong></p>
<p>前面的算术运算表（图3-10）没有列出除法或取模操作。这些操作是由单操作数除法指令来提供的，类似于单操作数乘法指令。有符号除法指令idivq 将寄存器 %rdx（高 64位）和%rax（低 64 位）中的 128 位数作为被除数，而除数作为指令的操作数给出。指令将商存储在奇存器 %rax 中，将余数存储在寄存器 %rdx 中。</p>
<p>对于大多数 64 位除法应用来说，被除数也常常是一个64位的值。这个值应该存放在%rax中，%rdx 的位应该设置为全0（无符号运算）或者%rax 的符号位（有符号运算）。后面这个操作可以用指令 cqto来完成。这条指令不需要操作数——它隐含读出 %rax 的符号位，并将它复制到 %rdx 的所有位。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232155.png" alt="image-20211104231141755"  />
</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232177.png" alt="image-20211104231151403"  />
</p>
<h3 id="控制">控制<a hidden class="anchor" aria-hidden="true" href="#控制">#</a></h3>
<h4 id="条件码">条件码<a hidden class="anchor" aria-hidden="true" href="#条件码">#</a></h4>
<p>除了整数奇存器，CPU 还维护着一组单个位的条件码(condition code)寄存器，它们描述了最近的算术或逻辑操作的属性。可以检测这些奇存器来执行条件分支指令。最常用的条件码有：</p>
<p>CF(carry flag)：进位标志。最近的操作使最高位产生了进位。可用来检查无符号操作的溢出。</p>
<p>ZF(zero flag)：零标志。最近的操作得出的结果为 0。</p>
<p>SF(sign flag)：符号称志，最近的操作得到的结果为负数。(运算结果最高有效位为1，说明结果是负数，SF会被置为1)</p>
<p>OF(overflow flag)：溢出标志。最近的操作导致一个补码溢出——正溢出或负溢出。</p>
<p>leaq指令不改变任何条件码，因为它是用来进行地址计算的。</p>
<p>CMP指令和TEST指令只设置条件码而不改变任何其他奇存器。(想要的结果最终在%rax中)</p>
<p>CMP指令根据两个操作数之差来设置条件码。除了只设置条件码而不更新目的寄存器之外，CMP 指令与 SUB 指令的行为是一样的。</p>
<p>TEST指令的行为与AND指令一样，除了它们只设置条件码而不改变目的寄存器的值。典型的用法是，两个操作数是一样的（例如，testq %rax,%rax 用来检查 %rax 是负数、零，还是正数），或其中的一个操作数是一个掩码，用来指示哪些位应该被测试。 （想要的结果最终在%rax中）</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232685.png" alt="image-20211104231214479"  />
</p>
<h4 id="访问条件码">访问条件码<a hidden class="anchor" aria-hidden="true" href="#访问条件码">#</a></h4>
<p>一条 SET指令的目的操作数是低位单字节寄存器元素(图 3-2)之一，或是一个字节的内存位置，指令会将这个字节设置成0或者1。为了得到一个 32 位或 64 位结果，我们必须对高位清零。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232706.png" alt="image-20211104231301954"  />
</p>
<h4 id="跳转指令">跳转指令<a hidden class="anchor" aria-hidden="true" href="#跳转指令">#</a></h4>
<p>图 3-15 列举了不同的跳转指令。jmp 指令是无条件跳转。它可以是直接跳转，即跳转目标是作为指令的一部分编码的；也可以是间接跳转，即跳转目标是从寄存器或内存位置中读出的。汇编语言中，直接跳转是给出一个标号作为跳转目标的，例如标号 “.L1”。间接跳转的写法是’*‘ ，后面跟一个操作数指示符，举个例子，指令</p>
<p>jmp *%rax</p>
<p>用寄存器%rax中的值作为跳转目标，而指令</p>
<p>jmp *(%rax)</p>
<p>以%rax 中的值作为读地址，从内存中读出跳转目标</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232735.png" alt="image-20211104231348001"  />
</p>
<h4 id="跳转指令的编码">跳转指令的编码<a hidden class="anchor" aria-hidden="true" href="#跳转指令的编码">#</a></h4>
<p>跳转指令有几种不同的编码，但是最常用都是PC相对的(PC-relative)。也就是，它们会将目标指令的地址与紧跟在跳转指令后面那条指令的地址之间的差作为编码。这些地址偏移量可以编码为1、2或4个字节。第二种编码方法是出“绝对”地址，用4个字节直接指定目标。汇编器和链接器会选择适当的跳转目的编码。</p>
<h4 id="用条件控制来实现条件分支">用条件控制来实现条件分支<a hidden class="anchor" aria-hidden="true" href="#用条件控制来实现条件分支">#</a></h4>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232115.png" alt="image-20211104231926287"  />
</p>
<img src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232142.png" alt="image-20211019103913698" style="zoom:50%;" /> 
<h4 id="用条件传送来实现条件分支">用条件传送来实现条件分支<a hidden class="anchor" aria-hidden="true" href="#用条件传送来实现条件分支">#</a></h4>
<img src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232191.png" alt="image-20211104231819599" style="zoom: 80%;" />
<img src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232220.png" alt="image-20211104231724271" style="zoom:80%;" />
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232246.png" alt="image-20211104232032562"  />
</p>
<h4 id="循环">循环<a hidden class="anchor" aria-hidden="true" href="#循环">#</a></h4>
<h5 id="1do-while">1.do-while<a hidden class="anchor" aria-hidden="true" href="#1do-while">#</a></h5>
<img src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232812.png" alt="image-20211104232105463" style="zoom:80%;" /> 
<h5 id="2while"><strong>2.while</strong><a hidden class="anchor" aria-hidden="true" href="#2while">#</a></h5>
<p>**①跳转到中间（jump to middle）：**它执行了一个无条件跳转跳转到循环结尾处的测试，以此来执行初始的测试。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232836.png" alt="image-20211104232134834"  />
</p>
<img src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232850.png" alt="image-20211104232159882" style="zoom:80%;" /> 
<p>**②guarded-do：**首先用条件分支，如果初始条件不成立就跳过循环，把代码变换为do-while</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232872.png" alt="image-20211104232223343"  />
</p>
<h5 id="3for循环">3.for循环<a hidden class="anchor" aria-hidden="true" href="#3for循环">#</a></h5>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232003.png" alt="image-20211104232244150"  />
</p>
<h4 id="switch语句">switch语句<a hidden class="anchor" aria-hidden="true" href="#switch语句">#</a></h4>
<p>switch（开关）语句可以根据一个整数索引值进行多重分支（multiway branching）。在处理具有多种可能结果的测试时，这种语句特别有用。它们不仅提高了 C 代码的可读性，而且通过使用<strong>跳转表（jump table）<strong>这种数据结构使得实现更加高效。跳转表是一个数组， <strong>表项i是一个代码段的地址</strong>，这个代码段实现当开关索引值等于i时程序应该采取的动作。程序代码用开关索引值来执行一个跳转表内的数组引用，确定跳转指令的目标。和使用一组很长的 if-else 语句相比，使用跳转表的优点是</strong>执行开关语句的时间与开关情况的数量无关</strong>。GCC 根据<strong>开关情况的数量</strong>和开关情况值的稀疏程度来翻译开关语句。当开关情况数量比较多（例如4个以上），并且值的范围跨度比较小时，就会使用跳转表。</p>
<img src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232348.png" alt="image-20211019112335735" style="zoom:50%;" /> 
<p><code>&amp;&amp;</code>：创建一个指向代码位置的指针。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232365.png" alt="image-20211104232330056"  />
</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232393.png" alt="image-20211104232340370"  />
</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232747.png" alt="image-20211104232706674"  />
</p>
<h3 id="过程">过程<a hidden class="anchor" aria-hidden="true" href="#过程">#</a></h3>
<h5 id="mov和lea的区别">mov和lea的区别<a hidden class="anchor" aria-hidden="true" href="#mov和lea的区别">#</a></h5>
<p>lea是“load effective address”的缩写，简单的说，lea指令可以用来将一个内存地址直接赋给目的操作数，例如：
<code>lea [ebx+8],eax</code> 就是将ebx+8这个值直接赋给eax，而不是把ebx+8处的内存地址里的数据赋给eax。</p>
<p>而mov指令则恰恰相反，例如：
<code>mov [ebx+8],eax</code> 则是把内存地址为ebx+8处的数据赋给eax。</p>
<h5 id="栈帧">栈帧<a hidden class="anchor" aria-hidden="true" href="#栈帧">#</a></h5>
<p>栈上用于特定call的每个内存块称为栈帧</p>
<p>每一次函数的调用，都会在调用栈（call stack）上维护一个独立的栈帧（stack frame）</p>
<p>每个独立的栈帧一般包括:</p>
<ul>
<li>
<p>函数的返回地址和参数</p>
</li>
<li>
<p>临时变量:  包括函数的非静态局部变量以及编译器自动生成的其他临时变量</p>
</li>
<li>
<p>函数调用的上下文</p>
<p>栈是从高地址向低地址延伸，一个函数的栈帧用 %rbp 和 %rsp 这两个寄存器来划定范围。%rbp 指向当前的栈帧的底部，%rsp 始终指向栈帧的顶部;</p>
<p>%rbp 寄存器又被称为帧指针(Frame Pointer);</p>
<p>%rspesp 寄存器又被称为栈指针(Stack Pointer);</p>
</li>
</ul>
<img src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232770.png" alt="image-20211030155445019" style="zoom: 67%;" /> 
<h5 id="ret">ret<a hidden class="anchor" aria-hidden="true" href="#ret">#</a></h5>
<p>执行ret，ret指令将始终采用栈指针指向的地址并将它作为返回地址。所以%rsp在你执行ret之前就恢复到它原来的位置是非常重要的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">subq $16, %rsp
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">addq $16, %rsp
</span></span><span class="line"><span class="cl">ret
</span></span></code></pre></td></tr></table>
</div>
</div><h5 id="在不同的函数里寄存器是共享的而内存是隔离的"><strong>在不同的函数里寄存器是共享的，而内存是隔离的</strong><a hidden class="anchor" aria-hidden="true" href="#在不同的函数里寄存器是共享的而内存是隔离的">#</a></h5>
<h4 id="运行时栈">运行时栈<a hidden class="anchor" aria-hidden="true" href="#运行时栈">#</a></h4>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232792.png" alt="image-20211101112656874"  />
</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232985.png" alt="image-20211105104136424"  />
</p>
<h4 id="转移控制">转移控制<a hidden class="anchor" aria-hidden="true" href="#转移控制">#</a></h4>
<p>将控制从函数P转移到函数Q只需要简单地把程序计数器(PC)设置为Q的代码的起始位置。不过，当稍后从Q返回的时候，处理器必须记录好它需要继续P的执行的代码位置。在x86-64 机器中，这个信息是用指令 call Q调用过程Q来记录的。该指令会把地址A压入栈中，并将PC设置为Q的起始地址。**压入的地址A被称为返回地址，是紧跟在call指令后面的那条指令的地址。**对应的指令ret会从栈中弹出地址A，并把PC设置为 A。下表给出的是call和ret指令的一般形式：</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232008.png" alt="image-20211105104156053"  />
</p>
<h4 id="数据传送">数据传送<a hidden class="anchor" aria-hidden="true" href="#数据传送">#</a></h4>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232025.png" alt="image-20211105104213611"  />
</p>
<p>如果一个函数有大于6个整型参数，超出 6个的部分就要通过栈来传递：把参数 1~6 复制到对应的奇存器，把参数7~n放到栈上，而参数7位于栈顶。</p>
<h4 id="栈上的局部存储">栈上的局部存储<a hidden class="anchor" aria-hidden="true" href="#栈上的局部存储">#</a></h4>
<p>到目前为止我们看到的大多数过程示例都不需要超出寄存器大小的本地存储区域。不过有些时候，局部数据必须在放在内在中，常见的情况包括：</p>
<ul>
<li>
<p>寄存器不足够存放所有的本地数据。</p>
</li>
<li>
<p>对一个局部变量使用地址运算符‘&amp;’，因此必须能够为它产生一个地址。</p>
</li>
<li>
<p>某些局部变量是数组或结构，因此必领能够通过数组或结构引用被访问到。</p>
<p>一般来说，过程通过减小栈指针在栈上分配空间。分配的结果作为栈帧的一部分，标号为 “局部变量”</p>
</li>
</ul>
<h4 id="寄存器中的局部存储空间">寄存器中的局部存储空间<a hidden class="anchor" aria-hidden="true" href="#寄存器中的局部存储空间">#</a></h4>
<p>根据惯例，寄存器%rbx、%rbp 和%r12～%r15 被划分为<code>被调用者保存寄存器</code>。当过程 P调用过程Q时，Q必须保存这些寄存器的值，保证它们的值在Q返回到P时与Q被调用时是一样的。过程Q保存一个寄存器的值不变，要么就是根本不去改变它，要么就是把原始值压人栈中，改变奇存器的值，然后在返回前从栈中弹出旧值。压人寄存器的值会在栈帧中创建标号为“被保存的寄存器”的一部分，如图 3-25 中所示。有了这条惯例，P的代码就能安全地把值存在被调用者保存寄存器中(当然，要先把之前的值保存到栈上），调用Q，然后继续使用寄存器中的值，不用担心值被破坏。</p>
<h3 id="数组分配和访问">数组分配和访问<a hidden class="anchor" aria-hidden="true" href="#数组分配和访问">#</a></h3>
<h4 id="基本原则">基本原则<a hidden class="anchor" aria-hidden="true" href="#基本原则">#</a></h4>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232047.png" alt="image-20211105105642247"  />
</p>
<p>X86-64 的内存引用指令可以用来简化数组访问。例如，假设 E 是一个 int 型的数组，而我们想计算 E[i]，在此，E的地址存放在寄存器％rdx 中，而 i 存放在寄存器％rcx 中。然后，指令</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">movl (%rdx,%rcx,4),%eax
</span></span></code></pre></td></tr></table>
</div>
</div><p>会执行地址计算 x~e~ + 4i 读这个内存位置的值，并将结果存放到寄存器 ％eax 中。允许的伸缩因子 1、2、4 和 8 覆盖了所有基本简单数据类型的大小。</p>
<h4 id="指针运算">指针运算<a hidden class="anchor" aria-hidden="true" href="#指针运算">#</a></h4>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232338.png" alt="image-20211105110019760"  />
</p>
<h4 id="嵌套的数组">嵌套的数组<a hidden class="anchor" aria-hidden="true" href="#嵌套的数组">#</a></h4>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232364.png" alt="image-20211105110153743"  />
</p>
<p>这里，L 是数据类型 T 以字节为单位的大小。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232384.png" alt="image-20211105110301768"  />
</p>
<p>正如可以看到的那样，这段代码计算元素的地址为 x~A~ + 12i + 4j = x~A~ + 4(3i +j)，使用了X86-64地址运算的伸缩和加法特性。</p>
<h4 id="定长数组">定长数组<a hidden class="anchor" aria-hidden="true" href="#定长数组">#</a></h4>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232401.png" alt="image-20211105110629686"  />
</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232420.png" alt="image-20211105110527377"  />
</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232876.png" alt="image-20211105110541773"  />
</p>
<h4 id="变长数组">变长数组<a hidden class="anchor" aria-hidden="true" href="#变长数组">#</a></h4>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232900.png" alt="image-20211105110805423"  />
</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232935.png" alt="image-20211105110820190"  />
</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232964.png" alt="image-20211105110836848"  />
</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232526.png" alt="image-20211105110903401"  />
</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232544.png" alt="image-20211105110920237"  />
</p>
<h3 id="异质的数据结构">异质的数据结构<a hidden class="anchor" aria-hidden="true" href="#异质的数据结构">#</a></h3>
<h4 id="结构">结构<a hidden class="anchor" aria-hidden="true" href="#结构">#</a></h4>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232564.png" alt="image-20211105111217803"  />
</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232596.png" alt="image-20211105111233423"  />
</p>
<h4 id="联合">联合<a hidden class="anchor" aria-hidden="true" href="#联合">#</a></h4>
<p>不怎么用</p>
<h4 id="数据对齐">数据对齐<a hidden class="anchor" aria-hidden="true" href="#数据对齐">#</a></h4>
<p>许多计算机系统对基本数据类型的合法地址做出了一些限制，要求某种类型对象的地址必须是某个值 K（通常是 2、4 或 8）的倍数。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232881.png" alt="image-20211105111500778"  />
</p>
<img src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232901.png" alt="image-20211103151633257" style="zoom:50%;" /> 
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232929.png" alt="image-20211105111650221"  />
</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232342.png" alt="image-20211105111700625"  />
</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232367.png" alt="image-20211105111717325"  />
</p>
<p>如果一个结构体的成员按照不同顺序声明，可能会得到不同大小的alignment（为了内存对齐）</p>
<p>如果只是把最大的东西放在开头，再依次放更小的元素，能够最大限度地减少任何浪费的空间</p>
<p>对于结构体来说：</p>
<p>每个结构都有对齐要求 K （K=任何元素的最大对齐）</p>
<p>初始地址和结构长度必须是 K 的倍数</p>
<p>（结构体中的）双精度数，它应该位于一个边界上，这样浮点数的起始地址是8的倍数</p>
<h3 id="内存缓冲区">内存、缓冲区<a hidden class="anchor" aria-hidden="true" href="#内存缓冲区">#</a></h3>
<h4 id="内存越界引用和缓冲区溢出">内存越界引用和缓冲区溢出<a hidden class="anchor" aria-hidden="true" href="#内存越界引用和缓冲区溢出">#</a></h4>
<h5 id="内存结构">内存结构<a hidden class="anchor" aria-hidden="true" href="#内存结构">#</a></h5>
<img src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232394.png" alt="image-20211103213517518" style="zoom: 67%;" /> 
<p>00007FFFFFFFFFFF = 111 1111( * 11) = 2^47^ = 128TB</p>
<img src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232416.png" alt="image-20211103213629248" style="zoom:67%;" /> 
<img src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232678.png" alt="image-20211103213640727" style="zoom:67%;" /> 
<h5 id="缓冲区溢出">缓冲区溢出<a hidden class="anchor" aria-hidden="true" href="#缓冲区溢出">#</a></h5>
<p>缓冲区是一块连续的计算机内存区域，可保存相同数据类型的多个实例。缓冲区可以是堆栈(自动变量)、堆(动态内存)和静态数据区(全局或静态)。在C/C++语言中，通常使用字符数组和malloc/new之类内存分配函数实现缓冲区。溢出指数据被添加到分配给该缓冲区的内存块之外。缓冲区溢出是最常见的程序缺陷。</p>
<p>栈帧结构的引入为高级语言中实现函数或过程调用提供直接的硬件支持，但由于将函数返回地址这样的重要数据保存在程序员可见的堆栈中，因此也给系统安全带来隐患。若将函数返回地址修改为指向一段精心安排的恶意代码，则可达到危害系统安全的目的。此外，堆栈的正确恢复依赖于压栈的EBP值的正确性，但EBP域邻近局部变量，若编程中有意无意地通过局部变量的地址偏移窜改EBP值，则程序的行为将变得非常危险。</p>
<p>由于C/C++语言没有数组越界检查机制，当向局部数组缓冲区里写入的数据超过为其分配的大小时，就会发生缓冲区溢出。攻击者可利用缓冲区溢出来窜改进程运行时栈，从而改变程序正常流向，轻则导致程序崩溃，重则系统特权被窃取。</p>
<p>例如，对于下图的栈结构：</p>
<p><img loading="lazy" src="https://images0.cnblogs.com/i/569008/201405/191529559812339.jpg" alt="img"  />
</p>
<p>若将长度为16字节的字符串赋给acArrBuf数组，则系统会从acArrBuf[0]开始向高地址填充栈空间，导致覆盖EBP值和函数返回地址。若攻击者用一个有意义的地址(否则会出现段错误)覆盖返回地址的内容，函数返回时就会去执行该地址处事先安排好的攻击代码。最常见的手段是通过制造缓冲区溢出使程序运行一个用户shell，再通过shell执行其它命令。若该程序有root或suid执行权限，则攻击者就获得一个有root权限的shell，进而可对系统进行任意操作。</p>
<p>除通过使堆栈缓冲区溢出而更改返回地址外，还可改写局部变量(尤其函数指针)以利用缓冲区溢出缺陷。</p>
<p>注意，本文描述的堆栈缓冲区溢出不同于广义的“堆栈溢出(Stack OverFlow)”，后者除局部数组越界和内存覆盖外，还可能由于调用层次太多(尤其应注意递归函数)或过大的局部变量所导致。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232794.png" alt="image-20211105112322760"  />
</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232870.png" alt="image-20211105112333320"  />
</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232977.png" alt="image-20211105112352009"  />
</p>
<h5 id="数据读写">数据读写<a hidden class="anchor" aria-hidden="true" href="#数据读写">#</a></h5>
<p>数据从内存要写入磁盘中时，数据会被先写入到磁盘缓冲区，磁盘缓冲区<strong>满了</strong>再把数据写入磁盘。</p>
<blockquote>
<p>磁盘缓冲区是为了平滑不同I/O设备的速度差。</p>
</blockquote>
<p>是的，磁盘是分区分块存储的。如果是机械硬盘，是分磁道和扇区的。当磁头转到一个扇区的某磁道时，开始读取数据，如果只读取了 100KB 的数据，这时操作系统就想，磁头转到这儿看不容易啊，反正来都来了，顺带多读点数据吧，万一用的着呢。</p>
<p>所以，读取数据的时候也是通过缓冲区的。</p>
<p>题外话：如果应用的数据存放在不同的磁道，不同的扇区，那么读取的效率是很低的，这被称为磁盘碎片，所以 windows 有个操作叫“整理磁盘碎片”。</p>
<h4 id="对抗缓冲区溢出攻击">对抗缓冲区溢出攻击<a hidden class="anchor" aria-hidden="true" href="#对抗缓冲区溢出攻击">#</a></h4>
<p><strong>1.栈随机化</strong></p>
<p><strong>2.栈破坏检测</strong></p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232022.png" alt="image-20211105113030543"  />
</p>
<p><strong>3.限制可执行代码区域</strong></p>
<p>许多系统允许控制三种访问形式：读（从内存读数据），写（存储数据到内存）和执行（将内存的内容看作机器级代码）。以前，x86 体系结构将读和执行访问控制合并成一个1位的标志，这样任何被标记为可读的页也都是可执行的。栈必须是既可读又可写的，因而栈上的字节也都是可执行的。已经实现的很多机制，能够限制一些页是可读但是不可执行的，然而这些机制通常会带来严重的性能损失。</p>
<p>最近，AMD 为它的 64 位处理器的内存保护引入了”NX“（No-Execute，不执行）位，将读和执行访问模式分开，Intel 也跟进了。有了这个特性，栈可以被标记为可读和可写，但是不可执行，而检査页是否可执行由硬件来完成，效率上没有损失。</p>
<h4 id="面向返回的编程攻击">面向返回的编程攻击<a hidden class="anchor" aria-hidden="true" href="#面向返回的编程攻击">#</a></h4>
<img src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232049.png" alt="image-20211104100517514" style="zoom:67%;" /> 
<img src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232063.png" alt="image-20211104100527269" style="zoom:67%;" /> 
<img src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232659.png" alt="image-20211104100534826" style="zoom:67%;" /> 
<img src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232676.png" alt="image-20211104100540521" style="zoom:67%;" />
<h3 id="浮点代码">浮点代码<a hidden class="anchor" aria-hidden="true" href="#浮点代码">#</a></h3>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232691.png" alt="image-20211105113304392"  />
</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232716.png" alt="image-20211105113325312"  />
</p>
<h4 id="浮点传送和转换操作">浮点传送和转换操作<a hidden class="anchor" aria-hidden="true" href="#浮点传送和转换操作">#</a></h4>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232897.png" alt="image-20211105113455334"  />
</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232915.png" alt="image-20211105113533219"  />
</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232941.png" alt="image-20211105113556497"  />
</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232458.png" alt="image-20211105113703428"  />
</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232482.png" alt="image-20211105113735601"  />
</p>
<p><strong>注：(v)cvttss2si ： Convert with Truncation Scalar Single-Precision Floating-Point Value to Integer</strong></p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232504.png" alt="image-20211105113808708"  />
</p>
<h4 id="浮点运算操作">浮点运算操作<a hidden class="anchor" aria-hidden="true" href="#浮点运算操作">#</a></h4>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232534.png" alt="image-20211105153036238"  />
</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232935.png" alt="image-20211105153427412"  />
</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232956.png" alt="image-20211105153449405"  />
</p>
<h4 id="在浮点代码中使用位级操作">在浮点代码中使用位级操作<a hidden class="anchor" aria-hidden="true" href="#在浮点代码中使用位级操作">#</a></h4>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232985.png" alt="image-20211105153519030"  />
</p>
<h4 id="浮点比较操作">浮点比较操作<a hidden class="anchor" aria-hidden="true" href="#浮点比较操作">#</a></h4>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232048.png" alt="image-20211105153741106"  />
</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232226.png" alt="image-20211105153754310"  />
</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232258.png" alt="image-20211105153809638"  />
</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232293.png" alt="image-20211105153820538"  />
</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012232750.png" alt="image-20211105153836589"  />
</p>


  </div>

  <footer class="post-footer">
    
<nav class="paginav">
  <a class="prev" href="https://chance7bin.github.io/posts/basic/os/%E4%B8%89%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">
    <span class="title">« 上一页</span>
    <br>
    <span>三、内存管理</span>
  </a>
  <a class="next" href="https://chance7bin.github.io/posts/basic/asm/%E7%AC%AC2%E7%AB%A0-%E5%AF%84%E5%AD%98%E5%99%A8/">
    <span class="title">下一页 »</span>
    <br>
    <span>第2章 寄存器</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://chance7bin.github.io/">Binb&#39;s Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
