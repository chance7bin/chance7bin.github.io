<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>实验6 信号量的实现和应用 | Binb&#39;s Blog</title>
<meta name="keywords" content="操作系统, 实验">
<meta name="description" content="1.实验目的 加深对进程同步与互斥概念的认识； 掌握信号量的使用，并应用它解决生产者——消费者问题； 掌握信号量的实现原理。 2.实验内容 本次实验的">
<meta name="author" content="chance7bin">
<link rel="canonical" href="https://chance7bin.github.io/posts/basic/os-lab/%E5%AE%9E%E9%AA%8C6-%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%92%8C%E5%BA%94%E7%94%A8/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.be81eec981a615a87a88f121642d7eebde74d033438693944db2fd6b827284ff.css" integrity="" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.acb54fd32bbc1982428b8850317e45d076b95012730a5936667e6bc21777692a.js" integrity=""
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://chance7bin.github.io/img/%E7%BE%8E%E9%98%9F.jpg">
<link rel="icon" type="image/png" sizes="16x16" href="https://chance7bin.github.io/img/%E7%BE%8E%E9%98%9F.jpg">
<link rel="icon" type="image/png" sizes="32x32" href="https://chance7bin.github.io/img/%E7%BE%8E%E9%98%9F.jpg">
<link rel="apple-touch-icon" href="https://chance7bin.github.io/img/%E7%BE%8E%E9%98%9F.jpg">
<link rel="mask-icon" href="https://chance7bin.github.io/img/%E7%BE%8E%E9%98%9F.jpg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="实验6 信号量的实现和应用" />
<meta property="og:description" content="1.实验目的 加深对进程同步与互斥概念的认识； 掌握信号量的使用，并应用它解决生产者——消费者问题； 掌握信号量的实现原理。 2.实验内容 本次实验的" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://chance7bin.github.io/posts/basic/os-lab/%E5%AE%9E%E9%AA%8C6-%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%92%8C%E5%BA%94%E7%94%A8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-22T00:00:00+00:00" />
<meta property="article:modified_time" content="2022-05-22T00:00:00+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="实验6 信号量的实现和应用"/>
<meta name="twitter:description" content="1.实验目的 加深对进程同步与互斥概念的认识； 掌握信号量的使用，并应用它解决生产者——消费者问题； 掌握信号量的实现原理。 2.实验内容 本次实验的"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "📚 文章",
      "item": "https://chance7bin.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "📕 计算机基础",
      "item": "https://chance7bin.github.io/posts/basic/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "hit-oslab",
      "item": "https://chance7bin.github.io/posts/basic/os-lab/"
    }, 
    {
      "@type": "ListItem",
      "position":  4 ,
      "name": "实验6 信号量的实现和应用",
      "item": "https://chance7bin.github.io/posts/basic/os-lab/%E5%AE%9E%E9%AA%8C6-%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%92%8C%E5%BA%94%E7%94%A8/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "实验6 信号量的实现和应用",
  "name": "实验6 信号量的实现和应用",
  "description": "1.实验目的 加深对进程同步与互斥概念的认识； 掌握信号量的使用，并应用它解决生产者——消费者问题； 掌握信号量的实现原理。 2.实验内容 本次实验的",
  "keywords": [
    "操作系统", "实验"
  ],
  "articleBody": "1.实验目的 加深对进程同步与互斥概念的认识； 掌握信号量的使用，并应用它解决生产者——消费者问题； 掌握信号量的实现原理。 2.实验内容 本次实验的基本内容是：\n在 Ubuntu 下编写程序，用信号量解决生产者——消费者问题； 在 0.11 中实现信号量，用生产者—消费者程序检验之。 3.1 用信号量解决生产者—消费者问题 在 Ubuntu 上编写应用程序“pc.c”，解决经典的生产者—消费者问题，完成下面的功能：\n建立一个生产者进程，N 个消费者进程（N\u003e1）； 用文件建立一个共享缓冲区； 生产者进程依次向缓冲区写入整数 0,1,2,…,M，M\u003e=500； 消费者进程从缓冲区读数，每次读一个，并将读出的数字从缓冲区删除，然后将本进程 ID 和 + 数字输出到标准输出； 缓冲区同时最多只能保存 10 个数。 一种可能的输出效果是：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 10: 0 10: 1 10: 2 10: 3 10: 4 11: 5 11: 6 12: 7 10: 8 12: 9 12: 10 12: 11 12: 12 …… 11: 498 11: 499 其中 ID 的顺序会有较大变化，但冒号后的数字一定是从 0 开始递增加一的。\npc.c 中将会用到 sem_open()、sem_close()、sem_wait() 和 sem_post() 等信号量相关的系统调用，请查阅相关文档。\n《UNIX 环境高级编程》是一本关于 Unix/Linux 系统级编程的相当经典的教程。如果你对 POSIX 编程感兴趣，建议买一本常备手边。\n哈尔滨工业大学校园网用户可以在 ftp://run.hit.edu.cn/study/Computer_Science/Linux_Unix/ 下载，后续实验也用得到。\n3.2 实现信号量 Linux 在 0.11 版还没有实现信号量，Linus 把这件富有挑战的工作留给了你。如果能实现一套山寨版的完全符合 POSIX 规范的信号量，无疑是很有成就感的。但时间暂时不允许我们这么做，所以先弄一套缩水版的类 POSIX 信号量，它的函数原型和标准并不完全相同，而且只包含如下系统调用：\n1 2 3 4 sem_t *sem_open(const char *name, unsigned int value); int sem_wait(sem_t *sem); int sem_post(sem_t *sem); int sem_unlink(const char *name); sem_open()的功能是创建一个信号量，或打开一个已经存在的信号量。\nsem_t 是信号量类型，根据实现的需要自定义。 name 是信号量的名字。不同的进程可以通过提供同样的 name 而共享同一个信号量。如果该信号量不存在，就创建新的名为 name 的信号量；如果存在，就打开已经存在的名为 name 的信号量。 value 是信号量的初值，仅当新建信号量时，此参数才有效，其余情况下它被忽略。当成功时，返回值是该信号量的唯一标识（比如，在内核的地址、ID 等），由另两个系统调用使用。如失败，返回值是 NULL。 sem_wait() 就是信号量的 P 原子操作。如果继续运行的条件不满足，则令调用进程等待在信号量 sem 上。返回 0 表示成功，返回 -1 表示失败。\nsem_post() 就是信号量的 V 原子操作。如果有等待 sem 的进程，它会唤醒其中的一个。返回 0 表示成功，返回 -1 表示失败。\nsem_unlink() 的功能是删除名为 name 的信号量。返回 0 表示成功，返回 -1 表示失败。\n在 kernel 目录下新建 sem.c 文件实现如上功能。然后将 pc.c 从 Ubuntu 移植到 0.11 下，测试自己实现的信号量。\n3.实验报告 完成实验后，在实验报告中回答如下问题：\n在 pc.c 中去掉所有与信号量有关的代码，再运行程序，执行效果有变化吗？为什么会这样？ 实验的设计者在第一次编写生产者——消费者程序的时候，是这么做的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 Producer() { // 生产一个产品 item; // 空闲缓存资源 P(Empty); // 互斥信号量 P(Mutex); // 将item放到空闲缓存中; V(Mutex); // 产品资源 V(Full); } Consumer() { P(Full); P(Mutex); //从缓存区取出一个赋值给item; V(Mutex); // 消费产品item; V(Empty); } 这样可行吗？如果可行，那么它和标准解法在执行效果上会有什么不同？如果不可行，那么它有什么问题使它不可行？\n4.实验提示 本实验需要完成两个任务：（1）在 Ubuntu 下编写程序，用信号量解决生产者——消费者问题；（2）在 linux-0.11 中实现信号量，用生产者—消费者程序检验之。\n4.1信号量 信号量，英文为 semaphore，最早由荷兰科学家、图灵奖获得者 E. W. Dijkstra 设计，任何操作系统教科书的“进程同步”部分都会有详细叙述。\nLinux 的信号量秉承 POSIX 规范，用man sem_overview可以查看相关信息。\n本次实验涉及到的信号量系统调用包括：sem_open()、sem_wait()、sem_post() 和 sem_unlink()。\n生产者—消费者问题\n生产者—消费者问题的解法几乎在所有操作系统教科书上都有，其基本结构为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 Producer() { // 生产一个产品 item; // 空闲缓存资源 P(Empty); // 互斥信号量 P(Mutex); // 将item放到空闲缓存中; V(Mutex); // 产品资源 V(Full); } Consumer() { P(Full); P(Mutex); //从缓存区取出一个赋值给item; V(Mutex); // 消费产品item; V(Empty); } 显然在演示这一过程时需要创建两类进程，一类执行函数 Producer()，另一类执行函数 Consumer()。\n4.2多进程共享文件 在 Linux 下使用 C 语言，可以通过三种方法进行文件的读写：\n使用标准 C 的 fopen()、fread()、fwrite()、fseek() 和 fclose() 等； 使用系统调用 open()、read()、write()、lseek() 和 close() 等； 通过内存镜像文件，使用 mmap() 系统调用。 在 Linux 0.11 上只能使用前两种方法。 fork() 调用成功后，子进程会继承父进程拥有的大多数资源，包括父进程打开的文件。所以子进程可以直接使用父进程创建的文件指针/描述符/句柄，访问的是与父进程相同的文件。\n使用标准 C 的文件操作函数要注意，它们使用的是进程空间内的文件缓冲区，父进程和子进程之间不共享这个缓冲区。因此，任何一个进程做完写操作后，必须 fflush() 一下，将数据强制更新到磁盘，其它进程才能读到所需数据。\n建议直接使用系统调用进行文件操作。\n4.3终端也是临界资源 用 printf() 向终端输出信息是很自然的事情，但当多个进程同时输出时，终端也成为了一个临界资源，需要做好互斥保护，否则输出的信息可能错乱。\n另外，printf() 之后，信息只是保存在输出缓冲区内，还没有真正送到终端上，这也可能造成输出信息时序不一致。用 fflush(stdout) 可以确保数据送到终端。\n4.4原子操作、睡眠和唤醒 Linux 0.11 是一个支持并发的现代操作系统，虽然它还没有面向应用实现任何锁或者信号量，但它内部一定使用了锁机制，即在多个进程访问共享的内核数据时一定需要通过锁来实现互斥和同步。\n锁必然是一种原子操作。通过模仿 0.11 的锁，就可以实现信号量。\n多个进程对磁盘的并发访问是一个需要锁的地方。Linux 0.11 访问磁盘的基本处理办法是在内存中划出一段磁盘缓存，用来加快对磁盘的访问。进程提出的磁盘访问请求首先要到磁盘缓存中去找，如果找到直接返回；如果没有找到则申请一段空闲的磁盘缓存，以这段磁盘缓存为参数发起磁盘读写请求。请求发出后，进程要睡眠等待（因为磁盘读写很慢，应该让出 CPU 让其他进程执行）。这种方法是许多操作系统（包括现代 Linux、UNIX 等）采用的较通用的方法。这里涉及到多个进程共同操作磁盘缓存，而进程在操作过程可能会被调度而失去 CPU。因此操作磁盘缓存时需要考虑互斥问题，所以其中必定用到了锁。而且也一定用到了让进程睡眠和唤醒。\n下面是从 kernel/blk_drv/ll_rw_blk.c 文件中取出的两个函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 static inline void lock_buffer(struct buffer_head * bh) { // 关中断 cli(); // 将当前进程睡眠在 bh-\u003eb_wait while (bh-\u003eb_lock) sleep_on(\u0026bh-\u003eb_wait); bh-\u003eb_lock=1; // 开中断 sti(); } static inline void unlock_buffer(struct buffer_head * bh) { if (!bh-\u003eb_lock) printk(\"ll_rw_block.c: buffer not locked\\n\\r\"); bh-\u003eb_lock = 0; // 唤醒睡眠在 bh-\u003eb_wait 上的进程 wake_up(\u0026bh-\u003eb_wait); } 分析 lock_buffer() 可以看出，访问锁变量时用开、关中断来实现原子操作，阻止进程切换的发生。当然这种方法有缺点，且不适合用于多处理器环境中，但对于 Linux 0.11，它是一种简单、直接而有效的机制。\n另外，上面的函数表明 Linux 0.11 提供了这样的接口：用 sleep_on() 实现进程的睡眠，用 wake_up() 实现进程的唤醒。它们的参数都是一个结构体指针—— struct task_struct *，即进程都睡眠或唤醒在该参数指向的一个进程 PCB 结构链表上。\n因此，我们可以用开关中断的方式实现原子操作，而调用 sleep_on() 和 wake_up() 进行进程的睡眠和唤醒。\nsleep_on() 的功能是将当前进程睡眠在参数指定的链表上（注意，这个链表是一个隐式链表，详见《注释》一书）。wake_up() 的功能是唤醒链表上睡眠的所有进程。这些进程都会被调度运行，所以它们被唤醒后，还要重新判断一下是否可以继续运行。可参考 lock_buffer() 中的那个 while 循环。\n4.5应对混乱的 bochs 虚拟屏幕 不知是 Linux 0.11 还是 bochs 的 bug，如果向终端输出的信息较多，bochs 的虚拟屏幕会产生混乱。此时按 ctrl+L 可以重新初始化一下屏幕，但输出信息一多，还是会混乱。建议把输出信息重定向到一个文件，然后用 vi、more 等工具按屏查看这个文件，可以基本解决此问题。\n4.6关于 string.h 的提示 下面描述的问题未必具有普遍意义，仅做为提醒，请实验者注意。\ninclude/string.h 实现了全套的 C 语言字符串操作，而且都是采用汇编 + inline 方式优化。\n但在使用中，某些情况下可能会遇到一些奇怪的问题。比如某人就遇到 strcmp() 会破坏参数内容的问题。如果调试中遇到有些 “诡异” 的情况，可以试试不包含头文件，一般都能解决。不包含 string.h，就不会用 inline 方式调用这些函数，它们工作起来就趋于正常了。\n5.实验步骤 实验内容 本次实验的基本内容是在Linux 0.11的内核中实现信号量，并向用户提供使用信号量的接口，用户使用该接口解决一个实际的进程同步问题。实验的主要内容包括如下两个部分：\n1.实现信号量 在Linux 0.11内核上（Linux 0.11内核中没有定义信号量）实现信号量，并创建相应的系统调用以供用户使用。应提供的系统接口主要包括：\n1 int CreateSemaphore(char * semname); 该操作用来在内核中创建一个信号量，输入的参数是信号量的名字，返回的是信号量的一个整数标识semid，信号量是一种内核资源，不应该无限制的创建，所以在内核中信号量可以被组织成一个数组，此时semid就是创建的信号量在内核信号量数组中的下标。如果这个名为semname的信号量已经创建，则返回这个已创建的信号量的标识semid，也即多个具有相同名字的信号量创建接口返回相同的返回值，即相同的semid\n1 int SetSemaphore(int semid, int value); 用来设置信号量的值，其中semid是信号量标识，value是要设置的信号量值，该函数的返回值是信号量的当前值。该接口通常用来设置信号量的初值。\n1 int WaitSemaphore(int semid); 该函数就是信号量的P操作，其功能就是对信号量的值减1，如果其值小于0则令调用进程等待在信号量semid上。\n1 int SignalSemaphore(int semid); 该函数就是信号量的V操作，其功能就是对信号量的值加1，如果其值小于等于0则令唤醒等待在信号量semid上的进程。\n2.使用信号量 在定义了信号量的Linux 0.11操作系统上编写用户程序来演示信号量的作用。该用户程序解决就是传统的生产者—消费者问题，要求编写的用户程序完成下面的任务： 1.编写的主程序演示生产者—消费者两个进程的同步过程； 2.编写的主程序创建两个进程：生产者进程和消费者进程； 3.编写生产者进程和消费者进程的代码。 4.要求对比三种设置下的运行结果：\n没有信号量下的生产者—消费者。 有信号量，1个生产者进程，1个消费者进程，用for循环控制生产者（消费者）各执行N次。 有信号量，N个生产者进程，N个消费者进程。 步骤 一、实现信号量 1.新建sem.h 在linux-0.11/include/linux目录下新建sem.h，定义信号量的数据结构。sem.h的代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #ifndef _SEM_H #define _SEM_H #include #define SEMTABLE_LEN 20 #define SEM_NAME_LEN 20 typedef struct semaphore{ char name[SEM_NAME_LEN]; int value; struct task_struct *queue; } sem_t; extern sem_t semtable[SEMTABLE_LEN]; #endif 代码截图如下：\n2.新建sem.c 在linux-0.11/kernel目录下，新建实现信号量函数的源代码文件sem.c。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 #include #include #include #include #include #include #include #include #include //#include sem_t semtable[SEMTABLE_LEN]; int cnt = 0; sem_t *sys_sem_open(const char *name,unsigned int value) { char kernelname[100]; int isExist = 0; int i=0; int name_cnt=0; while( get_fs_byte(name+name_cnt) != '\\0') name_cnt++; if(name_cnt\u003eSEM_NAME_LEN) return NULL; for(i=0;i\u003cname_cnt;i++) kernelname[i]=get_fs_byte(name+i); int name_len = strlen(kernelname); int sem_name_len =0; sem_t *p=NULL; for(i=0;i\u003ccnt;i++) { sem_name_len = strlen(semtable[i].name); if(sem_name_len == name_len) { if( !strcmp(kernelname,semtable[i].name) ) { isExist = 1; break; } } } if(isExist == 1) { p=(sem_t*)(\u0026semtable[i]); //printk(\"find previous name!\\n\"); } else { i=0; for(i=0;i\u003cname_len;i++) { semtable[cnt].name[i]=kernelname[i]; } semtable[cnt].value = value; p=(sem_t*)(\u0026semtable[cnt]); //printk(\"creat name!\\n\"); cnt++; } return p; } int sys_sem_wait(sem_t *sem) { cli(); while( sem-\u003evalue \u003c= 0 ) // sleep_on(\u0026(sem-\u003equeue)); //这两条语句顺序不能颠倒，很重要，是关于互斥信号量能不能正确工作的！！！ sem-\u003evalue--; sti(); return 0; } int sys_sem_post(sem_t *sem) { cli(); sem-\u003evalue++; if( (sem-\u003evalue) \u003c= 1) wake_up(\u0026(sem-\u003equeue)); sti(); return 0; } int sys_sem_unlink(const char *name) { char kernelname[100]; /* 应该足够大了 */ int isExist = 0; int i=0; int name_cnt=0; while( get_fs_byte(name+name_cnt) != '\\0') name_cnt++; if(name_cnt\u003eSEM_NAME_LEN) return NULL; for(i=0;i\u003cname_cnt;i++) kernelname[i]=get_fs_byte(name+i); int name_len = strlen(name); int sem_name_len =0; for(i=0;i\u003ccnt;i++) { sem_name_len = strlen(semtable[i].name); if(sem_name_len == name_len) { if( !strcmp(kernelname,semtable[i].name)) { isExist = 1; break; } } } if(isExist == 1) { int tmp=0; for(tmp=i;tmp\u003c=cnt;tmp++) { semtable[tmp]=semtable[tmp+1]; } cnt = cnt-1; return 0; } else return -1; } 3.修改unistd.h 在unistd.h内增加新的系统调用编号(之前的实验中也有做系统调用，所以这里直接记录一下修改的结果，过程就大概省略了一些)\n1 2 3 4 #define __NR_sem_open 72 #define __NR_sem_wait 73 #define __NR_sem_post 74 #define __NR_sem_unlink 75 4.修改system_call.s 在system_call.s文件中找到nr_system_calls并将其值更改为76（因为增加了四个sem系统调用函数）\n1 nr_system_calls = 76 5.修改sys.h 增加四个函数，函数如下： 1 2 3 4 extern int sys_sem_open(); extern int sys_sem_wait(); extern int sys_sem_post(); extern int sys_sem_unlink(); 将函数名放在数组内： 1 sys_sem_open,sys_sem_wait,sys_sem_post,sys_sem_unlink 代码截图如下:\n6.修改Makefile 将kernel下的Makefile修改为如下代码块（部分）：\n1 2 3 4 5 6 7 8 9 10 11 ...... OBJS = sched.o system_call.o traps.o asm.o fork.o \\ panic.o printk.o vsprintf.o sys.o exit.o \\ signal.o mktime.o sem.o ...... ### ###Dependencies: sem.s sem.o: sem.c ../include/linux/sem.h ../include/linux/kernel.h \\ ../include/unistd.h ...... Makefile截图如下:\n7.挂载hdc并准备相关文件 进入oslab根目录执行sudo ./mount-hdc，随后将unistd.h复制到usr/include下，将sem.h复制到usr/include/linux下，最后使用sudo umount hdc卸载hdc\n二、编写生产者-消费者检验程序 1.新建pc.c文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 #define __LIBRARY__ #include #include #include #include #include #include #include _syscall2(sem_t *,sem_open,const char *,name,unsigned int,value) _syscall1(int,sem_wait,sem_t *,sem) _syscall1(int,sem_post,sem_t *,sem) _syscall1(int,sem_unlink,const char *,name) const char *FILENAME = \"/usr/root/buffer_file\"; /* 消费生产的产品存放的缓冲文件的路径 */ const int NR_CONSUMERS = 5; /* 消费者的数量 */ const int NR_ITEMS = 50; /* 产品的最大量 */ const int BUFFER_SIZE = 10; /* 缓冲区大小，表示可同时存在的产品数量 */ sem_t *metux, *full, *empty; /* 3个信号量 */ unsigned int item_pro, item_used; /* 刚生产的产品号；刚消费的产品号 */ int fi, fo; /* 供生产者写入或消费者读取的缓冲文件的句柄 */ int main(int argc, char *argv[]) { char *filename; int pid; int i; filename = argc \u003e 1 ? argv[1] : FILENAME; /* O_TRUNC 表示：当文件以只读或只写打开时，若文件存在，则将其长度截为0（即清空文件） * 0222 和 0444 分别表示文件只写和只读（前面的0是八进制标识） */ fi = open(filename, O_CREAT| O_TRUNC| O_WRONLY, 0222); /* 以只写方式打开文件给生产者写入产品编号 */ fo = open(filename, O_TRUNC| O_RDONLY, 0444); /* 以只读方式打开文件给消费者读出产品编号 */ metux = sem_open(\"METUX\", 1); /* 互斥信号量，防止生产消费同时进行 */ full = sem_open(\"FULL\", 0); /* 产品剩余信号量，大于0则可消费 */ empty = sem_open(\"EMPTY\", BUFFER_SIZE); /* 空信号量，它与产品剩余信号量此消彼长，大于0时生产者才能继续生产 */ item_pro = 0; if ((pid = fork())) /* 父进程用来执行消费者动作 */ { printf(\"pid %d:\\tproducer created....\\n\", pid); /* printf()输出的信息会先保存到输出缓冲区，并没有马上输出到标准输出（通常为终端控制台）。 * 为避免偶然因素的影响，我们每次printf()都调用一下stdio.h中的fflush(stdout) * 来确保将输出立刻输出到标准输出。 */ fflush(stdout); while (item_pro \u003c= NR_ITEMS) /* 生产完所需产品 */ { sem_wait(empty); sem_wait(metux); /* 生产完一轮产品（文件缓冲区只能容纳BUFFER_SIZE个产品编号）后 * 将缓冲文件的位置指针重新定位到文件首部。 */ if(!(item_pro % BUFFER_SIZE)) lseek(fi, 0, 0); write(fi, (char *) \u0026item_pro, sizeof(item_pro)); /* 写入产品编号 */ printf(\"pid %d:\\tproduces item %d\\n\", pid, item_pro); fflush(stdout); item_pro++; sem_post(metux); sem_post(full); /* 唤醒消费者进程 */ } } else /* 子进程来创建消费者 */ { i = NR_CONSUMERS; while(i--) { if(!(pid=fork())) /* 创建i个消费者进程 */ { pid = getpid(); printf(\"pid %d:\\tconsumer %d created....\\n\", pid, NR_CONSUMERS-i); fflush(stdout); while(1) { sem_wait(full); sem_wait(metux); /* read()读到文件末尾时返回0，将文件的位置指针重新定位到文件首部 */ if(!read(fo, (char *)\u0026item_used, sizeof(item_used))) { lseek(fo, 0, 0); read(fo, (char *)\u0026item_used, sizeof(item_used)); } printf(\"pid %d:\\tconsumer %d consumes item %d\\n\", pid, NR_CONSUMERS-i+1, item_used); fflush(stdout); sem_post(metux); sem_post(empty); /* 唤醒生产者进程 */ if(item_used == NR_ITEMS) /* 如果已经消费完最后一个商品，则结束 */ goto OK; } } } } OK: close(fi); close(fo); return 0; } 将此文件移动到usr/root目录下，此目录需要挂载hdc才可以访问。移动成功之后直接重新编译linux并在虚拟环境内运行。\n2.编译运行pc.c 运行linux-0.11之后，首先编译pc.c，使用命令gcc -o pc pc.c，随后运行pc，使用命令**./pc \u003e sem_output**即可，最终在虚拟环境内输入sync把修改的数据写入磁盘。\n遇到的问题(还没解决) 上面报了一个类型转换的异常，定义和调用sem_open的地方如下，但是没有发现哪个地方写错了\n3.查看sem_output 首先挂载hdc，然后进入usr/root目录并在终端内执行sudo less sem_output命令，可看到下图结果：\n4.对比有无信号量 删除pc.c文件中关于信号量的代码，重新编译运行后得出如下结果\n回答问题 在有无信号量的不同条件下对比运行结果后可以发现，如果去掉所有与信号量有关的代码，编译运行程序之后可以发现输出的数字顺序完全混乱。 信号量不存在的情况下，进程之间无法同步或者协作，造成此种情况的有如下原因：\n一种情况是缓冲区满了，生产者还在写入数据，会造覆盖掉部分数据。 一种是缓冲区为空，消费者尝试读取数据，读到的数据是已输出的数据。 多个进程对文件缓冲区同时访问，造成了程序崩溃。 ",
  "wordCount" : "6745",
  "inLanguage": "zh",
  "datePublished": "2022-05-22T00:00:00Z",
  "dateModified": "2022-05-22T00:00:00Z",
  "author":[{
    "@type": "Person",
    "name": "chance7bin"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://chance7bin.github.io/posts/basic/os-lab/%E5%AE%9E%E9%AA%8C6-%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%92%8C%E5%BA%94%E7%94%A8/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Binb's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://chance7bin.github.io/img/%E7%BE%8E%E9%98%9F.jpg"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://chance7bin.github.io/" accesskey="h" title="Binb&#39;s Blog (Alt + H)">
                <img src="https://chance7bin.github.io/img/%E7%BE%8E%E9%98%9F.jpg" alt="" aria-label="logo"
                    height="35">Binb&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://chance7bin.github.io/search" title="🔍搜索 (Alt &#43; /)" accesskey=/>
                    <span>🔍搜索</span>
                </a>
            </li>
            <li>
                <a href="https://chance7bin.github.io/" title="🏠 主页">
                    <span>🏠 主页</span>
                </a>
            </li>
            <li>
                <a href="https://chance7bin.github.io/archives/" title="⏱️ 时间轴">
                    <span>⏱️ 时间轴</span>
                </a>
            </li>
            <li>
                <a href="https://chance7bin.github.io/posts" title="📚 文章">
                    <span>📚 文章</span>
                </a>
            </li>
            <li>
                <a href="https://chance7bin.github.io/tags" title="🔖 标签">
                    <span>🔖 标签</span>
                </a>
            </li>
            <li>
                <a href="https://github.com/chance7bin" title="GitHub">
                    <span>GitHub</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://chance7bin.github.io/">🏠 主页</a>&nbsp;»&nbsp;<a href="https://chance7bin.github.io/posts/">📚 文章</a>&nbsp;»&nbsp;<a href="https://chance7bin.github.io/posts/basic/">📕 计算机基础</a>&nbsp;»&nbsp;<a href="https://chance7bin.github.io/posts/basic/os-lab/">hit-oslab</a></div>
    <h1 class="post-title">
      实验6 信号量的实现和应用
    </h1>
    <div class="post-meta">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css">


<style>
    i[id*="post_meta_style"] {
        display: flex;
        align-items: center;
        margin: 0 0 10px 0;
    }

    .parent-post-meta {
        display: flex;
        flex-wrap: wrap;
        opacity: 0.8;
    }
</style>

<span class="parent-post-meta">
    <span id="post_meta_style_1">
        <span class="fa fa-calendar-check-o"></span>
        <span>2022-05-22
            &nbsp;&nbsp;
        </span>
    </span>
    
    
    
    
    
    
    
    <span id="post_meta_style_3">
        <span class="fa fa-file-word-o"></span>
        <span>6745字
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_4">
        <span class="fa fa-clock-o"></span>
        <span>14分钟
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_5">
        <span class="fa fa-user-o"></span>
        <span>chance7bin
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_6">
        <span class="fa fa-tags" style="opacity: 0.8"></span>
        <span>
            <span class="post-tags-meta">
                <a href="https://chance7bin.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="color: var(--secondary)!important;">操作系统</a>
                &nbsp;<a href="https://chance7bin.github.io/tags/%E5%AE%9E%E9%AA%8C/" style="color: var(--secondary)!important;">实验</a>
            </span>
        </span>
    </span>

    
</span>


      
      
      
      
      
      
      
          
          
          
              
              
              
              
          
      
    </div>
  </header>
   <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">目录</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#1%e5%ae%9e%e9%aa%8c%e7%9b%ae%e7%9a%84" aria-label="1.实验目的">1.实验目的</a></li>
                    <li>
                        <a href="#2%e5%ae%9e%e9%aa%8c%e5%86%85%e5%ae%b9" aria-label="2.实验内容">2.实验内容</a><ul>
                            
                    <li>
                        <a href="#31-%e7%94%a8%e4%bf%a1%e5%8f%b7%e9%87%8f%e8%a7%a3%e5%86%b3%e7%94%9f%e4%ba%a7%e8%80%85%e6%b6%88%e8%b4%b9%e8%80%85%e9%97%ae%e9%a2%98" aria-label="3.1 用信号量解决生产者—消费者问题">3.1 用信号量解决生产者—消费者问题</a></li>
                    <li>
                        <a href="#32-%e5%ae%9e%e7%8e%b0%e4%bf%a1%e5%8f%b7%e9%87%8f" aria-label="3.2 实现信号量">3.2 实现信号量</a></li></ul>
                    </li>
                    <li>
                        <a href="#3%e5%ae%9e%e9%aa%8c%e6%8a%a5%e5%91%8a" aria-label="3.实验报告">3.实验报告</a></li>
                    <li>
                        <a href="#4%e5%ae%9e%e9%aa%8c%e6%8f%90%e7%a4%ba" aria-label="4.实验提示">4.实验提示</a><ul>
                            
                    <li>
                        <a href="#41%e4%bf%a1%e5%8f%b7%e9%87%8f" aria-label="4.1信号量">4.1信号量</a></li>
                    <li>
                        <a href="#42%e5%a4%9a%e8%bf%9b%e7%a8%8b%e5%85%b1%e4%ba%ab%e6%96%87%e4%bb%b6" aria-label="4.2多进程共享文件">4.2多进程共享文件</a></li>
                    <li>
                        <a href="#43%e7%bb%88%e7%ab%af%e4%b9%9f%e6%98%af%e4%b8%b4%e7%95%8c%e8%b5%84%e6%ba%90" aria-label="4.3终端也是临界资源">4.3终端也是临界资源</a></li>
                    <li>
                        <a href="#44%e5%8e%9f%e5%ad%90%e6%93%8d%e4%bd%9c%e7%9d%a1%e7%9c%a0%e5%92%8c%e5%94%a4%e9%86%92" aria-label="4.4原子操作、睡眠和唤醒">4.4原子操作、睡眠和唤醒</a></li>
                    <li>
                        <a href="#45%e5%ba%94%e5%af%b9%e6%b7%b7%e4%b9%b1%e7%9a%84-bochs-%e8%99%9a%e6%8b%9f%e5%b1%8f%e5%b9%95" aria-label="4.5应对混乱的 bochs 虚拟屏幕">4.5应对混乱的 bochs 虚拟屏幕</a></li>
                    <li>
                        <a href="#46%e5%85%b3%e4%ba%8e-stringh-%e7%9a%84%e6%8f%90%e7%a4%ba" aria-label="4.6关于 string.h 的提示">4.6关于 string.h 的提示</a></li></ul>
                    </li>
                    <li>
                        <a href="#5%e5%ae%9e%e9%aa%8c%e6%ad%a5%e9%aa%a4" aria-label="5.实验步骤">5.实验步骤</a><ul>
                            
                    <li>
                        <a href="#%e5%ae%9e%e9%aa%8c%e5%86%85%e5%ae%b9" aria-label="实验内容">实验内容</a><ul>
                            
                    <li>
                        <a href="#1%e5%ae%9e%e7%8e%b0%e4%bf%a1%e5%8f%b7%e9%87%8f" aria-label="1.实现信号量">1.实现信号量</a></li>
                    <li>
                        <a href="#2%e4%bd%bf%e7%94%a8%e4%bf%a1%e5%8f%b7%e9%87%8f" aria-label="2.使用信号量">2.使用信号量</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e6%ad%a5%e9%aa%a4" aria-label="步骤">步骤</a><ul>
                            
                    <li>
                        <a href="#%e4%b8%80%e5%ae%9e%e7%8e%b0%e4%bf%a1%e5%8f%b7%e9%87%8f" aria-label="一、实现信号量">一、实现信号量</a></li>
                    <li>
                        <a href="#1%e6%96%b0%e5%bb%basemh" aria-label="1.新建sem.h">1.新建sem.h</a></li>
                    <li>
                        <a href="#2%e6%96%b0%e5%bb%basemc" aria-label="2.新建sem.c">2.新建sem.c</a></li>
                    <li>
                        <a href="#3%e4%bf%ae%e6%94%b9unistdh" aria-label="3.修改unistd.h">3.修改unistd.h</a></li>
                    <li>
                        <a href="#4%e4%bf%ae%e6%94%b9system_calls" aria-label="4.修改system_call.s">4.修改system_call.s</a></li>
                    <li>
                        <a href="#5%e4%bf%ae%e6%94%b9sysh" aria-label="5.修改sys.h">5.修改sys.h</a></li>
                    <li>
                        <a href="#6%e4%bf%ae%e6%94%b9makefile" aria-label="6.修改Makefile">6.修改Makefile</a></li>
                    <li>
                        <a href="#7%e6%8c%82%e8%bd%bdhdc%e5%b9%b6%e5%87%86%e5%a4%87%e7%9b%b8%e5%85%b3%e6%96%87%e4%bb%b6" aria-label="7.挂载hdc并准备相关文件">7.挂载hdc并准备相关文件</a></li>
                    <li>
                        <a href="#%e4%ba%8c%e7%bc%96%e5%86%99%e7%94%9f%e4%ba%a7%e8%80%85-%e6%b6%88%e8%b4%b9%e8%80%85%e6%a3%80%e9%aa%8c%e7%a8%8b%e5%ba%8f" aria-label="二、编写生产者-消费者检验程序">二、编写生产者-消费者检验程序</a></li>
                    <li>
                        <a href="#1%e6%96%b0%e5%bb%bapcc%e6%96%87%e4%bb%b6" aria-label="1.新建pc.c文件">1.新建pc.c文件</a></li>
                    <li>
                        <a href="#2%e7%bc%96%e8%af%91%e8%bf%90%e8%a1%8cpcc" aria-label="2.编译运行pc.c">2.编译运行pc.c</a></li>
                    <li>
                        <a href="#%e9%81%87%e5%88%b0%e7%9a%84%e9%97%ae%e9%a2%98%e8%bf%98%e6%b2%a1%e8%a7%a3%e5%86%b3" aria-label="遇到的问题(还没解决)"><code>遇到的问题(还没解决)</code></a></li>
                    <li>
                        <a href="#3%e6%9f%a5%e7%9c%8bsem_output" aria-label="3.查看sem_output">3.查看sem_output</a></li>
                    <li>
                        <a href="#4%e5%af%b9%e6%af%94%e6%9c%89%e6%97%a0%e4%bf%a1%e5%8f%b7%e9%87%8f" aria-label="4.对比有无信号量">4.对比有无信号量</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e5%9b%9e%e7%ad%94%e9%97%ae%e9%a2%98" aria-label="回答问题">回答问题</a>
                    </li>
                </ul>
                </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>
  <div class="post-content"><h2 id="1实验目的">1.实验目的<a hidden class="anchor" aria-hidden="true" href="#1实验目的">#</a></h2>
<ul>
<li>加深对进程同步与互斥概念的认识；</li>
<li>掌握信号量的使用，并应用它解决生产者——消费者问题；</li>
<li>掌握信号量的实现原理。</li>
</ul>
<h2 id="2实验内容">2.实验内容<a hidden class="anchor" aria-hidden="true" href="#2实验内容">#</a></h2>
<p>本次实验的基本内容是：</p>
<ul>
<li>在 Ubuntu 下编写程序，用信号量解决生产者——消费者问题；</li>
<li>在 0.11 中实现信号量，用生产者—消费者程序检验之。</li>
</ul>
<h3 id="31-用信号量解决生产者消费者问题">3.1 用信号量解决生产者—消费者问题<a hidden class="anchor" aria-hidden="true" href="#31-用信号量解决生产者消费者问题">#</a></h3>
<p>在 Ubuntu 上编写应用程序“pc.c”，解决经典的生产者—消费者问题，完成下面的功能：</p>
<ul>
<li>建立一个生产者进程，N 个消费者进程（N&gt;1）；</li>
<li>用文件建立一个共享缓冲区；</li>
<li>生产者进程依次向缓冲区写入整数 0,1,2,&hellip;,M，M&gt;=500；</li>
<li>消费者进程从缓冲区读数，每次读一个，并将读出的数字从缓冲区删除，然后将本进程 ID 和 + 数字输出到标准输出；</li>
<li>缓冲区同时最多只能保存 10 个数。</li>
</ul>
<p>一种可能的输出效果是：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">10: 0
</span></span><span class="line"><span class="cl">10: 1
</span></span><span class="line"><span class="cl">10: 2
</span></span><span class="line"><span class="cl">10: 3
</span></span><span class="line"><span class="cl">10: 4
</span></span><span class="line"><span class="cl">11: 5
</span></span><span class="line"><span class="cl">11: 6
</span></span><span class="line"><span class="cl">12: 7
</span></span><span class="line"><span class="cl">10: 8
</span></span><span class="line"><span class="cl">12: 9
</span></span><span class="line"><span class="cl">12: 10
</span></span><span class="line"><span class="cl">12: 11
</span></span><span class="line"><span class="cl">12: 12
</span></span><span class="line"><span class="cl">……
</span></span><span class="line"><span class="cl">11: 498
</span></span><span class="line"><span class="cl">11: 499
</span></span></code></pre></td></tr></table>
</div>
</div><p>其中 ID 的顺序会有较大变化，但冒号后的数字一定是从 0 开始递增加一的。</p>
<p><code>pc.c</code> 中将会用到 <code>sem_open()</code>、<code>sem_close()</code>、<code>sem_wait()</code> 和 <code>sem_post()</code> 等信号量相关的系统调用，请查阅相关文档。</p>
<p>《UNIX 环境高级编程》是一本关于 Unix/Linux 系统级编程的相当经典的教程。如果你对 POSIX 编程感兴趣，建议买一本常备手边。</p>
<blockquote>
<p>哈尔滨工业大学校园网用户可以在 <a href="ftp://run.hit.edu.cn/study/Computer_Science/Linux_Unix/">ftp://run.hit.edu.cn/study/Computer_Science/Linux_Unix/</a> 下载，后续实验也用得到。</p>
</blockquote>
<h3 id="32-实现信号量">3.2 实现信号量<a hidden class="anchor" aria-hidden="true" href="#32-实现信号量">#</a></h3>
<p>Linux 在 0.11 版还没有实现信号量，Linus 把这件富有挑战的工作留给了你。如果能实现一套山寨版的完全符合 POSIX 规范的信号量，无疑是很有成就感的。但时间暂时不允许我们这么做，所以先弄一套缩水版的类 POSIX 信号量，它的函数原型和标准并不完全相同，而且只包含如下系统调用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">sem_t</span> <span class="o">*</span><span class="nf">sem_open</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">sem_wait</span><span class="p">(</span><span class="kt">sem_t</span> <span class="o">*</span><span class="n">sem</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">sem_post</span><span class="p">(</span><span class="kt">sem_t</span> <span class="o">*</span><span class="n">sem</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">sem_unlink</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p><code>sem_open()</code>的功能是创建一个信号量，或打开一个已经存在的信号量。</p>
<ul>
<li><code>sem_t</code> 是信号量类型，根据实现的需要自定义。</li>
<li><code>name</code> 是信号量的名字。不同的进程可以通过提供同样的 name 而共享同一个信号量。如果该信号量不存在，就创建新的名为 name 的信号量；如果存在，就打开已经存在的名为 name 的信号量。</li>
<li><code>value</code> 是信号量的初值，仅当新建信号量时，此参数才有效，其余情况下它被忽略。当成功时，返回值是该信号量的唯一标识（比如，在内核的地址、ID 等），由另两个系统调用使用。如失败，返回值是 NULL。</li>
</ul>
</li>
<li>
<p><code>sem_wait()</code> 就是信号量的 P 原子操作。如果继续运行的条件不满足，则令调用进程等待在信号量 sem 上。返回 0 表示成功，返回 -1 表示失败。</p>
</li>
<li>
<p><code>sem_post()</code> 就是信号量的 V 原子操作。如果有等待 sem 的进程，它会唤醒其中的一个。返回 0 表示成功，返回 -1 表示失败。</p>
</li>
<li>
<p><code>sem_unlink()</code> 的功能是删除名为 name 的信号量。返回 0 表示成功，返回 -1 表示失败。</p>
</li>
</ul>
<p>在 <code>kernel</code> 目录下新建 <code>sem.c</code> 文件实现如上功能。然后将 pc.c 从 Ubuntu 移植到 0.11 下，测试自己实现的信号量。</p>
<h2 id="3实验报告">3.实验报告<a hidden class="anchor" aria-hidden="true" href="#3实验报告">#</a></h2>
<p>完成实验后，在实验报告中回答如下问题：</p>
<p>在 <code>pc.c</code> 中去掉所有与信号量有关的代码，再运行程序，执行效果有变化吗？为什么会这样？ 实验的设计者在第一次编写生产者——消费者程序的时候，是这么做的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="nf">Producer</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 生产一个产品 item;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 空闲缓存资源
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">P</span><span class="p">(</span><span class="n">Empty</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 互斥信号量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">P</span><span class="p">(</span><span class="n">Mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 将item放到空闲缓存中;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">V</span><span class="p">(</span><span class="n">Mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 产品资源
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">V</span><span class="p">(</span><span class="n">Full</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">Consumer</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">P</span><span class="p">(</span><span class="n">Full</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">P</span><span class="p">(</span><span class="n">Mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">//从缓存区取出一个赋值给item;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">V</span><span class="p">(</span><span class="n">Mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 消费产品item;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">V</span><span class="p">(</span><span class="n">Empty</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这样可行吗？如果可行，那么它和标准解法在执行效果上会有什么不同？如果不可行，那么它有什么问题使它不可行？</p>
<h2 id="4实验提示">4.实验提示<a hidden class="anchor" aria-hidden="true" href="#4实验提示">#</a></h2>
<p>本实验需要完成两个任务：（1）在 Ubuntu 下编写程序，用信号量解决生产者——消费者问题；（2）在 linux-0.11 中实现信号量，用生产者—消费者程序检验之。</p>
<h3 id="41信号量">4.1信号量<a hidden class="anchor" aria-hidden="true" href="#41信号量">#</a></h3>
<p>信号量，英文为 semaphore，最早由荷兰科学家、图灵奖获得者 E. W. Dijkstra 设计，任何操作系统教科书的“进程同步”部分都会有详细叙述。</p>
<p>Linux 的信号量秉承 POSIX 规范，用<code>man sem_overview</code>可以查看相关信息。</p>
<p>本次实验涉及到的信号量系统调用包括：<code>sem_open()</code>、<code>sem_wait()</code>、<code>sem_post()</code> 和 <code>sem_unlink()</code>。</p>
<p>生产者—消费者问题</p>
<p>生产者—消费者问题的解法几乎在所有操作系统教科书上都有，其基本结构为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="nf">Producer</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 生产一个产品 item;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 空闲缓存资源
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">P</span><span class="p">(</span><span class="n">Empty</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 互斥信号量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">P</span><span class="p">(</span><span class="n">Mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 将item放到空闲缓存中;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">V</span><span class="p">(</span><span class="n">Mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 产品资源
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">V</span><span class="p">(</span><span class="n">Full</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">Consumer</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">P</span><span class="p">(</span><span class="n">Full</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">P</span><span class="p">(</span><span class="n">Mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">//从缓存区取出一个赋值给item;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">V</span><span class="p">(</span><span class="n">Mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 消费产品item;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">V</span><span class="p">(</span><span class="n">Empty</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>显然在演示这一过程时需要创建两类进程，一类执行函数 <code>Producer()</code>，另一类执行函数 <code>Consumer()</code>。</p>
<h3 id="42多进程共享文件">4.2多进程共享文件<a hidden class="anchor" aria-hidden="true" href="#42多进程共享文件">#</a></h3>
<p>在 Linux 下使用 C 语言，可以通过三种方法进行文件的读写：</p>
<ul>
<li>使用标准 C 的 <code>fopen()</code>、<code>fread()</code>、<code>fwrite()</code>、<code>fseek()</code> 和 <code>fclose()</code> 等；</li>
<li>使用系统调用 <code>open()</code>、<code>read()</code>、<code>write()</code>、<code>lseek()</code> 和 <code>close()</code> 等；</li>
<li>通过内存镜像文件，使用 <code>mmap()</code> 系统调用。</li>
<li>在 Linux 0.11 上只能使用前两种方法。</li>
</ul>
<p><code>fork()</code> 调用成功后，子进程会继承父进程拥有的大多数资源，包括父进程打开的文件。所以子进程可以直接使用父进程创建的文件指针/描述符/句柄，访问的是与父进程相同的文件。</p>
<p>使用标准 C 的文件操作函数要注意，它们使用的是进程空间内的文件缓冲区，父进程和子进程之间不共享这个缓冲区。因此，任何一个进程做完写操作后，必须 <code>fflush()</code> 一下，将数据强制更新到磁盘，其它进程才能读到所需数据。</p>
<p>建议直接使用系统调用进行文件操作。</p>
<h3 id="43终端也是临界资源">4.3终端也是临界资源<a hidden class="anchor" aria-hidden="true" href="#43终端也是临界资源">#</a></h3>
<p>用 printf() 向终端输出信息是很自然的事情，但当多个进程同时输出时，终端也成为了一个临界资源，需要做好互斥保护，否则输出的信息可能错乱。</p>
<p>另外，printf() 之后，信息只是保存在输出缓冲区内，还没有真正送到终端上，这也可能造成输出信息时序不一致。用 <code>fflush(stdout)</code> 可以确保数据送到终端。</p>
<h3 id="44原子操作睡眠和唤醒">4.4原子操作、睡眠和唤醒<a hidden class="anchor" aria-hidden="true" href="#44原子操作睡眠和唤醒">#</a></h3>
<p>Linux 0.11 是一个支持并发的现代操作系统，虽然它还没有面向应用实现任何锁或者信号量，但它内部一定使用了锁机制，即在多个进程访问共享的内核数据时一定需要通过锁来实现互斥和同步。</p>
<p>锁必然是一种原子操作。通过模仿 0.11 的锁，就可以实现信号量。</p>
<p>多个进程对磁盘的并发访问是一个需要锁的地方。Linux 0.11 访问磁盘的基本处理办法是在内存中划出一段磁盘缓存，用来加快对磁盘的访问。进程提出的磁盘访问请求首先要到磁盘缓存中去找，如果找到直接返回；如果没有找到则申请一段空闲的磁盘缓存，以这段磁盘缓存为参数发起磁盘读写请求。请求发出后，进程要睡眠等待（因为磁盘读写很慢，应该让出 CPU 让其他进程执行）。这种方法是许多操作系统（包括现代 Linux、UNIX 等）采用的较通用的方法。这里涉及到多个进程共同操作磁盘缓存，而进程在操作过程可能会被调度而失去 CPU。因此操作磁盘缓存时需要考虑互斥问题，所以其中必定用到了锁。而且也一定用到了让进程睡眠和唤醒。</p>
<p>下面是从 <code>kernel/blk_drv/ll_rw_blk.c</code> 文件中取出的两个函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">lock_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span> <span class="n">bh</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 关中断
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">cli</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 将当前进程睡眠在 bh-&gt;b_wait
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">while</span> <span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">sleep_on</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_wait</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_lock</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 开中断
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">sti</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">unlock_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span> <span class="n">bh</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printk</span><span class="p">(</span><span class="s">&#34;ll_rw_block.c: buffer not locked</span><span class="se">\n\r</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_lock</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 唤醒睡眠在 bh-&gt;b_wait 上的进程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_wait</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>分析 <code>lock_buffer()</code> 可以看出，访问锁变量时用开、关中断来实现原子操作，阻止进程切换的发生。当然这种方法有缺点，且不适合用于多处理器环境中，但对于 Linux 0.11，它是一种简单、直接而有效的机制。</p>
<p>另外，上面的函数表明 Linux 0.11 提供了这样的接口：用 <code>sleep_on()</code> 实现进程的睡眠，用 <code>wake_up()</code> 实现进程的唤醒。它们的参数都是一个结构体指针—— <code>struct task_struct *</code>，即进程都睡眠或唤醒在该参数指向的一个进程 PCB 结构链表上。</p>
<p>因此，我们可以用开关中断的方式实现原子操作，而调用 <code>sleep_on()</code> 和 <code>wake_up()</code> 进行进程的睡眠和唤醒。</p>
<p><code>sleep_on()</code> 的功能是将当前进程睡眠在参数指定的链表上（注意，这个链表是一个隐式链表，详见《注释》一书）。<code>wake_up()</code> 的功能是唤醒链表上睡眠的所有进程。这些进程都会被调度运行，所以它们被唤醒后，还要重新判断一下是否可以继续运行。可参考 <code>lock_buffer()</code> 中的那个 while 循环。</p>
<h3 id="45应对混乱的-bochs-虚拟屏幕">4.5应对混乱的 bochs 虚拟屏幕<a hidden class="anchor" aria-hidden="true" href="#45应对混乱的-bochs-虚拟屏幕">#</a></h3>
<p>不知是 Linux 0.11 还是 bochs 的 bug，如果向终端输出的信息较多，bochs 的虚拟屏幕会产生混乱。此时按 ctrl+L 可以重新初始化一下屏幕，但输出信息一多，还是会混乱。建议把输出信息重定向到一个文件，然后用 vi、more 等工具按屏查看这个文件，可以基本解决此问题。</p>
<h3 id="46关于-stringh-的提示">4.6关于 string.h 的提示<a hidden class="anchor" aria-hidden="true" href="#46关于-stringh-的提示">#</a></h3>
<p>下面描述的问题未必具有普遍意义，仅做为提醒，请实验者注意。</p>
<p>include/string.h 实现了全套的 C 语言字符串操作，而且都是采用汇编 + inline 方式优化。</p>
<p>但在使用中，某些情况下可能会遇到一些奇怪的问题。比如某人就遇到 <code>strcmp()</code> 会破坏参数内容的问题。如果调试中遇到有些 “诡异” 的情况，可以试试不包含头文件，一般都能解决。不包含 <code>string.h</code>，就不会用 inline 方式调用这些函数，它们工作起来就趋于正常了。</p>
<h2 id="5实验步骤">5.实验步骤<a hidden class="anchor" aria-hidden="true" href="#5实验步骤">#</a></h2>
<h3 id="实验内容">实验内容<a hidden class="anchor" aria-hidden="true" href="#实验内容">#</a></h3>
<p>本次实验的基本内容是在Linux 0.11的内核中实现信号量，并向用户提供使用信号量的接口，用户使用该接口解决一个实际的进程同步问题。实验的主要内容包括如下两个部分：</p>
<h4 id="1实现信号量">1.实现信号量<a hidden class="anchor" aria-hidden="true" href="#1实现信号量">#</a></h4>
<p>在Linux 0.11内核上（Linux 0.11内核中没有定义信号量）实现信号量，并创建相应的系统调用以供用户使用。应提供的系统接口主要包括：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">CreateSemaphore</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span> <span class="n">semname</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>该操作用来在内核中创建一个信号量，输入的参数是信号量的名字，返回的是信号量的一个整数标识semid，信号量是一种内核资源，不应该无限制的创建，所以在内核中信号量可以被组织成一个数组，此时semid就是创建的信号量在内核信号量数组中的下标。如果这个名为semname的信号量已经创建，则返回这个已创建的信号量的标识semid，也即多个具有相同名字的信号量创建接口返回相同的返回值，即相同的semid</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">SetSemaphore</span><span class="p">(</span><span class="kt">int</span> <span class="n">semid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>用来设置信号量的值，其中semid是信号量标识，value是要设置的信号量值，该函数的返回值是信号量的当前值。该接口通常用来设置信号量的初值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">WaitSemaphore</span><span class="p">(</span><span class="kt">int</span> <span class="n">semid</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>该函数就是信号量的P操作，其功能就是对信号量的值减1，如果其值小于0则令调用进程等待在信号量semid上。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">SignalSemaphore</span><span class="p">(</span><span class="kt">int</span> <span class="n">semid</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>该函数就是信号量的V操作，其功能就是对信号量的值加1，如果其值小于等于0则令唤醒等待在信号量semid上的进程。</p>
<h4 id="2使用信号量">2.使用信号量<a hidden class="anchor" aria-hidden="true" href="#2使用信号量">#</a></h4>
<p>在定义了信号量的Linux 0.11操作系统上编写用户程序来演示信号量的作用。该用户程序解决就是传统的生产者—消费者问题，要求编写的用户程序完成下面的任务：
1.编写的主程序演示生产者—消费者两个进程的同步过程；
2.编写的主程序创建两个进程：生产者进程和消费者进程；
3.编写生产者进程和消费者进程的代码。
4.要求对比三种设置下的运行结果：</p>
<ul>
<li>没有信号量下的生产者—消费者。</li>
<li>有信号量，1个生产者进程，1个消费者进程，用for循环控制生产者（消费者）各执行N次。</li>
<li>有信号量，N个生产者进程，N个消费者进程。</li>
</ul>
<h3 id="步骤">步骤<a hidden class="anchor" aria-hidden="true" href="#步骤">#</a></h3>
<h4 id="一实现信号量">一、实现信号量<a hidden class="anchor" aria-hidden="true" href="#一实现信号量">#</a></h4>
<h4 id="1新建semh">1.新建sem.h<a hidden class="anchor" aria-hidden="true" href="#1新建semh">#</a></h4>
<p>在linux-0.11/include/linux目录下新建sem.h，定义信号量的数据结构。sem.h的代码如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#ifndef _SEM_H
</span></span></span><span class="line"><span class="cl"><span class="cp">#define _SEM_H
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;linux/sched.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#define SEMTABLE_LEN    20
</span></span></span><span class="line"><span class="cl"><span class="cp">#define SEM_NAME_LEN    20
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">semaphore</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">SEM_NAME_LEN</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">queue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="kt">sem_t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">extern</span> <span class="kt">sem_t</span> <span class="n">semtable</span><span class="p">[</span><span class="n">SEMTABLE_LEN</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>代码截图如下：</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012340949.png" alt="img"  />
</p>
<h4 id="2新建semc">2.新建sem.c<a hidden class="anchor" aria-hidden="true" href="#2新建semc">#</a></h4>
<p>在linux-0.11/kernel目录下，新建实现信号量函数的源代码文件sem.c。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;linux/sem.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;linux/sched.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;asm/segment.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;linux/tty.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;linux/kernel.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;linux/fdreg.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;asm/system.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;asm/io.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="c1">//#include &lt;string.h&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">sem_t</span> <span class="n">semtable</span><span class="p">[</span><span class="n">SEMTABLE_LEN</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">sem_t</span> <span class="o">*</span><span class="nf">sys_sem_open</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">kernelname</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>   
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">isExist</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">name_cnt</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span> <span class="nf">get_fs_byte</span><span class="p">(</span><span class="n">name</span><span class="o">+</span><span class="n">name_cnt</span><span class="p">)</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">name_cnt</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">name_cnt</span><span class="o">&gt;</span><span class="n">SEM_NAME_LEN</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">name_cnt</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">kernelname</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="nf">get_fs_byte</span><span class="p">(</span><span class="n">name</span><span class="o">+</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">name_len</span> <span class="o">=</span> <span class="nf">strlen</span><span class="p">(</span><span class="n">kernelname</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">sem_name_len</span> <span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">sem_t</span> <span class="o">*</span><span class="n">p</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">cnt</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">sem_name_len</span> <span class="o">=</span> <span class="nf">strlen</span><span class="p">(</span><span class="n">semtable</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">sem_name_len</span> <span class="o">==</span> <span class="n">name_len</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="nf">strcmp</span><span class="p">(</span><span class="n">kernelname</span><span class="p">,</span><span class="n">semtable</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">)</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">isExist</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                    <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">isExist</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">p</span><span class="o">=</span><span class="p">(</span><span class="kt">sem_t</span><span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">semtable</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//printk(&#34;find previous name!\n&#34;);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">name_len</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">semtable</span><span class="p">[</span><span class="n">cnt</span><span class="p">].</span><span class="n">name</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">kernelname</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">semtable</span><span class="p">[</span><span class="n">cnt</span><span class="p">].</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">p</span><span class="o">=</span><span class="p">(</span><span class="kt">sem_t</span><span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">semtable</span><span class="p">[</span><span class="n">cnt</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">         <span class="c1">//printk(&#34;creat name!\n&#34;);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">cnt</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">     <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">sys_sem_wait</span><span class="p">(</span><span class="kt">sem_t</span> <span class="o">*</span><span class="n">sem</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">cli</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span> <span class="n">sem</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">)</span>        <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">sleep_on</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">sem</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">));</span>    <span class="c1">//这两条语句顺序不能颠倒，很重要，是关于互斥信号量能不能正确工作的！！！
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">sem</span><span class="o">-&gt;</span><span class="n">value</span><span class="o">--</span><span class="p">;</span>               
</span></span><span class="line"><span class="cl">    <span class="nf">sti</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">sys_sem_post</span><span class="p">(</span><span class="kt">sem_t</span> <span class="o">*</span><span class="n">sem</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">cli</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">sem</span><span class="o">-&gt;</span><span class="n">value</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="p">(</span><span class="n">sem</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">sem</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="nf">sti</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">sys_sem_unlink</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">kernelname</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>   <span class="cm">/* 应该足够大了 */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">isExist</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">name_cnt</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span> <span class="nf">get_fs_byte</span><span class="p">(</span><span class="n">name</span><span class="o">+</span><span class="n">name_cnt</span><span class="p">)</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">name_cnt</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">name_cnt</span><span class="o">&gt;</span><span class="n">SEM_NAME_LEN</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">name_cnt</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">kernelname</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="nf">get_fs_byte</span><span class="p">(</span><span class="n">name</span><span class="o">+</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">name_len</span> <span class="o">=</span> <span class="nf">strlen</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">sem_name_len</span> <span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">cnt</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">sem_name_len</span> <span class="o">=</span> <span class="nf">strlen</span><span class="p">(</span><span class="n">semtable</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">sem_name_len</span> <span class="o">==</span> <span class="n">name_len</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="nf">strcmp</span><span class="p">(</span><span class="n">kernelname</span><span class="p">,</span><span class="n">semtable</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                <span class="p">{</span>
</span></span><span class="line"><span class="cl">                        <span class="n">isExist</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                        <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">isExist</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">tmp</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="n">tmp</span><span class="o">=</span><span class="n">i</span><span class="p">;</span><span class="n">tmp</span><span class="o">&lt;=</span><span class="n">cnt</span><span class="p">;</span><span class="n">tmp</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">semtable</span><span class="p">[</span><span class="n">tmp</span><span class="p">]</span><span class="o">=</span><span class="n">semtable</span><span class="p">[</span><span class="n">tmp</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">cnt</span> <span class="o">=</span> <span class="n">cnt</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="3修改unistdh">3.修改unistd.h<a hidden class="anchor" aria-hidden="true" href="#3修改unistdh">#</a></h4>
<p>在unistd.h内增加新的系统调用编号(之前的实验中也有做系统调用，所以这里直接记录一下修改的结果，过程就大概省略了一些)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#define __NR_sem_open   72 
</span></span></span><span class="line"><span class="cl"><span class="cp">#define __NR_sem_wait   73
</span></span></span><span class="line"><span class="cl"><span class="cp">#define __NR_sem_post   74
</span></span></span><span class="line"><span class="cl"><span class="cp">#define __NR_sem_unlink 75
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="4修改system_calls">4.修改system_call.s<a hidden class="anchor" aria-hidden="true" href="#4修改system_calls">#</a></h4>
<p>在system_call.s文件中找到nr_system_calls并将其值更改为76（因为增加了四个sem系统调用函数）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">nr_system_calls</span> <span class="o">=</span> <span class="mi">76</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="5修改sysh">5.修改sys.h<a hidden class="anchor" aria-hidden="true" href="#5修改sysh">#</a></h4>
<ul>
<li>增加四个函数，函数如下：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">extern</span> <span class="kt">int</span> <span class="nf">sys_sem_open</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="k">extern</span> <span class="kt">int</span> <span class="nf">sys_sem_wait</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="k">extern</span> <span class="kt">int</span> <span class="nf">sys_sem_post</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="k">extern</span> <span class="kt">int</span> <span class="nf">sys_sem_unlink</span><span class="p">();</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>将函数名放在数组内：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">sys_sem_open</span><span class="p">,</span><span class="n">sys_sem_wait</span><span class="p">,</span><span class="n">sys_sem_post</span><span class="p">,</span><span class="n">sys_sem_unlink</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>代码截图如下:</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012340955.png" alt="img"  />
</p>
<h4 id="6修改makefile">6.修改Makefile<a hidden class="anchor" aria-hidden="true" href="#6修改makefile">#</a></h4>
<p>将kernel下的Makefile修改为如下代码块（部分）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="p">......</span>
</span></span><span class="line"><span class="cl"><span class="n">OBJS</span>  <span class="o">=</span> <span class="n">sched</span><span class="p">.</span><span class="n">o</span> <span class="n">system_call</span><span class="p">.</span><span class="n">o</span> <span class="n">traps</span><span class="p">.</span><span class="n">o</span> <span class="k">asm</span><span class="p">.</span><span class="n">o</span> <span class="n">fork</span><span class="p">.</span><span class="n">o</span> \
</span></span><span class="line"><span class="cl"><span class="n">panic</span><span class="p">.</span><span class="n">o</span> <span class="n">printk</span><span class="p">.</span><span class="n">o</span> <span class="n">vsprintf</span><span class="p">.</span><span class="n">o</span> <span class="n">sys</span><span class="p">.</span><span class="n">o</span> <span class="n">exit</span><span class="p">.</span><span class="n">o</span> \
</span></span><span class="line"><span class="cl"><span class="n">signal</span><span class="p">.</span><span class="n">o</span> <span class="n">mktime</span><span class="p">.</span><span class="n">o</span> <span class="n">sem</span><span class="p">.</span><span class="n">o</span>
</span></span><span class="line"><span class="cl"><span class="p">......</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">### ###Dependencies:
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="n">sem</span><span class="p">.</span><span class="n">s</span> <span class="n">sem</span><span class="p">.</span><span class="nl">o</span><span class="p">:</span> <span class="n">sem</span><span class="p">.</span><span class="n">c</span> <span class="p">..</span><span class="o">/</span><span class="n">include</span><span class="o">/</span><span class="n">linux</span><span class="o">/</span><span class="n">sem</span><span class="p">.</span><span class="n">h</span> <span class="p">..</span><span class="o">/</span><span class="n">include</span><span class="o">/</span><span class="n">linux</span><span class="o">/</span><span class="n">kernel</span><span class="p">.</span><span class="n">h</span> \
</span></span><span class="line"><span class="cl"><span class="p">..</span><span class="o">/</span><span class="n">include</span><span class="o">/</span><span class="n">unistd</span><span class="p">.</span><span class="n">h</span>
</span></span><span class="line"><span class="cl"><span class="p">......</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Makefile截图如下:</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012340963.png" alt="img"  />
</p>
<h4 id="7挂载hdc并准备相关文件">7.挂载hdc并准备相关文件<a hidden class="anchor" aria-hidden="true" href="#7挂载hdc并准备相关文件">#</a></h4>
<p>进入oslab根目录执行<strong>sudo ./mount-hdc</strong>，随后将unistd.h复制到usr/include下，将sem.h复制到usr/include/linux下，最后使用<strong>sudo umount hdc</strong>卸载hdc</p>
<h4 id="二编写生产者-消费者检验程序">二、编写生产者-消费者检验程序<a hidden class="anchor" aria-hidden="true" href="#二编写生产者-消费者检验程序">#</a></h4>
<h4 id="1新建pcc文件">1.新建pc.c文件<a hidden class="anchor" aria-hidden="true" href="#1新建pcc文件">#</a></h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#define __LIBRARY__
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;linux/sem.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/stat.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;fcntl.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;linux/sched.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="nf">_syscall2</span><span class="p">(</span><span class="kt">sem_t</span> <span class="o">*</span><span class="p">,</span><span class="n">sem_open</span><span class="p">,</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span><span class="n">value</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nf">_syscall1</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="n">sem_wait</span><span class="p">,</span><span class="kt">sem_t</span> <span class="o">*</span><span class="p">,</span><span class="n">sem</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nf">_syscall1</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="n">sem_post</span><span class="p">,</span><span class="kt">sem_t</span> <span class="o">*</span><span class="p">,</span><span class="n">sem</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nf">_syscall1</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="n">sem_unlink</span><span class="p">,</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span><span class="n">name</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">FILENAME</span> <span class="o">=</span> <span class="s">&#34;/usr/root/buffer_file&#34;</span><span class="p">;</span>    <span class="cm">/* 消费生产的产品存放的缓冲文件的路径 */</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">NR_CONSUMERS</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>                        <span class="cm">/* 消费者的数量 */</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">NR_ITEMS</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>                        <span class="cm">/* 产品的最大量 */</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">BUFFER_SIZE</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>                        <span class="cm">/* 缓冲区大小，表示可同时存在的产品数量 */</span>
</span></span><span class="line"><span class="cl"><span class="kt">sem_t</span> <span class="o">*</span><span class="n">metux</span><span class="p">,</span> <span class="o">*</span><span class="n">full</span><span class="p">,</span> <span class="o">*</span><span class="n">empty</span><span class="p">;</span>                    <span class="cm">/* 3个信号量 */</span>
</span></span><span class="line"><span class="cl"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">item_pro</span><span class="p">,</span> <span class="n">item_used</span><span class="p">;</span>                <span class="cm">/* 刚生产的产品号；刚消费的产品号 */</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">fi</span><span class="p">,</span> <span class="n">fo</span><span class="p">;</span>                                        <span class="cm">/* 供生产者写入或消费者读取的缓冲文件的句柄 */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">pid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">filename</span> <span class="o">=</span> <span class="n">argc</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">?</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">:</span> <span class="n">FILENAME</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* O_TRUNC 表示：当文件以只读或只写打开时，若文件存在，则将其长度截为0（即清空文件）
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 0222 和 0444 分别表示文件只写和只读（前面的0是八进制标识）
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="n">fi</span> <span class="o">=</span> <span class="nf">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">O_CREAT</span><span class="o">|</span> <span class="n">O_TRUNC</span><span class="o">|</span> <span class="n">O_WRONLY</span><span class="p">,</span> <span class="mo">0222</span><span class="p">);</span>    <span class="cm">/* 以只写方式打开文件给生产者写入产品编号 */</span>
</span></span><span class="line"><span class="cl">    <span class="n">fo</span> <span class="o">=</span> <span class="nf">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">O_TRUNC</span><span class="o">|</span> <span class="n">O_RDONLY</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>            <span class="cm">/* 以只读方式打开文件给消费者读出产品编号 */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">metux</span> <span class="o">=</span> <span class="nf">sem_open</span><span class="p">(</span><span class="s">&#34;METUX&#34;</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>    <span class="cm">/* 互斥信号量，防止生产消费同时进行 */</span>
</span></span><span class="line"><span class="cl">    <span class="n">full</span> <span class="o">=</span> <span class="nf">sem_open</span><span class="p">(</span><span class="s">&#34;FULL&#34;</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>        <span class="cm">/* 产品剩余信号量，大于0则可消费 */</span>
</span></span><span class="line"><span class="cl">    <span class="n">empty</span> <span class="o">=</span> <span class="nf">sem_open</span><span class="p">(</span><span class="s">&#34;EMPTY&#34;</span><span class="p">,</span> <span class="n">BUFFER_SIZE</span><span class="p">);</span>    <span class="cm">/* 空信号量，它与产品剩余信号量此消彼长，大于0时生产者才能继续生产 */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">item_pro</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">((</span><span class="n">pid</span> <span class="o">=</span> <span class="nf">fork</span><span class="p">()))</span>    <span class="cm">/* 父进程用来执行消费者动作 */</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;pid %d:</span><span class="se">\t</span><span class="s">producer created....</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* printf()输出的信息会先保存到输出缓冲区，并没有马上输出到标准输出（通常为终端控制台）。
</span></span></span><span class="line"><span class="cl"><span class="cm">         * 为避免偶然因素的影响，我们每次printf()都调用一下stdio.h中的fflush(stdout)
</span></span></span><span class="line"><span class="cl"><span class="cm">         * 来确保将输出立刻输出到标准输出。
</span></span></span><span class="line"><span class="cl"><span class="cm">         */</span>
</span></span><span class="line"><span class="cl">        <span class="nf">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">(</span><span class="n">item_pro</span> <span class="o">&lt;=</span> <span class="n">NR_ITEMS</span><span class="p">)</span>    <span class="cm">/* 生产完所需产品 */</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">sem_wait</span><span class="p">(</span><span class="n">empty</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="nf">sem_wait</span><span class="p">(</span><span class="n">metux</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="cm">/* 生产完一轮产品（文件缓冲区只能容纳BUFFER_SIZE个产品编号）后
</span></span></span><span class="line"><span class="cl"><span class="cm">             * 将缓冲文件的位置指针重新定位到文件首部。
</span></span></span><span class="line"><span class="cl"><span class="cm">             */</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">item_pro</span> <span class="o">%</span> <span class="n">BUFFER_SIZE</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                <span class="nf">lseek</span><span class="p">(</span><span class="n">fi</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="nf">write</span><span class="p">(</span><span class="n">fi</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">item_pro</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">item_pro</span><span class="p">));</span>        <span class="cm">/* 写入产品编号 */</span>
</span></span><span class="line"><span class="cl">            <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;pid %d:</span><span class="se">\t</span><span class="s">produces item %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="n">item_pro</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="nf">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">item_pro</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="nf">sem_post</span><span class="p">(</span><span class="n">metux</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="nf">sem_post</span><span class="p">(</span><span class="n">full</span><span class="p">);</span>        <span class="cm">/* 唤醒消费者进程 */</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>    <span class="cm">/* 子进程来创建消费者 */</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">i</span> <span class="o">=</span> <span class="n">NR_CONSUMERS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span><span class="p">(</span><span class="n">i</span><span class="o">--</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">pid</span><span class="o">=</span><span class="nf">fork</span><span class="p">()))</span>    <span class="cm">/* 创建i个消费者进程 */</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">pid</span> <span class="o">=</span> <span class="nf">getpid</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">                <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;pid %d:</span><span class="se">\t</span><span class="s">consumer %d created....</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="n">NR_CONSUMERS</span><span class="o">-</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="nf">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="nf">sem_wait</span><span class="p">(</span><span class="n">full</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                    <span class="nf">sem_wait</span><span class="p">(</span><span class="n">metux</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                    <span class="cm">/* read()读到文件末尾时返回0，将文件的位置指针重新定位到文件首部 */</span>
</span></span><span class="line"><span class="cl">                    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nf">read</span><span class="p">(</span><span class="n">fo</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">item_used</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">item_used</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">                    <span class="p">{</span>
</span></span><span class="line"><span class="cl">                        <span class="nf">lseek</span><span class="p">(</span><span class="n">fo</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                        <span class="nf">read</span><span class="p">(</span><span class="n">fo</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">item_used</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">item_used</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">                    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;pid %d:</span><span class="se">\t</span><span class="s">consumer %d consumes item %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="n">NR_CONSUMERS</span><span class="o">-</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">item_used</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                    <span class="nf">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                    <span class="nf">sem_post</span><span class="p">(</span><span class="n">metux</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                    <span class="nf">sem_post</span><span class="p">(</span><span class="n">empty</span><span class="p">);</span>    <span class="cm">/* 唤醒生产者进程 */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                    <span class="k">if</span><span class="p">(</span><span class="n">item_used</span> <span class="o">==</span> <span class="n">NR_ITEMS</span><span class="p">)</span>    <span class="cm">/* 如果已经消费完最后一个商品，则结束 */</span>
</span></span><span class="line"><span class="cl">                        <span class="k">goto</span> <span class="n">OK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nl">OK</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nf">close</span><span class="p">(</span><span class="n">fi</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">close</span><span class="p">(</span><span class="n">fo</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>将此文件移动到usr/root目录下，此目录需要挂载hdc才可以访问。移动成功之后直接重新编译linux并在虚拟环境内运行。</p>
<h4 id="2编译运行pcc">2.编译运行pc.c<a hidden class="anchor" aria-hidden="true" href="#2编译运行pcc">#</a></h4>
<p>运行linux-0.11之后，首先编译pc.c，使用命令<strong>gcc -o pc pc.c</strong>，随后运行pc，使用命令**./pc &gt; sem_output**即可，最终在虚拟环境内输入sync把修改的数据写入磁盘。</p>
<h4 id="遇到的问题还没解决"><code>遇到的问题(还没解决)</code><a hidden class="anchor" aria-hidden="true" href="#遇到的问题还没解决">#</a></h4>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012340962.png" alt="image-20220410161634084"  />
</p>
<p>上面报了一个类型转换的异常，定义和调用sem_open的地方如下，但是没有发现哪个地方写错了</p>
<img src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012340959.png" alt="image-20220410161721485" style="zoom:80%;" /> 
<img src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012340969.png" alt="image-20220410161809029" style="zoom:80%;" /> 
<h4 id="3查看sem_output">3.查看sem_output<a hidden class="anchor" aria-hidden="true" href="#3查看sem_output">#</a></h4>
<p>首先挂载hdc，然后进入usr/root目录并在终端内执行<strong>sudo less sem_output</strong>命令，可看到下图结果：</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012340234.png" alt="img"  />
</p>
<h4 id="4对比有无信号量">4.对比有无信号量<a hidden class="anchor" aria-hidden="true" href="#4对比有无信号量">#</a></h4>
<p>删除pc.c文件中关于信号量的代码，重新编译运行后得出如下结果</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012340260.png" alt="img"  />
</p>
<h3 id="回答问题">回答问题<a hidden class="anchor" aria-hidden="true" href="#回答问题">#</a></h3>
<p>在有无信号量的不同条件下对比运行结果后可以发现，如果去掉所有与信号量有关的代码，编译运行程序之后可以发现输出的数字顺序完全混乱。
信号量不存在的情况下，进程之间无法同步或者协作，造成此种情况的有如下原因：</p>
<ul>
<li>一种情况是缓冲区满了，生产者还在写入数据，会造覆盖掉部分数据。</li>
<li>一种是缓冲区为空，消费者尝试读取数据，读到的数据是已输出的数据。</li>
<li>多个进程对文件缓冲区同时访问，造成了程序崩溃。</li>
</ul>


  </div>

  <footer class="post-footer">
    
<nav class="paginav">
  <a class="prev" href="https://chance7bin.github.io/posts/basic/asm/%E7%AC%AC4%E7%AB%A0-%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F/">
    <span class="title">« 上一页</span>
    <br>
    <span>第4章 第一个程序</span>
  </a>
  <a class="next" href="https://chance7bin.github.io/posts/basic/asm/%E7%AC%AC5%E7%AB%A0-bx%E5%92%8Cloop%E6%8C%87%E4%BB%A4/">
    <span class="title">下一页 »</span>
    <br>
    <span>第5章 [BX]和loop指令</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://chance7bin.github.io/">Binb&#39;s Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
