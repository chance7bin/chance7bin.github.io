<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>实验7 地址映射与共享 | Binb&#39;s Blog</title>
<meta name="keywords" content="操作系统, 实验">
<meta name="description" content="1.实验目的 深入理解操作系统的段、页式内存管理，深入理解段表、页表、逻辑地址、线性地址、物理地址等概念； 实践段、页式内存管理的地址映射过程；">
<meta name="author" content="chance7bin">
<link rel="canonical" href="https://chance7bin.github.io/posts/basic/os-lab/%E5%AE%9E%E9%AA%8C7-%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E4%B8%8E%E5%85%B1%E4%BA%AB/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.be81eec981a615a87a88f121642d7eebde74d033438693944db2fd6b827284ff.css" integrity="" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.acb54fd32bbc1982428b8850317e45d076b95012730a5936667e6bc21777692a.js" integrity=""
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://chance7bin.github.io/img/%E7%BE%8E%E9%98%9F.jpg">
<link rel="icon" type="image/png" sizes="16x16" href="https://chance7bin.github.io/img/%E7%BE%8E%E9%98%9F.jpg">
<link rel="icon" type="image/png" sizes="32x32" href="https://chance7bin.github.io/img/%E7%BE%8E%E9%98%9F.jpg">
<link rel="apple-touch-icon" href="https://chance7bin.github.io/img/%E7%BE%8E%E9%98%9F.jpg">
<link rel="mask-icon" href="https://chance7bin.github.io/img/%E7%BE%8E%E9%98%9F.jpg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="实验7 地址映射与共享" />
<meta property="og:description" content="1.实验目的 深入理解操作系统的段、页式内存管理，深入理解段表、页表、逻辑地址、线性地址、物理地址等概念； 实践段、页式内存管理的地址映射过程；" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://chance7bin.github.io/posts/basic/os-lab/%E5%AE%9E%E9%AA%8C7-%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E4%B8%8E%E5%85%B1%E4%BA%AB/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-25T00:00:00+00:00" />
<meta property="article:modified_time" content="2022-05-25T00:00:00+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="实验7 地址映射与共享"/>
<meta name="twitter:description" content="1.实验目的 深入理解操作系统的段、页式内存管理，深入理解段表、页表、逻辑地址、线性地址、物理地址等概念； 实践段、页式内存管理的地址映射过程；"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "📚 文章",
      "item": "https://chance7bin.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "📕 计算机基础",
      "item": "https://chance7bin.github.io/posts/basic/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "hit-oslab",
      "item": "https://chance7bin.github.io/posts/basic/os-lab/"
    }, 
    {
      "@type": "ListItem",
      "position":  4 ,
      "name": "实验7 地址映射与共享",
      "item": "https://chance7bin.github.io/posts/basic/os-lab/%E5%AE%9E%E9%AA%8C7-%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E4%B8%8E%E5%85%B1%E4%BA%AB/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "实验7 地址映射与共享",
  "name": "实验7 地址映射与共享",
  "description": "1.实验目的 深入理解操作系统的段、页式内存管理，深入理解段表、页表、逻辑地址、线性地址、物理地址等概念； 实践段、页式内存管理的地址映射过程；",
  "keywords": [
    "操作系统", "实验"
  ],
  "articleBody": "1.实验目的 深入理解操作系统的段、页式内存管理，深入理解段表、页表、逻辑地址、线性地址、物理地址等概念； 实践段、页式内存管理的地址映射过程； 编程实现段、页式内存管理上的内存共享，从而深入理解操作系统的内存管理。 2.实验内容 本次实验的基本内容是：\n用 Bochs 调试工具跟踪 Linux 0.11 的地址翻译（地址映射）过程，了解 IA-32 和 Linux 0.11 的内存管理机制； 在 Ubuntu 上编写多进程的生产者—消费者程序，用共享内存做缓冲区； 在信号量实验的基础上，为 Linux 0.11 增加共享内存功能，并将生产者—消费者程序移植到 Linux 0.11。 2.1 跟踪地址翻译过程 首先以汇编级调试的方式启动 Bochs，引导 Linux 0.11，在 0.11 下编译和运行 test.c。它是一个无限循环的程序，永远不会主动退出。然后在调试器中通过查看各项系统参数，从逻辑地址、LDT 表、GDT 表、线性地址到页表，计算出变量 i 的物理地址。最后通过直接修改物理内存的方式让 test.c 退出运行。\ntest.c 的代码如下：\n1 2 3 4 5 6 7 8 9 10 11 #include int i = 0x12345678; int main(void) { printf(\"The logical/virtual address of i is 0x%08x\", \u0026i); fflush(stdout); while (i) ; return 0; } 2.2 基于共享内存的生产者—消费者程序 本项实验在 Ubuntu 下完成，与信号量实验中的 pc.c 的功能要求基本一致，仅有两点不同：\n不用文件做缓冲区，而是使用共享内存； 生产者和消费者分别是不同的程序。生产者是 producer.c，消费者是 consumer.c。两个程序都是单进程的，通过信号量和缓冲区进行通信。 Linux 下，可以通过 shmget() 和 shmat() 两个系统调用使用共享内存。\n2.3 共享内存的实现 进程之间可以通过页共享进行通信，被共享的页叫做共享内存，结构如下图所示：\n图 1 进程间共享内存的结构\n本部分实验内容是在 Linux 0.11 上实现上述页面共享，并将上一部分实现的 producer.c 和 consumer.c 移植过来，验证页面共享的有效性。\n具体要求在 mm/shm.c 中实现 shmget() 和 shmat() 两个系统调用。它们能支持 producer.c 和 consumer.c 的运行即可，不需要完整地实现 POSIX 所规定的功能。\nshmget() 1 int shmget(key_t key, size_t size, int shmflg); shmget() 会新建/打开一页内存，并返回该页共享内存的 shmid（该块共享内存在操作系统内部的 id）。\n所有使用同一块共享内存的进程都要使用相同的 key 参数。\n如果 key 所对应的共享内存已经建立，则直接返回 shmid。如果 size 超过一页内存的大小，返回 -1，并置 errno 为 EINVAL。如果系统无空闲内存，返回 -1，并置 errno 为 ENOMEM。\nshmflg 参数可忽略。\nshmat() 1 void *shmat(int shmid, const void *shmaddr, int shmflg); shmat() 会将 shmid 指定的共享页面映射到当前进程的虚拟地址空间中，并将其首地址返回。\n如果 shmid 非法，返回 -1，并置 errno 为 EINVAL。\nshmaddr 和 shmflg 参数可忽略。\n3.实验报告 完成实验后，在实验报告中回答如下问题：\n对于地址映射实验部分，列出你认为最重要的那几步（不超过 4 步），并给出你获得的实验数据。 test.c 退出后，如果马上再运行一次，并再进行地址跟踪，你发现有哪些异同？为什么？ 4.实验提示 本次需要完成的内容：\n（1）用 Bochs 调试工具跟踪 Linux 0.11 的地址翻译（地址映射）过程，了解 IA-32 和 Linux 0.11 的内存管理机制； （2）在 Ubuntu 上编写多进程的生产者—消费者程序，用共享内存做缓冲区； （3）在信号量实验的基础上，为 Linux 0.11 增加共享内存功能，并将生产者—消费者程序移植到 Linux 0.11。 4.1 IA-32 的地址翻译过程 Linux 0.11 完全遵循 IA-32（Intel Architecture 32-bit）架构进行地址翻译，Windows、后续版本的 Linux 以及一切在 IA-32 保护模式下运行的操作系统都遵循此架构。因为只有这样才能充分发挥 CPU 的 MMU（内存管理单元） 的功能。\n关于此地址翻译过程的细节，请参考《注释》一书中的 5.3.1-5.3.4 节。\n4.2 用 Bochs 汇编级调试功能进行人工地址翻译 此过程比较机械，基本不消耗脑细胞，做一下有很多好处。\n==Bochs命令==\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 [内存操作] x /nuf [addr] 显示线性地址的内容 xp /nuf [addr] 显示物理地址的内容 n 显示的单元数 u 每个显示单元的大小，u可以是下列之一： b BYTE h WORD w DWORD g DWORD64 注意: 这种命名法是按照GDB习惯的，而并不是按照inter的规范。 f 显示格式，f可以是下列之一： x 按照十六进制显示 d 十进制显示 u 按照无符号十进制显示 o 按照八进制显示 t 按照二进制显示 c 按照字符显示 n、f、u是可选参数，如果不指定，则u默认是w，f默认是x。如果前面使用过x或 者xp命令，会按照上一次的x或者xp命令所使用的值。n默认为1。addr 也是一个 可选参数，如果不指定，addr是0，如过前面使用过x或者xp命令，指定了n=i， 则再次执行时n默认为i+1。 setpmem [addr] [size] [val] 设置物理内存某地址的内容。 （1）准备 编译好 Linux 0.11 后，首先通过运行 ./dbg-asm 启动调试器，此时 Bochs 的窗口处于黑屏状态\n而命令行窗口显示：\n1 2 3 4 5 6 7 8 9 10 ======================================================================== Bochs x86 Emulator 2.3.7 Build from CVS snapshot, on June 3, 2008 ======================================================================== 00000000000i[ ] reading configuration from ./bochs/bochsrc.bxrc 00000000000i[ ] installing x module as the Bochs GUI 00000000000i[ ] using log file ./bochsout.txt Next at t=0 (0) [0xfffffff0] f000:fff0 (unk. ctxt): jmp far f000:e05b ; ea5be000f0 _ Next at t=0 表示下面的指令是 Bochs 启动后要执行的第一条软件指令。\n单步跟踪进去就能看到 BIOS 的代码。不过这不是本实验需要的。直接输入命令 c，continue 程序的运行，Bochs 一如既往地启动了 Linux 0.11。\n在 Linux 0.11 下输入（或拷入）test.c（代码在本实验的第 3 小节中），编译为 test，运行之，打印如下信息：\n1 The logical/virtual address of i is 0x00003004 只要 test 不变，0x00003004 这个值在任何人的机器上都是一样的。即使在同一个机器上多次运行 test，也是一样的。\ntest 是一个死循环，只会不停占用 CPU，不会退出。\n（2）暂停 当 test 运行的时候，在命令行窗口按 Ctrl+c，Bochs 会暂停运行，进入调试状态。绝大多数情况下都会停在 test 内，显示类似如下信息：\n1 (0) [0x00fc8031] 000f:00000031 (unk. ctxt): cmp dword ptr ds:0x3004, 0x00000000 ; 833d0430000000 其中的 000f 如果是 0008，则说明中断在了内核里。那么就要 c，然后再 ctrl+c，直到变为 000f 为止。\n如果显示的下一条指令不是 cmp ...（这里指语句以 cmp 开头），就用 n 命令单步运行几步，直到停在 cmp ...。\n使用命令 u /8，显示从当前位置开始 8 条指令的反汇编代码，结构如下：\n1 2 3 4 5 6 7 8 9 u /8 10000063: ( ): cmp dword ptr ds:0x3004, 0x00000000 ; 833d0430000000 1000006a: ( ): jz .+0x00000004 ; 7404 1000006c: ( ): jmp .+0xfffffff5 ; ebf5 1000006e: ( ): add byte ptr ds:[eax], al ; 0000 10000070: ( ): xor eax, eax ; 31c0 10000072: ( ): jmp .+0x00000000 ; eb00 10000074: ( ): leave ; c9 10000075: ( ): ret ; c3 这就是 test.c 中从 while 开始一直到 return 的汇编代码。变量 i 保存在 ds:0x3004 这个地址，并不停地和 0 进行比较，直到它为 0，才会跳出循环。\n现在，开始寻找 ds:0x3004 对应的物理地址。\n4.3 段表 ds:0x3004 是虚拟地址，ds 表明这个地址属于 ds 段。首先要找到段表，然后通过 ds 的值在段表中找到 ds 段的具体信息，才能继续进行地址翻译。\n每个在 IA-32 上运行的应用程序都有一个段表，叫 LDT，段的信息叫段描述符。\nLDT 在哪里呢？ldtr 寄存器是线索的起点，通过它可以在 GDT（全局描述符表）中找到 LDT 的物理地址。\n用 sreg 命令（是在调试窗口输入）：\n1 2 3 4 5 6 7 8 9 10 11 sreg cs:s=0x000f, dl=0x00000002, dh=0x10c0fa00, valid=1 ds:s=0x0017, dl=0x00003fff, dh=0x10c0f300, valid=3 ss:s=0x0017, dl=0x00003fff, dh=0x10c0f300, valid=1 es:s=0x0017, dl=0x00003fff, dh=0x10c0f300, valid=1 fs:s=0x0017, dl=0x00003fff, dh=0x10c0f300, valid=1 gs:s=0x0017, dl=0x00003fff, dh=0x10c0f300, valid=1 ldtr:s=0x0068, dl=0xa2d00068, dh=0x000082fa, valid=1 tr:s=0x0060, dl=0xa2e80068, dh=0x00008bfa, valid=1 gdtr:base=0x00005cb8, limit=0x7ff idtr:base=0x000054b8, limit=0x7ff 可以看到 ldtr 的值是 0x0068=0000000001101000（二进制），表示 LDT 表存放在 GDT 表的 1101（二进制）=13（十进制）号位置（每位数据的意义参考后文叙述的段选择子）。\n而 GDT 的位置已经由 gdtr 明确给出，在物理地址的 0x00005cb8。\n用 xp /32w 0x00005cb8 查看从该地址开始，32 个字的内容，及 GDT 表的前 16 项，如下：\n1 2 3 4 5 6 7 8 9 10 xp /32w 0x00005cb8 [bochs]: 0x00005cb8 : 0x00000000 0x00000000 0x00000fff 0x00c09a00 0x00005cc8 : 0x00000fff 0x00c09300 0x00000000 0x00000000 0x00005cd8 : 0xa4280068 0x00008901 0xa4100068 0x00008201 0x00005ce8 : 0xf2e80068 0x000089ff 0xf2d00068 0x000082ff 0x00005cf8 : 0xd2e80068 0x000089ff 0xd2d00068 0x000082ff 0x00005d08 : 0x12e80068 0x000089fc 0x12d00068 0x000082fc 0x00005d18 : 0xa2e80068 0x00008bfa 0xa2d00068 0x000082fa 0x00005d28 : 0xc2e80068 0x000089f8 0xc2d00068 0x000082f8 GDT 表中的每一项占 64 位（8 个字节），所以我们要查找的项的地址是 0x00005cb8+13*8。\n输入 xp /2w 0x00005cb8+13*8，得到：\n1 2 3 xp /2w 0x00005cb8+13*8 [bochs]: 0x00005d20 : 0xa2d00068 0x000082fa 上两步看到的数值可能和这里给出的示例不一致，这是很正常的。如果想确认是否准确，就看 sreg 输出中，ldtr 所在行里，dl 和 dh 的值，它们是 Bochs 的调试器自动计算出的，你寻找到的必须和它们一致。\n“0xa2d00068 0x000082fa” 将其中的加粗数字组合为“0x00faa2d0”，这就是 LDT 表的物理地址（为什么这么组合，参考后文介绍的段描述符）。\nxp /8w 0x00faa2d0，得到：\n1 2 3 4 xp /8w 0x00faa2d0 [bochs]: 0x00faa2d0 : 0x00000000 0x00000000 0x00000002 0x10c0fa00 0x00faa2e0 : 0x00003fff 0x10c0f300 0x00000000 0x00fab000 这就是 LDT 表的前 4 项内容了。\n4.4 段描述符 在保护模式下，段寄存器有另一个名字，叫段选择子，因为它保存的信息主要是该段在段表里索引值，用这个索引值可以从段表中“选择”出相应的段描述符。\n先看看 ds 选择子的内容，还是用 sreg 命令：\n1 2 3 4 5 6 7 8 9 10 11 sreg cs:s=0x000f, dl=0x00000002, dh=0x10c0fa00, valid=1 ds:s=0x0017, dl=0x00003fff, dh=0x10c0f300, valid=3 ss:s=0x0017, dl=0x00003fff, dh=0x10c0f300, valid=1 es:s=0x0017, dl=0x00003fff, dh=0x10c0f300, valid=1 fs:s=0x0017, dl=0x00003fff, dh=0x10c0f300, valid=1 gs:s=0x0017, dl=0x00003fff, dh=0x10c0f300, valid=1 ldtr:s=0x0068, dl=0xa2d00068, dh=0x000082fa, valid=1 tr:s=0x0060, dl=0xa2e80068, dh=0x00008bfa, valid=1 gdtr:base=0x00005cb8, limit=0x7ff idtr:base=0x000054b8, limit=0x7ff 可以看到，ds 的值是 0x0017。段选择子是一个 16 位寄存器，它各位的含义如下图：\n图 2 段选择子的结构\n其中 RPL 是请求特权级，当访问一个段时，处理器要检查 RPL 和 CPL（放在 cs 的位 0 和位 1 中，用来表示当前代码的特权级），即使程序有足够的特权级（CPL）来访问一个段，但如果 RPL（如放在 ds 中，表示请求数据段）的特权级不足，则仍然不能访问，即如果 RPL 的数值大于 CPL（数值越大，权限越小），则用 RPL 的值覆盖 CPL 的值。\n而段选择子中的 TI 是表指示标记，如果 TI=0，则表示段描述符（段的详细信息）在 GDT（全局描述符表）中，即去 GDT 中去查；而 TI=1，则去 LDT（局部描述符表）中去查。\n看看上面的 ds，0x0017=0000000000010111（二进制），所以 RPL=11，可见是在最低的特权级（因为在应用程序中执行），TI=1，表示查找 LDT 表，索引值为 10（二进制）= 2（十进制），表示找 LDT 表中的第 3 个段描述符（从 0 开始编号）。\nLDT 和 GDT 的结构一样，每项占 8 个字节。所以第 3 项 0x00003fff 0x10c0f300（上一步骤的最后一个输出结果中） 就是搜寻好久的 ds 的段描述符了。\n用 sreg 输出中 ds 所在行的 dl 和 dh 值可以验证找到的描述符是否正确。\n接下来看看段描述符里面放置的是什么内容：\n图 3 段描述符的结构\n可以看到，段描述符是一个 64 位二进制的数，存放了段基址和段限长等重要的数据。其中位 P（Present）是段是否存在的标记；位 S 用来表示是系统段描述符（S=0）还是代码或数据段描述符（S=1）；四位 TYPE 用来表示段的类型，如数据段、代码段、可读、可写等；DPL 是段的权限，和 CPL、RPL 对应使用；位 G 是粒度，G=0 表示段限长以位为单位，G=1 表示段限长以 4KB 为单位；其他内容就不详细解释了。\n4.5 段基址和线性地址 费了很大的劲，实际上我们需要的只有段基址一项数据，即段描述符 “0x00003fff 0x10c0f300” 中加粗部分组合成的 “0x10000000”。这就是 ds 段在线性地址空间中的起始地址。用同样的方法也可以算算其它段的基址，都是这个数。\n段基址+段内偏移，就是线性地址了。所以 ds:0x3004 的线性地址就是：\n1 0x10000000 + 0x3004 = 0x10003004 用 calc ds:0x3004 命令可以验证这个结果。\n4.6 页表 从线性地址计算物理地址，需要查找页表。线性地址变成物理地址的过程如下：\n图 4 页表工作原理\n线性地址变成物理地址\n首先需要算出线性地址中的页目录号、页表号和页内偏移，它们分别对应了 32 位线性地址的 10 位 + 10 位 + 12 位，所以==0x10003004 的页目录号是 64，页号 3，页内偏移是 4==。\nIA-32 下，页目录表的位置由 CR3 寄存器指引。“creg”命令可以看到：\n1 2 3 4 5 6 CR0=0x8000001b: PG cd nw ac wp ne ET TS em MP PE CR2=page fault laddr=0x10002f68 CR3=0x00000000 PCD=page-level cache disable=0 PWT=page-level writes transparent=0 CR4=0x00000000: osxmmexcpt osfxsr pce pge mce pae pse de tsd pvi vme 说明页目录表的基址为 0。看看其内容，“xp /68w 0”：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 0x00000000 : 0x00001027 0x00002007 0x00003007 0x00004027 0x00000010 : 0x00000000 0x00024764 0x00000000 0x00000000 0x00000020 : 0x00000000 0x00000000 0x00000000 0x00000000 0x00000030 : 0x00000000 0x00000000 0x00000000 0x00000000 0x00000040 : 0x00ffe027 0x00000000 0x00000000 0x00000000 0x00000050 : 0x00000000 0x00000000 0x00000000 0x00000000 0x00000060 : 0x00000000 0x00000000 0x00000000 0x00000000 0x00000070 : 0x00000000 0x00000000 0x00000000 0x00000000 0x00000080 : 0x00ff3027 0x00000000 0x00000000 0x00000000 0x00000090 : 0x00000000 0x00000000 0x00000000 0x00000000 0x000000a0 : 0x00000000 0x00000000 0x00000000 0x00000000 0x000000b0 : 0x00000000 0x00000000 0x00000000 0x00ffb027 0x000000c0 : 0x00ff6027 0x00000000 0x00000000 0x00000000 0x000000d0 : 0x00000000 0x00000000 0x00000000 0x00000000 0x000000e0 : 0x00000000 0x00000000 0x00000000 0x00000000 0x000000f0 : 0x00000000 0x00000000 0x00000000 0x00ffa027 0x00000100 : 0x00faa027 0x00000000 0x00000000 0x00000000 页目录表和页表中的内容很简单，是 1024 个 32 位（正好是 4K）数。这 32 位中前 20 位是物理页框号，后面是一些属性信息（其中最重要的是最后一位 P）。其中第 65 个页目录项就是我们要找的内容，用“xp /w 0+64*4”查看：\n1 0x00000100 : 0x00faa027 其中的 027 是属性，显然 P=1，其他属性实验者自己分析吧。页表所在物理页框号为 0x00faa，即页表在物理内存的 0x00faa000 位置。从该位置开始查找 3 号页表项，得到（xp /w 0x00faa000+3*4）：\n1 0x00faa00c : 0x00fa7067 其中 067 是属性，显然 P=1，应该是这样。\n4.7 物理地址 最终结果马上就要出现了！\n线性地址 0x10003004 对应的物理页框号为 0x00fa7，和页内偏移 0x004 接到一起，得到 0x00fa7004，这就是变量 i 的物理地址。可以通过两种方法验证。\n第一种方法是用命令 page 0x10003004，可以得到信息：\n1 linear page 0x10003000 maps to physical page 0x00fa7000 第二种方法是用命令 xp /w 0x00fa7004，可以看到：\n1 0x00fa7004 : 0x12345678 这个数值确实是 test.c 中 i 的初值。\n现在，通过直接修改内存来改变 i 的值为 0，命令是： setpmem 0x00fa7004 4 0，表示从 0x00fa7004 地址开始的 4 个字节都设为 0。然后再用“c”命令继续 Bochs 的运行，可以看到 test 退出了，说明 i 的修改成功了，此项实验结束。\n4.8 在 Linux 0.11 中实现共享内存 （1）Linux 中的共享内存 Linux 支持两种方式的共享内存。一种方式是 shm_open()、mmap() 和 shm_unlink() 的组合；另一种方式是 shmget()、shmat() 和 shmdt() 的组合。本实验建议使用后一种方式。\n这些系统调用的详情，请查阅 man 及相关资料。\n特别提醒：没有父子关系的进程之间进行共享内存，shmget() 的第一个参数 key 不要用 IPC_PRIVATE，否则无法共享。用什么数字可视心情而定。\n（2）获得空闲物理页面 实验者需要考虑如何实现页面共享。首先看一下 Linux 0.11 如何操作页面，如何管理进程地址空间。\n在 kernel/fork.c 文件中有：\n1 2 3 4 5 6 7 8 int copy_process(…) { struct task_struct *p; p = (struct task_struct *) get_free_page(); if (!p) return -EAGAIN; // …… } 函数 get_free_page() 用来获得一个空闲物理页面，在 mm/memory.c 文件中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 unsigned long get_free_page(void) { register unsigned long __res asm(\"ax\"); __asm__(\"std ; repne ; scasb\\n\\t\" \"jne 1f\\n\\t\" \"movb $1,1(%%edi)\\n\\t\" // 页面数*4KB=相对页面起始地址 \"sall $12,%%ecx\\n\\t\" // 在加上低端的内存地址，得到的是物理起始地址 \"addl %2,%%ecx\\n\\t\" \"movl %%ecx,%%edx\\n\\t\" \"movl $1024,%%ecx\\n\\t\" \"leal 4092(%%edx),%%edi\\n\\t\" \"rep ; stosl\\n\\t\" //edx赋给eax，eax返回了物理起始地址 \"movl %%edx,%%eax\\n\" \"1:\" :\"=a\" (__res) :\"0\" (0),\"i\" (LOW_MEM),\"c\" (PAGING_PAGES), \"D\" (mem_map+PAGING_PAGES-1):\"di\",\"cx\",\"dx\"); return __res; } static unsigned char mem_map [ PAGING_PAGES ] = {0,}; 显然 get_free_page 函数就是在 mem_map 位图中寻找值为 0 的项（空闲页面），该函数返回的是该页面的起始物理地址。\n（3）地址映射 有了空闲的物理页面，接下来需要完成线性地址和物理页面的映射，Linux 0.11 中也有这样的代码，看看 mm/memory.c 中的 do_no_page(unsigned long address)，该函数用来处理线性地址 address 对应的物理页面无效的情况（即缺页中断），do_no_page 函数中调用一个重要的函数 get_empty_page(address)，其中有：\n1 2 3 4 5 // 函数 get_empty_page(address) unsigned long tmp=get_free_page(); // 建立线性地址和物理地址的映射 put_page(tmp, address); 显然这两条语句就用来获得空闲物理页面，然后填写线性地址 address 对应的页目录和页表。\n（4）寻找空闲的虚拟地址空间 有了空闲物理页面，也有了建立线性地址和物理页面的映射，但要完成本实验还需要能获得一段空闲的虚拟地址空闲。\n要从数据段中划出一段空间，首先需要了解进程数据段空间的分布，而这个分布显然是由 exec 系统调用决定的，所以要详细看一看 exec 的核心代码，do_execve（在文件 fs/exec.c 中）。\n在函数 do_execve() 中，修改数据段（当然是修改 LDT）的地方是 change_ldt，函数 change_ldt 实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 static unsigned long change_ldt(unsigned long text_size,unsigned long * page) { /*其中text_size是代码段长度，从可执行文件的头部取出，page为参数和环境页*/ unsigned long code_limit,data_limit,code_base,data_base; int i; code_limit = text_size+PAGE_SIZE -1; code_limit \u0026= 0xFFFFF000; //code_limit为代码段限长=text_size对应的页数（向上取整） data_limit = 0x4000000; //数据段限长64MB code_base = get_base(current-\u003eldt[1]); data_base = code_base; // 数据段基址 = 代码段基址 set_base(current-\u003eldt[1],code_base); set_limit(current-\u003eldt[1],code_limit); set_base(current-\u003eldt[2],data_base); set_limit(current-\u003eldt[2],data_limit); __asm__(\"pushl $0x17\\n\\tpop %%fs\":: ); // 从数据段的末尾开始 data_base += data_limit; // 向前处理 for (i=MAX_ARG_PAGES-1 ; i\u003e=0 ; i--) { // 一次处理一页 data_base -= PAGE_SIZE; // 建立线性地址到物理页的映射 if (page[i]) put_page(page[i],data_base); } // 返回段界限 return data_limit; } 仔细分析过函数 change_ldt，想必实验者已经知道该如何从数据段中找到一页空闲的线性地址。《注释》中的图 13-6 也能给你很大帮助。\n4.9 在同一终端中同时运行两个程序 Linux 的 shell 有后台运行程序的功能。只要在命令的最后输入一个 \u0026，命令就会进入后台运行，前台马上回到提示符，进而能运行下一个命令，例如：\n1 2 $ sudo ./producer \u0026 $ sudo ./consumer 当运行 ./consumer 的时候，producer 正在后台运行。\n5.实验步骤 1.创建test.c 挂载hdc文件系统，然后在usr/root目录内增加test.c文件用于测试地址映射，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include int i = 0x12345678; int main(void) { printf(\"The logical/virtual address of i is 0x%08x\", \u0026i); fflush(stdout); while (i) ; return 0; } 代码添加过程截图如下： 2.寻找物理地址 首先进入Linux-0.11目录内make编译系统，然后回退至oslab目录内运行系统，再使用下述命令编译运行test.c文件\n1 2 gcc -o test test.c ./test 运行效果如下图所示： 此时会进入在test.c内的while死循环，然后ctrl+c暂停bochs。 此时需要让Linux-0.11的test跳出死循环，所以需要找到逻辑地址ds:0X00003004对应的物理地址，将它的内容更改为0。 在终端中输入sreg，得到gdtr的基址值为0x00005cb8，ldtr为0x0068即0000 0000 0110 1000 b，可知索引为1101b即13，TI位为0，即GDT中的第13项为LDT的段描述符。 输入xp /2w 0x00005cb8+13*8得到LDT段描述符，可以得到LDT的基址为0x00f9a2d0 ds段选择子为0x0017 =\u003e 0000 0000 0001 0111 b，可知索引为10b即2，TI位为1，即LDT中的第2项为ds的段描述符，输入xp/2w 0x00f9a2d0+2*8得到ds段描述符，可以知道ds的基址为0x10000000，所以0x3004对应的线性地址为0x10000000+0x3004=0x10003004。输入xp /w 64*4获取页目录项，可知页表基地址为0x00fa6000。 输入xp /w 0x00fa6000+3*4得到物理基址为0xfa5000。 输入xp /w 0xfa5000+4得到的内容即test.c中的变量的值，输入setpmem 0xfa5004 4 0将它设为0。 然后在终端内输入c继续让系统运行，发现test而已跳出循环。\n3.添加系统调用 在unistd.h中增加下面的代码：\n1 2 3 4 5 6 7 8 9 10 11 #define SHM_SIZE 64 typedef struct shm_ds { unsigned int key; unsigned int size; unsigned long page; }shm_ds; int sys_shmget(unsigned int key,size_t size); void * sys_shmat(int shmid); 然后增加两个系统调用\n1 2 #define __NR_shmget 76 #define __NR_shmat 77 4.修改sys.h文件 在此文件中增加函数声明：\n1 2 extern int sys_shmget(); extern int sys_shmat(); 在system_call.s中把nr_system_calls改为78\n5.增加shm.c shm.c的位置在kernel目录下 代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 #define __LIBRARY__ #include #include #include #include #include static shm_ds shm_list[SHM_SIZE] = {{0,0,0}}; int sys_shmget(unsigned int key, size_t size) { int i; void *page; if(size \u003e PAGE_SIZE) return -EINVAL; page = get_free_page(); if(!page) return -ENOMEM; printk(\"shmget get memory's address is 0x%08x\\n\",page); for(i=0; i\u003cSHM_SIZE; i++) { if(shm_list[i].key == key) return i; } for(i=0; i\u003cSHM_SIZE; i++) { if(shm_list[i].key == 0) { shm_list[i].page = page; shm_list[i].key = key; shm_list[i].size = size; return i; } } return -1; } void * sys_shmat(int shmid) { int i; unsigned long data_base, brk; if(shmid \u003c 0 || SHM_SIZE \u003c= shmid || shm_list[shmid].page==0 || shm_list[shmid].key \u003c= 0) return (void *)-EINVAL; data_base = get_base(current-\u003eldt[2]); printk(\"current's data_base = 0x%08x,new page = 0x%08x\\n\",data_base,shm_list[shmid].page); brk = current-\u003ebrk + data_base; current-\u003ebrk += PAGE_SIZE; if(put_page(shm_list[shmid].page, brk) == 0) return (void *)-ENOMEM; return (void *)(current-\u003ebrk - PAGE_SIZE); } 然后修改Kernel下的Makefile文件\n1 2 3 4 5 ### Dependencies: sem.s sem.o: sem.c ../include/linux/sem.h ../include/linux/kernel.h \\ ../include/unistd.h shm.s shm.o:shm.c ../include/unistd.h ../include/linux/kernel.h ../include/linux/sched.h ../include/linux/mm.h ../include/errno.h ... 修改截图如下： 6.编写消费者和生产者程序 在hdc的root目录下增加producer.c和consumer.c文件，这两个文件的代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 /*producer*/ #define __LIBRARY__ #include #include #include #include #include #include _syscall2(sem_t *,sem_open,const char *,name,int,value); _syscall1(int,sem_post,sem_t *,sem); _syscall1(int,sem_wait,sem_t *,sem); _syscall1(int, shmat, int, shmid); _syscall2(int, shmget, unsigned int, key, size_t, size); #define PRODUCE_NUM 200 #define BUFFER_SIZE 10 #define SHM_KEY 2018 int main(int argc, char* argv[]) { sem_t *Empty,*Full,*Mutex; int i, shm_id, location=0; int *p; Empty = sem_open(\"Empty\", BUFFER_SIZE); Full = sem_open(\"Full\", 0); Mutex = sem_open(\"Mutex\", 1); if((shm_id = shmget(SHM_KEY, BUFFER_SIZE*sizeof(int))) \u003c 0) printf(\"shmget failed!\"); if((p = (int * )shmat(shm_id)) \u003c 0) printf(\"shmat error!\"); for(i=0; i\u003cPRODUCE_NUM; i++) { sem_wait(Empty); sem_wait(Mutex); p[location] = i; sem_post(Mutex); sem_post(Full); location = (location+1) % BUFFER_SIZE; } return 0; } consumer.c代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 /*consumer*/ #define __LIBRARY__ #include #include #include #include #include #include _syscall2(sem_t *,sem_open,const char *,name,int,value); _syscall1(int,sem_post,sem_t *,sem); _syscall1(int,sem_wait,sem_t *,sem); _syscall1(int,sem_unlink,const char*,name); _syscall1(int, shmat, int, shmid); _syscall2(int, shmget, unsigned int, key, size_t, size); #define PRODUCE_NUM 200 #define BUFFER_SIZE 10 #define SHM_KEY 2018 int main(int argc, char* argv[]) { sem_t *Empty,*Full,*Mutex; int used = 0, shm_id,location = 0; int *p; Empty = sem_open(\"Empty\", BUFFER_SIZE); Full = sem_open(\"Full\", 0); Mutex = sem_open(\"Mutex\", 1); if((shm_id = shmget(SHM_KEY, BUFFER_SIZE*sizeof(int))) \u003c 0) printf(\"shmget failed!\\n\"); if((p = (int * )shmat(shm_id)) \u003c 0) printf(\"link error!\\n\"); while(1) { sem_wait(Full); sem_wait(Mutex); printf(\"pid %d:\\tconsumer consumes item %d\\n\", getpid(), p[location]); fflush(stdout); sem_post(Mutex); sem_post(Empty); location = (location+1) % BUFFER_SIZE; if(++used == PRODUCE_NUM) break; } sem_unlink(\"Mutex\"); sem_unlink(\"Full\"); sem_unlink(\"Empty\"); return 0; } 7.运行验证 运行bochs，输入：\n1 2 gcc -o pro producer.c gcc -o con consumer.c 编译这两个程序， 然后输入\n1 2 pro \u003e proOutput \u0026 con \u003e conOutput \u0026 来同时运行这两个程序，并将结果保存到proOutput和conOutput中。 最后输入sync,结果如下 关闭linux-0.11回到ubunt终端，输入sudo less hdc/usr/root/conOutput查看结果如下： ",
  "wordCount" : "8122",
  "inLanguage": "zh",
  "datePublished": "2022-05-25T00:00:00Z",
  "dateModified": "2022-05-25T00:00:00Z",
  "author":[{
    "@type": "Person",
    "name": "chance7bin"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://chance7bin.github.io/posts/basic/os-lab/%E5%AE%9E%E9%AA%8C7-%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E4%B8%8E%E5%85%B1%E4%BA%AB/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Binb's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://chance7bin.github.io/img/%E7%BE%8E%E9%98%9F.jpg"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://chance7bin.github.io/" accesskey="h" title="Binb&#39;s Blog (Alt + H)">
                <img src="https://chance7bin.github.io/img/%E7%BE%8E%E9%98%9F.jpg" alt="" aria-label="logo"
                    height="35">Binb&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://chance7bin.github.io/search" title="🔍搜索 (Alt &#43; /)" accesskey=/>
                    <span>🔍搜索</span>
                </a>
            </li>
            <li>
                <a href="https://chance7bin.github.io/" title="🏠 主页">
                    <span>🏠 主页</span>
                </a>
            </li>
            <li>
                <a href="https://chance7bin.github.io/archives/" title="⏱️ 时间轴">
                    <span>⏱️ 时间轴</span>
                </a>
            </li>
            <li>
                <a href="https://chance7bin.github.io/posts" title="📚 文章">
                    <span>📚 文章</span>
                </a>
            </li>
            <li>
                <a href="https://chance7bin.github.io/tags" title="🔖 标签">
                    <span>🔖 标签</span>
                </a>
            </li>
            <li>
                <a href="https://github.com/chance7bin" title="GitHub">
                    <span>GitHub</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://chance7bin.github.io/">🏠 主页</a>&nbsp;»&nbsp;<a href="https://chance7bin.github.io/posts/">📚 文章</a>&nbsp;»&nbsp;<a href="https://chance7bin.github.io/posts/basic/">📕 计算机基础</a>&nbsp;»&nbsp;<a href="https://chance7bin.github.io/posts/basic/os-lab/">hit-oslab</a></div>
    <h1 class="post-title">
      实验7 地址映射与共享
    </h1>
    <div class="post-meta">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css">


<style>
    i[id*="post_meta_style"] {
        display: flex;
        align-items: center;
        margin: 0 0 10px 0;
    }

    .parent-post-meta {
        display: flex;
        flex-wrap: wrap;
        opacity: 0.8;
    }
</style>

<span class="parent-post-meta">
    <span id="post_meta_style_1">
        <span class="fa fa-calendar-check-o"></span>
        <span>2022-05-25
            &nbsp;&nbsp;
        </span>
    </span>
    
    
    
    
    
    
    
    <span id="post_meta_style_3">
        <span class="fa fa-file-word-o"></span>
        <span>8122字
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_4">
        <span class="fa fa-clock-o"></span>
        <span>17分钟
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_5">
        <span class="fa fa-user-o"></span>
        <span>chance7bin
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_6">
        <span class="fa fa-tags" style="opacity: 0.8"></span>
        <span>
            <span class="post-tags-meta">
                <a href="https://chance7bin.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="color: var(--secondary)!important;">操作系统</a>
                &nbsp;<a href="https://chance7bin.github.io/tags/%E5%AE%9E%E9%AA%8C/" style="color: var(--secondary)!important;">实验</a>
            </span>
        </span>
    </span>

    
</span>


      
      
      
      
      
      
      
          
          
          
              
              
              
              
          
      
    </div>
  </header>
   <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">目录</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#1%e5%ae%9e%e9%aa%8c%e7%9b%ae%e7%9a%84" aria-label="1.实验目的">1.实验目的</a></li>
                    <li>
                        <a href="#2%e5%ae%9e%e9%aa%8c%e5%86%85%e5%ae%b9" aria-label="2.实验内容">2.实验内容</a><ul>
                            
                    <li>
                        <a href="#21-%e8%b7%9f%e8%b8%aa%e5%9c%b0%e5%9d%80%e7%bf%bb%e8%af%91%e8%bf%87%e7%a8%8b" aria-label="2.1 跟踪地址翻译过程">2.1 跟踪地址翻译过程</a></li>
                    <li>
                        <a href="#22-%e5%9f%ba%e4%ba%8e%e5%85%b1%e4%ba%ab%e5%86%85%e5%ad%98%e7%9a%84%e7%94%9f%e4%ba%a7%e8%80%85%e6%b6%88%e8%b4%b9%e8%80%85%e7%a8%8b%e5%ba%8f" aria-label="2.2 基于共享内存的生产者—消费者程序">2.2 基于共享内存的生产者—消费者程序</a></li>
                    <li>
                        <a href="#23-%e5%85%b1%e4%ba%ab%e5%86%85%e5%ad%98%e7%9a%84%e5%ae%9e%e7%8e%b0" aria-label="2.3 共享内存的实现">2.3 共享内存的实现</a></li></ul>
                    </li>
                    <li>
                        <a href="#3%e5%ae%9e%e9%aa%8c%e6%8a%a5%e5%91%8a" aria-label="3.实验报告">3.实验报告</a></li>
                    <li>
                        <a href="#4%e5%ae%9e%e9%aa%8c%e6%8f%90%e7%a4%ba" aria-label="4.实验提示">4.实验提示</a><ul>
                            
                    <li>
                        <a href="#41-ia-32-%e7%9a%84%e5%9c%b0%e5%9d%80%e7%bf%bb%e8%af%91%e8%bf%87%e7%a8%8b" aria-label="4.1 IA-32 的地址翻译过程">4.1 IA-32 的地址翻译过程</a></li>
                    <li>
                        <a href="#42-%e7%94%a8-bochs-%e6%b1%87%e7%bc%96%e7%ba%a7%e8%b0%83%e8%af%95%e5%8a%9f%e8%83%bd%e8%bf%9b%e8%a1%8c%e4%ba%ba%e5%b7%a5%e5%9c%b0%e5%9d%80%e7%bf%bb%e8%af%91" aria-label="4.2 用 Bochs 汇编级调试功能进行人工地址翻译">4.2 用 Bochs 汇编级调试功能进行人工地址翻译</a></li>
                    <li>
                        <a href="#1%e5%87%86%e5%a4%87" aria-label="（1）准备">（1）准备</a></li>
                    <li>
                        <a href="#2%e6%9a%82%e5%81%9c" aria-label="（2）暂停">（2）暂停</a></li>
                    <li>
                        <a href="#43-%e6%ae%b5%e8%a1%a8" aria-label="4.3 段表">4.3 段表</a></li>
                    <li>
                        <a href="#44-%e6%ae%b5%e6%8f%8f%e8%bf%b0%e7%ac%a6" aria-label="4.4 段描述符">4.4 段描述符</a></li>
                    <li>
                        <a href="#45-%e6%ae%b5%e5%9f%ba%e5%9d%80%e5%92%8c%e7%ba%bf%e6%80%a7%e5%9c%b0%e5%9d%80" aria-label="4.5 段基址和线性地址">4.5 段基址和线性地址</a></li>
                    <li>
                        <a href="#46-%e9%a1%b5%e8%a1%a8" aria-label="4.6 页表">4.6 页表</a></li>
                    <li>
                        <a href="#47-%e7%89%a9%e7%90%86%e5%9c%b0%e5%9d%80" aria-label="4.7 物理地址">4.7 物理地址</a></li>
                    <li>
                        <a href="#48-%e5%9c%a8-linux-011-%e4%b8%ad%e5%ae%9e%e7%8e%b0%e5%85%b1%e4%ba%ab%e5%86%85%e5%ad%98" aria-label="4.8 在 Linux 0.11 中实现共享内存">4.8 在 Linux 0.11 中实现共享内存</a><ul>
                            
                    <li>
                        <a href="#1linux-%e4%b8%ad%e7%9a%84%e5%85%b1%e4%ba%ab%e5%86%85%e5%ad%98" aria-label="（1）Linux 中的共享内存">（1）Linux 中的共享内存</a></li>
                    <li>
                        <a href="#2%e8%8e%b7%e5%be%97%e7%a9%ba%e9%97%b2%e7%89%a9%e7%90%86%e9%a1%b5%e9%9d%a2" aria-label="（2）获得空闲物理页面">（2）获得空闲物理页面</a></li>
                    <li>
                        <a href="#3%e5%9c%b0%e5%9d%80%e6%98%a0%e5%b0%84" aria-label="（3）地址映射">（3）地址映射</a></li>
                    <li>
                        <a href="#4%e5%af%bb%e6%89%be%e7%a9%ba%e9%97%b2%e7%9a%84%e8%99%9a%e6%8b%9f%e5%9c%b0%e5%9d%80%e7%a9%ba%e9%97%b4" aria-label="（4）寻找空闲的虚拟地址空间">（4）寻找空闲的虚拟地址空间</a></li></ul>
                    </li>
                    <li>
                        <a href="#49-%e5%9c%a8%e5%90%8c%e4%b8%80%e7%bb%88%e7%ab%af%e4%b8%ad%e5%90%8c%e6%97%b6%e8%bf%90%e8%a1%8c%e4%b8%a4%e4%b8%aa%e7%a8%8b%e5%ba%8f" aria-label="4.9 在同一终端中同时运行两个程序">4.9 在同一终端中同时运行两个程序</a></li></ul>
                    </li>
                    <li>
                        <a href="#5%e5%ae%9e%e9%aa%8c%e6%ad%a5%e9%aa%a4" aria-label="5.实验步骤">5.实验步骤</a><ul>
                            
                    <li>
                        <a href="#1%e5%88%9b%e5%bb%batestc" aria-label="1.创建test.c">1.创建test.c</a></li>
                    <li>
                        <a href="#2%e5%af%bb%e6%89%be%e7%89%a9%e7%90%86%e5%9c%b0%e5%9d%80" aria-label="2.寻找物理地址">2.寻找物理地址</a></li>
                    <li>
                        <a href="#3%e6%b7%bb%e5%8a%a0%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8" aria-label="3.添加系统调用">3.添加系统调用</a></li>
                    <li>
                        <a href="#4%e4%bf%ae%e6%94%b9sysh%e6%96%87%e4%bb%b6" aria-label="4.修改sys.h文件">4.修改sys.h文件</a></li>
                    <li>
                        <a href="#5%e5%a2%9e%e5%8a%a0shmc" aria-label="5.增加shm.c">5.增加shm.c</a></li>
                    <li>
                        <a href="#6%e7%bc%96%e5%86%99%e6%b6%88%e8%b4%b9%e8%80%85%e5%92%8c%e7%94%9f%e4%ba%a7%e8%80%85%e7%a8%8b%e5%ba%8f" aria-label="6.编写消费者和生产者程序">6.编写消费者和生产者程序</a></li>
                    <li>
                        <a href="#7%e8%bf%90%e8%a1%8c%e9%aa%8c%e8%af%81" aria-label="7.运行验证">7.运行验证</a>
                    </li>
                </ul>
                </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>
  <div class="post-content"><h2 id="1实验目的">1.实验目的<a hidden class="anchor" aria-hidden="true" href="#1实验目的">#</a></h2>
<ul>
<li>深入理解操作系统的段、页式内存管理，深入理解段表、页表、逻辑地址、线性地址、物理地址等概念；</li>
<li>实践段、页式内存管理的地址映射过程；</li>
<li>编程实现段、页式内存管理上的内存共享，从而深入理解操作系统的内存管理。</li>
</ul>
<h2 id="2实验内容">2.实验内容<a hidden class="anchor" aria-hidden="true" href="#2实验内容">#</a></h2>
<p>本次实验的基本内容是：</p>
<ul>
<li>用 Bochs 调试工具跟踪 Linux 0.11 的地址翻译（地址映射）过程，了解 IA-32 和 Linux 0.11 的内存管理机制；</li>
<li>在 Ubuntu 上编写多进程的生产者—消费者程序，用共享内存做缓冲区；</li>
<li>在信号量实验的基础上，为 Linux 0.11 增加共享内存功能，并将生产者—消费者程序移植到 Linux 0.11。</li>
</ul>
<h3 id="21-跟踪地址翻译过程">2.1 跟踪地址翻译过程<a hidden class="anchor" aria-hidden="true" href="#21-跟踪地址翻译过程">#</a></h3>
<p>首先以汇编级调试的方式启动 Bochs，引导 Linux 0.11，在 0.11 下编译和运行 test.c。它是一个无限循环的程序，永远不会主动退出。然后在调试器中通过查看各项系统参数，从逻辑地址、LDT 表、GDT 表、线性地址到页表，计算出变量 <code>i</code> 的物理地址。最后通过直接修改物理内存的方式让 test.c 退出运行。</p>
<p>test.c 的代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mh">0x12345678</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;The logical/virtual address of i is 0x%08x&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="22-基于共享内存的生产者消费者程序">2.2 基于共享内存的生产者—消费者程序<a hidden class="anchor" aria-hidden="true" href="#22-基于共享内存的生产者消费者程序">#</a></h3>
<p>本项实验在 Ubuntu 下完成，与信号量实验中的 <code>pc.c</code> 的功能要求基本一致，仅有两点不同：</p>
<ul>
<li>不用文件做缓冲区，而是使用共享内存；</li>
<li>生产者和消费者分别是不同的程序。生产者是 producer.c，消费者是 consumer.c。两个程序都是单进程的，通过信号量和缓冲区进行通信。</li>
</ul>
<p>Linux 下，可以通过 <code>shmget()</code> 和 <code>shmat()</code> 两个系统调用使用共享内存。</p>
<h3 id="23-共享内存的实现">2.3 共享内存的实现<a hidden class="anchor" aria-hidden="true" href="#23-共享内存的实现">#</a></h3>
<p>进程之间可以通过页共享进行通信，被共享的页叫做共享内存，结构如下图所示：</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012340284.bmp" alt="图片描述信息"  />
</p>
<p>图 1 进程间共享内存的结构</p>
<p>本部分实验内容是在 Linux 0.11 上实现上述页面共享，并将上一部分实现的 producer.c 和 consumer.c 移植过来，验证页面共享的有效性。</p>
<p>具体要求在 <code>mm/shm.c</code> 中实现 <code>shmget()</code> 和 <code>shmat()</code> 两个系统调用。它们能支持 <code>producer.c</code> 和 <code>consumer.c</code> 的运行即可，不需要完整地实现 POSIX 所规定的功能。</p>
<ul>
<li>shmget()</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">shmget</span><span class="p">(</span><span class="kt">key_t</span> <span class="n">key</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">shmflg</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>shmget()</code> 会新建/打开一页内存，并返回该页共享内存的 shmid（该块共享内存在操作系统内部的 id）。</p>
<p>所有使用同一块共享内存的进程都要使用相同的 key 参数。</p>
<p>如果 key 所对应的共享内存已经建立，则直接返回 <code>shmid</code>。如果 size 超过一页内存的大小，返回 <code>-1</code>，并置 <code>errno</code> 为 <code>EINVAL</code>。如果系统无空闲内存，返回 -1，并置 <code>errno</code> 为 <code>ENOMEM</code>。</p>
<p><code>shmflg</code> 参数可忽略。</p>
<ul>
<li>shmat()</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="o">*</span><span class="nf">shmat</span><span class="p">(</span><span class="kt">int</span> <span class="n">shmid</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">shmaddr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">shmflg</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>shmat()</code> 会将 <code>shmid</code> 指定的共享页面映射到当前进程的虚拟地址空间中，并将其首地址返回。</p>
<p>如果 <code>shmid</code> 非法，返回 <code>-1</code>，并置 <code>errno</code> 为 <code>EINVAL</code>。</p>
<p><code>shmaddr</code> 和 <code>shmflg</code> 参数可忽略。</p>
<h2 id="3实验报告">3.实验报告<a hidden class="anchor" aria-hidden="true" href="#3实验报告">#</a></h2>
<p>完成实验后，在实验报告中回答如下问题：</p>
<ul>
<li>对于地址映射实验部分，列出你认为最重要的那几步（不超过 4 步），并给出你获得的实验数据。</li>
<li>test.c 退出后，如果马上再运行一次，并再进行地址跟踪，你发现有哪些异同？为什么？</li>
</ul>
<h2 id="4实验提示">4.实验提示<a hidden class="anchor" aria-hidden="true" href="#4实验提示">#</a></h2>
<p>本次需要完成的内容：</p>
<ul>
<li>（1）用 Bochs 调试工具跟踪 Linux 0.11 的地址翻译（地址映射）过程，了解 IA-32 和 Linux 0.11 的内存管理机制；</li>
<li>（2）在 Ubuntu 上编写多进程的生产者—消费者程序，用共享内存做缓冲区；</li>
<li>（3）在信号量实验的基础上，为 Linux 0.11 增加共享内存功能，并将生产者—消费者程序移植到 Linux 0.11。</li>
</ul>
<h3 id="41-ia-32-的地址翻译过程">4.1 IA-32 的地址翻译过程<a hidden class="anchor" aria-hidden="true" href="#41-ia-32-的地址翻译过程">#</a></h3>
<p>Linux 0.11 完全遵循 IA-32（Intel Architecture 32-bit）架构进行地址翻译，Windows、后续版本的 Linux 以及一切在 IA-32 保护模式下运行的操作系统都遵循此架构。因为只有这样才能充分发挥 CPU 的 <code>MMU</code>（内存管理单元） 的功能。</p>
<p>关于此地址翻译过程的细节，请参考《注释》一书中的 5.3.1-5.3.4 节。</p>
<h3 id="42-用-bochs-汇编级调试功能进行人工地址翻译">4.2 用 Bochs 汇编级调试功能进行人工地址翻译<a hidden class="anchor" aria-hidden="true" href="#42-用-bochs-汇编级调试功能进行人工地址翻译">#</a></h3>
<p>此过程比较机械，基本不消耗脑细胞，做一下有很多好处。</p>
<p>==Bochs命令==</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">[内存操作]
</span></span><span class="line"><span class="cl">x  /nuf [addr]  显示线性地址的内容
</span></span><span class="line"><span class="cl">xp /nuf [addr]  显示物理地址的内容
</span></span><span class="line"><span class="cl">    n           显示的单元数
</span></span><span class="line"><span class="cl">    u           每个显示单元的大小，u可以是下列之一：
</span></span><span class="line"><span class="cl">                    b BYTE
</span></span><span class="line"><span class="cl">                    h WORD
</span></span><span class="line"><span class="cl">                    w DWORD
</span></span><span class="line"><span class="cl">                    g DWORD64
</span></span><span class="line"><span class="cl">                    注意: 这种命名法是按照GDB习惯的，而并不是按照inter的规范。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    f           显示格式，f可以是下列之一：
</span></span><span class="line"><span class="cl">                    x 按照十六进制显示
</span></span><span class="line"><span class="cl">                    d 十进制显示
</span></span><span class="line"><span class="cl">                    u 按照无符号十进制显示
</span></span><span class="line"><span class="cl">                    o 按照八进制显示
</span></span><span class="line"><span class="cl">                    t 按照二进制显示
</span></span><span class="line"><span class="cl">                    c 按照字符显示
</span></span><span class="line"><span class="cl">    n、f、u是可选参数，如果不指定，则u默认是w，f默认是x。如果前面使用过x或
</span></span><span class="line"><span class="cl">    者xp命令，会按照上一次的x或者xp命令所使用的值。n默认为1。addr 也是一个
</span></span><span class="line"><span class="cl">    可选参数，如果不指定，addr是0，如过前面使用过x或者xp命令，指定了n=i，
</span></span><span class="line"><span class="cl">    则再次执行时n默认为i+1。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">setpmem [addr] [size] [val]    设置物理内存某地址的内容。
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="1准备">（1）准备<a hidden class="anchor" aria-hidden="true" href="#1准备">#</a></h3>
<p>编译好 Linux 0.11 后，首先通过运行 <code>./dbg-asm</code> 启动调试器，此时 Bochs 的窗口处于黑屏状态</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012340288.png" alt="图片描述"  />
</p>
<p>而命令行窗口显示：</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012340294.png" alt="图片描述"  />
</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">========================================================================
</span></span><span class="line"><span class="cl">                       Bochs x86 Emulator 2.3.7
</span></span><span class="line"><span class="cl">               Build from CVS snapshot, on June 3, 2008
</span></span><span class="line"><span class="cl">========================================================================
</span></span><span class="line"><span class="cl">00000000000i[     ] reading configuration from ./bochs/bochsrc.bxrc
</span></span><span class="line"><span class="cl">00000000000i[     ] installing x module as the Bochs GUI
</span></span><span class="line"><span class="cl">00000000000i[     ] using log file ./bochsout.txt
</span></span><span class="line"><span class="cl">Next at t=0
</span></span><span class="line"><span class="cl">(0) [0xfffffff0] f000:fff0 (unk. ctxt): jmp far f000:e05b         ; ea5be000f0
</span></span><span class="line"><span class="cl">&lt;bochs:1&gt;_
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>Next at t=0</code> 表示下面的指令是 Bochs 启动后要执行的第一条软件指令。</p>
<p>单步跟踪进去就能看到 BIOS 的代码。不过这不是本实验需要的。直接输入命令 <code>c</code>，continue 程序的运行，Bochs 一如既往地启动了 Linux 0.11。</p>
<p>在 Linux 0.11 下输入（或拷入）test.c（代码在本实验的第 3 小节中），编译为 test，运行之，打印如下信息：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">The logical/virtual address of i is 0x00003004
</span></span></code></pre></td></tr></table>
</div>
</div><p>只要 test 不变，<code>0x00003004</code> 这个值在任何人的机器上都是一样的。即使在同一个机器上多次运行 test，也是一样的。</p>
<p>test 是一个死循环，只会不停占用 CPU，不会退出。</p>
<h3 id="2暂停">（2）暂停<a hidden class="anchor" aria-hidden="true" href="#2暂停">#</a></h3>
<p>当 test 运行的时候，在命令行窗口按 <code>Ctrl+c</code>，Bochs 会暂停运行，进入调试状态。绝大多数情况下都会停在 test 内，显示类似如下信息：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">(0) [0x00fc8031] 000f:00000031 (unk. ctxt): cmp dword ptr ds:0x3004, 0x00000000 ; 833d0430000000
</span></span></code></pre></td></tr></table>
</div>
</div><p>其中的 <code>000f</code> 如果是 <code>0008</code>，则说明中断在了内核里。那么就要 <code>c</code>，然后再 <code>ctrl+c</code>，直到变为 <code>000f</code> 为止。</p>
<p>如果显示的下一条指令不是 <code>cmp ...</code>（这里指语句以 <code>cmp</code> 开头），就用 <code>n</code> 命令单步运行几步，直到停在 <code>cmp ...</code>。</p>
<p>使用命令 <code>u /8</code>，显示从当前位置开始 8 条指令的反汇编代码，结构如下：</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012340299.png" alt="图片描述"  />
</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">&lt;bochs:3&gt; u /8
</span></span><span class="line"><span class="cl">10000063: (                    ): cmp dword ptr ds:0x3004, 0x00000000 ; 833d0430000000
</span></span><span class="line"><span class="cl">1000006a: (                    ): jz .+0x00000004           ; 7404
</span></span><span class="line"><span class="cl">1000006c: (                    ): jmp .+0xfffffff5          ; ebf5
</span></span><span class="line"><span class="cl">1000006e: (                    ): add byte ptr ds:[eax], al ; 0000
</span></span><span class="line"><span class="cl">10000070: (                    ): xor eax, eax              ; 31c0
</span></span><span class="line"><span class="cl">10000072: (                    ): jmp .+0x00000000          ; eb00
</span></span><span class="line"><span class="cl">10000074: (                    ): leave                     ; c9
</span></span><span class="line"><span class="cl">10000075: (                    ): ret                       ; c3
</span></span></code></pre></td></tr></table>
</div>
</div><p>这就是 test.c 中从 while 开始一直到 return 的汇编代码。变量 i 保存在 <code>ds:0x3004</code> 这个地址，并不停地和 0 进行比较，直到它为 0，才会跳出循环。</p>
<p>现在，开始寻找 <code>ds:0x3004</code> 对应的物理地址。</p>
<h3 id="43-段表">4.3 段表<a hidden class="anchor" aria-hidden="true" href="#43-段表">#</a></h3>
<p><code>ds:0x3004</code> 是虚拟地址，ds 表明这个地址属于 ds 段。首先要找到段表，然后通过 ds 的值在段表中找到 ds 段的具体信息，才能继续进行地址翻译。</p>
<p>每个在 IA-32 上运行的应用程序都有一个段表，叫 LDT，段的信息叫段描述符。</p>
<p>LDT 在哪里呢？ldtr 寄存器是线索的起点，通过它可以在 GDT（全局描述符表）中找到 LDT 的物理地址。</p>
<p>用 <code>sreg</code> 命令（是在调试窗口输入）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">&lt;bochs:4&gt; sreg
</span></span><span class="line"><span class="cl">cs:s=0x000f, dl=0x00000002, dh=0x10c0fa00, valid=1
</span></span><span class="line"><span class="cl">ds:s=0x0017, dl=0x00003fff, dh=0x10c0f300, valid=3
</span></span><span class="line"><span class="cl">ss:s=0x0017, dl=0x00003fff, dh=0x10c0f300, valid=1
</span></span><span class="line"><span class="cl">es:s=0x0017, dl=0x00003fff, dh=0x10c0f300, valid=1
</span></span><span class="line"><span class="cl">fs:s=0x0017, dl=0x00003fff, dh=0x10c0f300, valid=1
</span></span><span class="line"><span class="cl">gs:s=0x0017, dl=0x00003fff, dh=0x10c0f300, valid=1
</span></span><span class="line"><span class="cl">ldtr:s=0x0068, dl=0xa2d00068, dh=0x000082fa, valid=1
</span></span><span class="line"><span class="cl">tr:s=0x0060, dl=0xa2e80068, dh=0x00008bfa, valid=1
</span></span><span class="line"><span class="cl">gdtr:base=0x00005cb8, limit=0x7ff
</span></span><span class="line"><span class="cl">idtr:base=0x000054b8, limit=0x7ff
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到 ldtr 的值是 <code>0x0068=0000000001101000</code>（二进制），表示 LDT 表存放在 GDT 表的 1101（二进制）=13（十进制）号位置（每位数据的意义参考后文叙述的段选择子）。</p>
<p>而 GDT 的位置已经由 gdtr 明确给出，在物理地址的 <code>0x00005cb8</code>。</p>
<p>用 <code>xp /32w 0x00005cb8</code> 查看从该地址开始，32 个字的内容，及 GDT 表的前 16 项，如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">&lt;bochs:5&gt; xp /32w 0x00005cb8
</span></span><span class="line"><span class="cl">[bochs]:
</span></span><span class="line"><span class="cl">0x00005cb8 &lt;bogus+       0&gt;:    0x00000000    0x00000000    0x00000fff    0x00c09a00
</span></span><span class="line"><span class="cl">0x00005cc8 &lt;bogus+      16&gt;:    0x00000fff    0x00c09300    0x00000000    0x00000000
</span></span><span class="line"><span class="cl">0x00005cd8 &lt;bogus+      32&gt;:    0xa4280068    0x00008901    0xa4100068    0x00008201
</span></span><span class="line"><span class="cl">0x00005ce8 &lt;bogus+      48&gt;:    0xf2e80068    0x000089ff    0xf2d00068    0x000082ff
</span></span><span class="line"><span class="cl">0x00005cf8 &lt;bogus+      64&gt;:    0xd2e80068    0x000089ff    0xd2d00068    0x000082ff
</span></span><span class="line"><span class="cl">0x00005d08 &lt;bogus+      80&gt;:    0x12e80068    0x000089fc    0x12d00068    0x000082fc
</span></span><span class="line"><span class="cl">0x00005d18 &lt;bogus+      96&gt;:    0xa2e80068    0x00008bfa    0xa2d00068    0x000082fa
</span></span><span class="line"><span class="cl">0x00005d28 &lt;bogus+     112&gt;:    0xc2e80068    0x000089f8    0xc2d00068    0x000082f8
</span></span></code></pre></td></tr></table>
</div>
</div><p>GDT 表中的每一项占 64 位（8 个字节），所以我们要查找的项的地址是 <code>0x00005cb8+13*8</code>。</p>
<p>输入 <code>xp /2w 0x00005cb8+13*8</code>，得到：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">&lt;bochs:6&gt; xp /2w 0x00005cb8+13*8
</span></span><span class="line"><span class="cl">[bochs]:
</span></span><span class="line"><span class="cl">0x00005d20 &lt;bogus+       0&gt;:    0xa2d00068    0x000082fa
</span></span></code></pre></td></tr></table>
</div>
</div><p>上两步看到的数值可能和这里给出的示例不一致，这是很正常的。如果想确认是否准确，就看 <code>sreg</code> 输出中，ldtr 所在行里，<code>dl</code> 和 <code>dh</code> 的值，它们是 Bochs 的调试器自动计算出的，你寻找到的必须和它们一致。</p>
<p>“0x<strong>a2d0</strong>0068 0x<strong>00</strong>0082<strong>fa</strong>” 将其中的加粗数字组合为“0x00faa2d0”，这就是 LDT 表的物理地址（为什么这么组合，参考后文介绍的段描述符）。</p>
<p><code>xp /8w 0x00faa2d0</code>，得到：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">&lt;bochs:7&gt; xp /8w 0x00faa2d0
</span></span><span class="line"><span class="cl">[bochs]:
</span></span><span class="line"><span class="cl">0x00faa2d0 &lt;bogus+       0&gt;:    0x00000000    0x00000000    0x00000002    0x10c0fa00
</span></span><span class="line"><span class="cl">0x00faa2e0 &lt;bogus+      16&gt;:    0x00003fff    0x10c0f300    0x00000000    0x00fab000
</span></span></code></pre></td></tr></table>
</div>
</div><p>这就是 LDT 表的前 4 项内容了。</p>
<h3 id="44-段描述符">4.4 段描述符<a hidden class="anchor" aria-hidden="true" href="#44-段描述符">#</a></h3>
<p>在保护模式下，<code>段寄存器</code>有另一个名字，叫<code>段选择子</code>，因为它<code>保存的信息</code>主要是<code>该段在段表里索引值</code>，用这个索引值可以从段表中“选择”出相应的<code>段描述符</code>。</p>
<p>先看看 ds 选择子的内容，还是用 <code>sreg</code> 命令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">&lt;bochs:8&gt; sreg
</span></span><span class="line"><span class="cl">cs:s=0x000f, dl=0x00000002, dh=0x10c0fa00, valid=1
</span></span><span class="line"><span class="cl">ds:s=0x0017, dl=0x00003fff, dh=0x10c0f300, valid=3
</span></span><span class="line"><span class="cl">ss:s=0x0017, dl=0x00003fff, dh=0x10c0f300, valid=1
</span></span><span class="line"><span class="cl">es:s=0x0017, dl=0x00003fff, dh=0x10c0f300, valid=1
</span></span><span class="line"><span class="cl">fs:s=0x0017, dl=0x00003fff, dh=0x10c0f300, valid=1
</span></span><span class="line"><span class="cl">gs:s=0x0017, dl=0x00003fff, dh=0x10c0f300, valid=1
</span></span><span class="line"><span class="cl">ldtr:s=0x0068, dl=0xa2d00068, dh=0x000082fa, valid=1
</span></span><span class="line"><span class="cl">tr:s=0x0060, dl=0xa2e80068, dh=0x00008bfa, valid=1
</span></span><span class="line"><span class="cl">gdtr:base=0x00005cb8, limit=0x7ff
</span></span><span class="line"><span class="cl">idtr:base=0x000054b8, limit=0x7ff
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，ds 的值是 <code>0x0017</code>。段选择子是一个 16 位寄存器，它各位的含义如下图：</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012340307.bmp" alt="图片描述信息"  />
</p>
<p>图 2 段选择子的结构</p>
<p>其中 RPL 是请求特权级，当访问一个段时，处理器要检查 RPL 和 CPL（放在 cs 的位 0 和位 1 中，用来表示当前代码的特权级），即使程序有足够的特权级（CPL）来访问一个段，但如果 RPL（如放在 ds 中，表示请求数据段）的特权级不足，则仍然不能访问，即如果 RPL 的数值大于 CPL（数值越大，权限越小），则用 RPL 的值覆盖 CPL 的值。</p>
<p>而段选择子中的 TI 是表指示标记，如果 TI=0，则表示段描述符（段的详细信息）在 GDT（全局描述符表）中，即去 GDT 中去查；而 TI=1，则去 LDT（局部描述符表）中去查。</p>
<p>看看上面的 ds，<code>0x0017=0000000000010111</code>（二进制），所以 RPL=11，可见是在最低的特权级（因为在应用程序中执行），TI=1，表示查找 LDT 表，索引值为 10（二进制）= 2（十进制），表示找 LDT 表中的第 3 个段描述符（从 0 开始编号）。</p>
<p>LDT 和 GDT 的结构一样，每项占 8 个字节。所以第 3 项 <code>0x00003fff 0x10c0f300</code>（上一步骤的最后一个输出结果中） 就是搜寻好久的 ds 的段描述符了。</p>
<p>用 <code>sreg</code> 输出中 ds 所在行的 dl 和 dh 值可以验证找到的描述符是否正确。</p>
<p>接下来看看段描述符里面放置的是什么内容：</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012340309.bmp" alt="图片描述信息"  />
</p>
<p>图 3 段描述符的结构</p>
<p>可以看到，段描述符是一个 64 位二进制的数，存放了段基址和段限长等重要的数据。其中位 P（Present）是段是否存在的标记；位 S 用来表示是系统段描述符（S=0）还是代码或数据段描述符（S=1）；四位 TYPE 用来表示段的类型，如数据段、代码段、可读、可写等；DPL 是段的权限，和 CPL、RPL 对应使用；位 G 是粒度，G=0 表示段限长以位为单位，G=1 表示段限长以 4KB 为单位；其他内容就不详细解释了。</p>
<h3 id="45-段基址和线性地址">4.5 段基址和线性地址<a hidden class="anchor" aria-hidden="true" href="#45-段基址和线性地址">#</a></h3>
<p>费了很大的劲，实际上我们需要的只有段基址一项数据，即段描述符 “0x<strong>0000</strong>3fff 0x<strong>10</strong>c0f3<strong>00</strong>” 中加粗部分组合成的 “0x10000000”。这就是 ds 段在线性地址空间中的起始地址。用同样的方法也可以算算其它段的基址，都是这个数。</p>
<p>段基址+段内偏移，就是线性地址了。所以 ds:0x3004 的线性地址就是：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">0x10000000 + 0x3004 = 0x10003004
</span></span></code></pre></td></tr></table>
</div>
</div><p>用 <code>calc ds:0x3004</code> 命令可以验证这个结果。</p>
<h3 id="46-页表">4.6 页表<a hidden class="anchor" aria-hidden="true" href="#46-页表">#</a></h3>
<p>从线性地址计算物理地址，需要查找页表。线性地址变成物理地址的过程如下：</p>
<img src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012340562.bmp" alt="图片描述信息"  /> 
<p>图 4 页表工作原理</p>
<p>线性地址变成物理地址</p>
<p>首先需要算出线性地址中的页目录号、页表号和页内偏移，它们分别对应了 32 位线性地址的 10 位 + 10 位 + 12 位，所以==0x10003004 的页目录号是 64，页号 3，页内偏移是 4==。</p>
<p>IA-32 下，页目录表的位置由 CR3 寄存器指引。“creg”命令可以看到：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">CR0=0x8000001b: PG cd nw ac wp ne ET TS em MP PE
</span></span><span class="line"><span class="cl">CR2=page fault laddr=0x10002f68
</span></span><span class="line"><span class="cl">CR3=0x00000000
</span></span><span class="line"><span class="cl">    PCD=page-level cache disable=0
</span></span><span class="line"><span class="cl">    PWT=page-level writes transparent=0
</span></span><span class="line"><span class="cl">CR4=0x00000000: osxmmexcpt osfxsr pce pge mce pae pse de tsd pvi vme
</span></span></code></pre></td></tr></table>
</div>
</div><p>说明页目录表的基址为 0。看看其内容，“xp /68w 0”：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">0x00000000 :    0x00001027    0x00002007    0x00003007    0x00004027
</span></span><span class="line"><span class="cl">0x00000010 :    0x00000000    0x00024764    0x00000000    0x00000000
</span></span><span class="line"><span class="cl">0x00000020 :    0x00000000    0x00000000    0x00000000    0x00000000
</span></span><span class="line"><span class="cl">0x00000030 :    0x00000000    0x00000000    0x00000000    0x00000000
</span></span><span class="line"><span class="cl">0x00000040 :    0x00ffe027    0x00000000    0x00000000    0x00000000
</span></span><span class="line"><span class="cl">0x00000050 :    0x00000000    0x00000000    0x00000000    0x00000000
</span></span><span class="line"><span class="cl">0x00000060 :    0x00000000    0x00000000    0x00000000    0x00000000
</span></span><span class="line"><span class="cl">0x00000070 :    0x00000000    0x00000000    0x00000000    0x00000000
</span></span><span class="line"><span class="cl">0x00000080 :    0x00ff3027    0x00000000    0x00000000    0x00000000
</span></span><span class="line"><span class="cl">0x00000090 :    0x00000000    0x00000000    0x00000000    0x00000000
</span></span><span class="line"><span class="cl">0x000000a0 :    0x00000000    0x00000000    0x00000000    0x00000000
</span></span><span class="line"><span class="cl">0x000000b0 :    0x00000000    0x00000000    0x00000000    0x00ffb027
</span></span><span class="line"><span class="cl">0x000000c0 :    0x00ff6027    0x00000000    0x00000000    0x00000000
</span></span><span class="line"><span class="cl">0x000000d0 :    0x00000000    0x00000000    0x00000000    0x00000000
</span></span><span class="line"><span class="cl">0x000000e0 :    0x00000000    0x00000000    0x00000000    0x00000000
</span></span><span class="line"><span class="cl">0x000000f0 :    0x00000000    0x00000000    0x00000000    0x00ffa027
</span></span><span class="line"><span class="cl">0x00000100 :    0x00faa027    0x00000000    0x00000000    0x00000000
</span></span></code></pre></td></tr></table>
</div>
</div><p>页目录表和页表中的内容很简单，是 1024 个 32 位（正好是 4K）数。这 32 位中前 20 位是物理页框号，后面是一些属性信息（其中最重要的是最后一位 P）。其中第 65 个页目录项就是我们要找的内容，用“xp /w 0+64*4”查看：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">0x00000100 :    0x00faa027
</span></span></code></pre></td></tr></table>
</div>
</div><p>其中的 027 是属性，显然 P=1，其他属性实验者自己分析吧。页表所在物理页框号为 0x00faa，即页表在物理内存的 0x00faa000 位置。从该位置开始查找 3 号页表项，得到（xp /w 0x00faa000+3*4）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">0x00faa00c :    0x00fa7067
</span></span></code></pre></td></tr></table>
</div>
</div><p>其中 067 是属性，显然 P=1，应该是这样。</p>
<h3 id="47-物理地址">4.7 物理地址<a hidden class="anchor" aria-hidden="true" href="#47-物理地址">#</a></h3>
<p>最终结果马上就要出现了！</p>
<p>线性地址 0x10003004 对应的物理页框号为 0x00fa7，和页内偏移 0x004 接到一起，得到 0x00fa7004，这就是变量 i 的物理地址。可以通过两种方法验证。</p>
<p>第一种方法是用命令 <code>page 0x10003004</code>，可以得到信息：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">linear page 0x10003000 maps to physical page 0x00fa7000
</span></span></code></pre></td></tr></table>
</div>
</div><p>第二种方法是用命令 <code>xp /w 0x00fa7004</code>，可以看到：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">0x00fa7004 :    0x12345678
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个数值确实是 test.c 中 i 的初值。</p>
<p>现在，通过直接修改内存来改变 i 的值为 0，命令是： setpmem 0x00fa7004 4 0，表示从 0x00fa7004 地址开始的 4 个字节都设为 0。然后再用“c”命令继续 Bochs 的运行，可以看到 test 退出了，说明 i 的修改成功了，此项实验结束。</p>
<h3 id="48-在-linux-011-中实现共享内存">4.8 在 Linux 0.11 中实现共享内存<a hidden class="anchor" aria-hidden="true" href="#48-在-linux-011-中实现共享内存">#</a></h3>
<h4 id="1linux-中的共享内存">（1）Linux 中的共享内存<a hidden class="anchor" aria-hidden="true" href="#1linux-中的共享内存">#</a></h4>
<p>Linux 支持两种方式的共享内存。一种方式是 <code>shm_open()</code>、<code>mmap()</code> 和 <code>shm_unlink()</code> 的组合；另一种方式是 <code>shmget()</code>、<code>shmat()</code> 和 <code>shmdt()</code> 的组合。本实验建议使用后一种方式。</p>
<p>这些系统调用的详情，请查阅 man 及相关资料。</p>
<p>特别提醒：没有父子关系的进程之间进行共享内存，<code>shmget()</code> 的第一个参数 key 不要用 <code>IPC_PRIVATE</code>，否则无法共享。用什么数字可视心情而定。</p>
<h4 id="2获得空闲物理页面">（2）获得空闲物理页面<a hidden class="anchor" aria-hidden="true" href="#2获得空闲物理页面">#</a></h4>
<p>实验者需要考虑如何实现页面共享。首先看一下 Linux 0.11 如何操作页面，如何管理进程地址空间。</p>
<p>在 <code>kernel/fork.c</code> 文件中有：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">copy_process</span><span class="p">(</span><span class="err">…</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="p">)</span> <span class="nf">get_free_page</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">//    ……
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>函数 <code>get_free_page()</code> 用来获得一个空闲物理页面，在 <code>mm/memory.c</code> 文件中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">get_free_page</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">register</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__res</span> <span class="k">asm</span><span class="p">(</span><span class="s">&#34;ax&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">__asm__</span><span class="p">(</span><span class="s">&#34;std ; repne ; scasb</span><span class="se">\n\t</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl">            <span class="s">&#34;jne 1f</span><span class="se">\n\t</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl">            <span class="s">&#34;movb $1,1(%%edi)</span><span class="se">\n\t</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 页面数*4KB=相对页面起始地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="s">&#34;sall $12,%%ecx</span><span class="se">\n\t</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 在加上低端的内存地址，得到的是物理起始地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="s">&#34;addl %2,%%ecx</span><span class="se">\n\t</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl">            <span class="s">&#34;movl %%ecx,%%edx</span><span class="se">\n\t</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl">            <span class="s">&#34;movl $1024,%%ecx</span><span class="se">\n\t</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl">            <span class="s">&#34;leal 4092(%%edx),%%edi</span><span class="se">\n\t</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl">            <span class="s">&#34;rep ; stosl</span><span class="se">\n\t</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//edx赋给eax，eax返回了物理起始地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="s">&#34;movl %%edx,%%eax</span><span class="se">\n</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl">            <span class="s">&#34;1:&#34;</span> <span class="o">:</span><span class="s">&#34;=a&#34;</span> <span class="p">(</span><span class="n">__res</span><span class="p">)</span> <span class="o">:</span><span class="s">&#34;0&#34;</span> <span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="s">&#34;i&#34;</span> <span class="p">(</span><span class="n">LOW_MEM</span><span class="p">),</span><span class="s">&#34;c&#34;</span> <span class="p">(</span><span class="n">PAGING_PAGES</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">            <span class="s">&#34;D&#34;</span> <span class="p">(</span><span class="n">mem_map</span><span class="o">+</span><span class="n">PAGING_PAGES</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span><span class="s">&#34;di&#34;</span><span class="p">,</span><span class="s">&#34;cx&#34;</span><span class="p">,</span><span class="s">&#34;dx&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">__res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">mem_map</span> <span class="p">[</span> <span class="n">PAGING_PAGES</span> <span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>显然 <code>get_free_page</code> 函数就是在 <code>mem_map</code> 位图中寻找值为 0 的项（空闲页面），该函数返回的是该页面的起始物理地址。</p>
<h4 id="3地址映射">（3）地址映射<a hidden class="anchor" aria-hidden="true" href="#3地址映射">#</a></h4>
<p>有了空闲的物理页面，接下来需要完成线性地址和物理页面的映射，Linux 0.11 中也有这样的代码，看看 <code>mm/memory.c</code> 中的 <code>do_no_page(unsigned long address)</code>，该函数用来处理线性地址 address 对应的物理页面无效的情况（即缺页中断），<code>do_no_page</code> 函数中调用一个重要的函数 <code>get_empty_page(address)</code>，其中有：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// 函数 get_empty_page(address)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tmp</span><span class="o">=</span><span class="nf">get_free_page</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 建立线性地址和物理地址的映射
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">put_page</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>显然这两条语句就用来获得空闲物理页面，然后填写线性地址 address 对应的页目录和页表。</p>
<h4 id="4寻找空闲的虚拟地址空间">（4）寻找空闲的虚拟地址空间<a hidden class="anchor" aria-hidden="true" href="#4寻找空闲的虚拟地址空间">#</a></h4>
<p>有了空闲物理页面，也有了建立线性地址和物理页面的映射，但要完成本实验还需要能获得一段空闲的虚拟地址空闲。</p>
<p>要从数据段中划出一段空间，首先需要了解进程数据段空间的分布，而这个分布显然是由 exec 系统调用决定的，所以要详细看一看 exec 的核心代码，<code>do_execve</code>（在文件 <code>fs/exec.c</code> 中）。</p>
<p>在函数 <code>do_execve()</code> 中，修改数据段（当然是修改 LDT）的地方是 <code>change_ldt</code>，函数 change_ldt 实现如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">change_ldt</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">text_size</span><span class="p">,</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span> <span class="n">page</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/*其中text_size是代码段长度，从可执行文件的头部取出，page为参数和环境页*/</span>
</span></span><span class="line"><span class="cl">    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">code_limit</span><span class="p">,</span><span class="n">data_limit</span><span class="p">,</span><span class="n">code_base</span><span class="p">,</span><span class="n">data_base</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">code_limit</span> <span class="o">=</span> <span class="n">text_size</span><span class="o">+</span><span class="n">PAGE_SIZE</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">code_limit</span> <span class="o">&amp;=</span> <span class="mh">0xFFFFF000</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//code_limit为代码段限长=text_size对应的页数（向上取整）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">data_limit</span> <span class="o">=</span> <span class="mh">0x4000000</span><span class="p">;</span> <span class="c1">//数据段限长64MB
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">code_base</span> <span class="o">=</span> <span class="nf">get_base</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">ldt</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="n">data_base</span> <span class="o">=</span> <span class="n">code_base</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 数据段基址 = 代码段基址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">set_base</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">ldt</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">code_base</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">set_limit</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">ldt</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">code_limit</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">set_base</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">ldt</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">data_base</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">set_limit</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">ldt</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">data_limit</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">__asm__</span><span class="p">(</span><span class="s">&#34;pushl $0x17</span><span class="se">\n\t</span><span class="s">pop %%fs&#34;</span><span class="o">::</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 从数据段的末尾开始
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">data_base</span> <span class="o">+=</span> <span class="n">data_limit</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 向前处理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">MAX_ARG_PAGES</span><span class="o">-</span><span class="mi">1</span> <span class="p">;</span> <span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 一次处理一页
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">data_base</span> <span class="o">-=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 建立线性地址到物理页的映射
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="nf">put_page</span><span class="p">(</span><span class="n">page</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">data_base</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 返回段界限
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="n">data_limit</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>仔细分析过函数 <code>change_ldt</code>，想必实验者已经知道该如何从数据段中找到一页空闲的线性地址。《注释》中的图 13-6 也能给你很大帮助。</p>
<h3 id="49-在同一终端中同时运行两个程序">4.9 在同一终端中同时运行两个程序<a hidden class="anchor" aria-hidden="true" href="#49-在同一终端中同时运行两个程序">#</a></h3>
<p>Linux 的 shell 有后台运行程序的功能。只要在命令的最后输入一个 <code>&amp;</code>，命令就会进入后台运行，前台马上回到提示符，进而能运行下一个命令，例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ sudo ./producer <span class="p">&amp;</span>
</span></span><span class="line"><span class="cl">$ sudo ./consumer
</span></span></code></pre></td></tr></table>
</div>
</div><p>当运行 <code>./consumer</code> 的时候，producer 正在后台运行。</p>
<h2 id="5实验步骤">5.实验步骤<a hidden class="anchor" aria-hidden="true" href="#5实验步骤">#</a></h2>
<h3 id="1创建testc">1.创建test.c<a hidden class="anchor" aria-hidden="true" href="#1创建testc">#</a></h3>
<p>挂载hdc文件系统，然后在usr/root目录内增加test.c文件用于测试地址映射，代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mh">0x12345678</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;The logical/virtual address of i is 0x%08x&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>代码添加过程截图如下：
<img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012340579.png" alt="img"  />
</p>
<h3 id="2寻找物理地址">2.寻找物理地址<a hidden class="anchor" aria-hidden="true" href="#2寻找物理地址">#</a></h3>
<p>首先进入Linux-0.11目录内make编译系统，然后回退至oslab目录内运行系统，再使用下述命令编译运行test.c文件</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">gcc -o test test.c
</span></span><span class="line"><span class="cl">./test
</span></span></code></pre></td></tr></table>
</div>
</div><p>运行效果如下图所示：
<img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012340608.png" alt="img"  />
</p>
<p>此时会进入在test.c内的while死循环，然后ctrl+c暂停bochs。
此时需要让Linux-0.11的test跳出死循环，所以需要找到逻辑地址ds:0X00003004对应的物理地址，将它的内容更改为0。
在终端中输入sreg，得到gdtr的基址值为0x00005cb8，ldtr为0x0068即0000 0000 0110 1000 b，可知索引为1101b即13，TI位为0，即GDT中的第13项为LDT的段描述符。
<img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012340626.png" alt="img"  />
</p>
<p>输入<code>xp /2w 0x00005cb8+13*8</code>得到LDT段描述符，可以得到LDT的基址为<code>0x00f9a2d0</code>
ds段选择子为<code>0x0017 =&gt; 0000 0000 0001 0111 b</code>，可知索引为10b即2，TI位为1，即LDT中的第2项为ds的段描述符，输入<code>xp/2w 0x00f9a2d0+2*8</code>得到ds段描述符，可以知道ds的基址为<code>0x10000000</code>，所以0x3004对应的线性地址为<code>0x10000000+0x3004=0x10003004</code>。输入<code>xp /w 64*4</code>获取页目录项，可知页表基地址为<code>0x00fa6000</code>。
输入<code>xp /w 0x00fa6000+3*4</code>得到物理基址为<code>0xfa5000</code>。
输入<code>xp /w 0xfa5000+4</code>得到的内容即test.c中的变量的值，输入<code>setpmem 0xfa5004 4 0</code>将它设为0。
<img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012340871.png" alt="img"  />
</p>
<p>然后在终端内输入c继续让系统运行，发现test而已跳出循环。</p>
<h3 id="3添加系统调用">3.添加系统调用<a hidden class="anchor" aria-hidden="true" href="#3添加系统调用">#</a></h3>
<p>在unistd.h中增加下面的代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#define SHM_SIZE 64
</span></span></span><span class="line"><span class="cl"><span class="cp"></span> 
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">shm_ds</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">key</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span><span class="n">shm_ds</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">sys_shmget</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">key</span><span class="p">,</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="o">*</span> <span class="nf">sys_shmat</span><span class="p">(</span><span class="kt">int</span> <span class="n">shmid</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012340076.png" alt="img"  />
</p>
<p>然后增加两个系统调用</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#define __NR_shmget 76
</span></span></span><span class="line"><span class="cl"><span class="cp">#define __NR_shmat 77
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012340101.png" alt="img"  />
</p>
<h3 id="4修改sysh文件">4.修改sys.h文件<a hidden class="anchor" aria-hidden="true" href="#4修改sysh文件">#</a></h3>
<p>在此文件中增加函数声明：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="k">extern</span> <span class="kt">int</span> <span class="n">sys_shmget</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="k">extern</span> <span class="kt">int</span> <span class="n">sys_shmat</span><span class="p">();</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012340536.png" alt="img"  />
</p>
<p>在system_call.s中把nr_system_calls改为78</p>
<h3 id="5增加shmc">5.增加shm.c<a hidden class="anchor" aria-hidden="true" href="#5增加shmc">#</a></h3>
<p>shm.c的位置在kernel目录下
代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#define __LIBRARY__
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;linux/kernel.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;linux/sched.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;linux/mm.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;errno.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="n">shm_ds</span> <span class="n">shm_list</span><span class="p">[</span><span class="n">SHM_SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{{</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">}};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">sys_shmget</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">key</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">page</span> <span class="o">=</span> <span class="nf">get_free_page</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printk</span><span class="p">(</span><span class="s">&#34;shmget get memory&#39;s address is 0x%08x</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">page</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">SHM_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">shm_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">key</span> <span class="o">==</span> <span class="n">key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">SHM_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">shm_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">key</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">               <span class="n">shm_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">page</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">shm_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">shm_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="o">*</span> <span class="nf">sys_shmat</span><span class="p">(</span><span class="kt">int</span> <span class="n">shmid</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data_base</span><span class="p">,</span> <span class="n">brk</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">shmid</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">SHM_SIZE</span> <span class="o">&lt;=</span> <span class="n">shmid</span> <span class="o">||</span> <span class="n">shm_list</span><span class="p">[</span><span class="n">shmid</span><span class="p">].</span><span class="n">page</span><span class="o">==</span><span class="mi">0</span> <span class="o">||</span> <span class="n">shm_list</span><span class="p">[</span><span class="n">shmid</span><span class="p">].</span><span class="n">key</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">data_base</span> <span class="o">=</span> <span class="nf">get_base</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">ldt</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printk</span><span class="p">(</span><span class="s">&#34;current&#39;s data_base = 0x%08x,new page = 0x%08x</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">data_base</span><span class="p">,</span><span class="n">shm_list</span><span class="p">[</span><span class="n">shmid</span><span class="p">].</span><span class="n">page</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">brk</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">brk</span> <span class="o">+</span> <span class="n">data_base</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">current</span><span class="o">-&gt;</span><span class="n">brk</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="nf">put_page</span><span class="p">(</span><span class="n">shm_list</span><span class="p">[</span><span class="n">shmid</span><span class="p">].</span><span class="n">page</span><span class="p">,</span> <span class="n">brk</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">brk</span> <span class="o">-</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>然后修改Kernel下的Makefile文件</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1">### Dependencies:</span>
</span></span><span class="line"><span class="cl">sem.s sem.o: sem.c ../include/linux/sem.h ../include/linux/kernel.h <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>../include/unistd.h
</span></span><span class="line"><span class="cl">shm.s shm.o:shm.c ../include/unistd.h ../include/linux/kernel.h ../include/linux/sched.h ../include/linux/mm.h ../include/errno.h
</span></span><span class="line"><span class="cl">...
</span></span></code></pre></td></tr></table>
</div>
</div><p>修改截图如下：
<img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012340559.png" alt="img"  />
</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012340591.png" alt="img"  />
</p>
<h3 id="6编写消费者和生产者程序">6.编写消费者和生产者程序<a hidden class="anchor" aria-hidden="true" href="#6编写消费者和生产者程序">#</a></h3>
<p>在hdc的root目录下增加producer.c和consumer.c文件，这两个文件的代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/*producer*/</span> 
</span></span><span class="line"><span class="cl"><span class="cp">#define __LIBRARY__
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;linux/kernel.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;fcntl.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;linux/sem.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="nf">_syscall2</span><span class="p">(</span><span class="kt">sem_t</span> <span class="o">*</span><span class="p">,</span><span class="n">sem_open</span><span class="p">,</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="kt">int</span><span class="p">,</span><span class="n">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nf">_syscall1</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="n">sem_post</span><span class="p">,</span><span class="kt">sem_t</span> <span class="o">*</span><span class="p">,</span><span class="n">sem</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nf">_syscall1</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="n">sem_wait</span><span class="p">,</span><span class="kt">sem_t</span> <span class="o">*</span><span class="p">,</span><span class="n">sem</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">_syscall1</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">shmat</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">shmid</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nf">_syscall2</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">shmget</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#define PRODUCE_NUM 200
</span></span></span><span class="line"><span class="cl"><span class="cp">#define BUFFER_SIZE 10
</span></span></span><span class="line"><span class="cl"><span class="cp">#define SHM_KEY 2018
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">sem_t</span> <span class="o">*</span><span class="n">Empty</span><span class="p">,</span><span class="o">*</span><span class="n">Full</span><span class="p">,</span><span class="o">*</span><span class="n">Mutex</span><span class="p">;</span>    
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">shm_id</span><span class="p">,</span> <span class="n">location</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">Empty</span> <span class="o">=</span> <span class="nf">sem_open</span><span class="p">(</span><span class="s">&#34;Empty&#34;</span><span class="p">,</span> <span class="n">BUFFER_SIZE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">Full</span> <span class="o">=</span> <span class="nf">sem_open</span><span class="p">(</span><span class="s">&#34;Full&#34;</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">Mutex</span> <span class="o">=</span> <span class="nf">sem_open</span><span class="p">(</span><span class="s">&#34;Mutex&#34;</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">((</span><span class="n">shm_id</span> <span class="o">=</span> <span class="nf">shmget</span><span class="p">(</span><span class="n">SHM_KEY</span><span class="p">,</span> <span class="n">BUFFER_SIZE</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;shmget failed!&#34;</span><span class="p">);</span>    
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">((</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span> <span class="p">)</span><span class="nf">shmat</span><span class="p">(</span><span class="n">shm_id</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;shmat error!&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">PRODUCE_NUM</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">sem_wait</span><span class="p">(</span><span class="n">Empty</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">sem_wait</span><span class="p">(</span><span class="n">Mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">p</span><span class="p">[</span><span class="n">location</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="nf">sem_post</span><span class="p">(</span><span class="n">Mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">sem_post</span><span class="p">(</span><span class="n">Full</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">location</span>  <span class="o">=</span> <span class="p">(</span><span class="n">location</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">BUFFER_SIZE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>    
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>consumer.c代码如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/*consumer*/</span> 
</span></span><span class="line"><span class="cl"><span class="cp">#define __LIBRARY__
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;linux/kernel.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;fcntl.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;linux/sem.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="nf">_syscall2</span><span class="p">(</span><span class="kt">sem_t</span> <span class="o">*</span><span class="p">,</span><span class="n">sem_open</span><span class="p">,</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="kt">int</span><span class="p">,</span><span class="n">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nf">_syscall1</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="n">sem_post</span><span class="p">,</span><span class="kt">sem_t</span> <span class="o">*</span><span class="p">,</span><span class="n">sem</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nf">_syscall1</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="n">sem_wait</span><span class="p">,</span><span class="kt">sem_t</span> <span class="o">*</span><span class="p">,</span><span class="n">sem</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nf">_syscall1</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="n">sem_unlink</span><span class="p">,</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">,</span><span class="n">name</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">_syscall1</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">shmat</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">shmid</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nf">_syscall2</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">shmget</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#define PRODUCE_NUM 200
</span></span></span><span class="line"><span class="cl"><span class="cp">#define BUFFER_SIZE 10
</span></span></span><span class="line"><span class="cl"><span class="cp">#define SHM_KEY 2018
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">sem_t</span> <span class="o">*</span><span class="n">Empty</span><span class="p">,</span><span class="o">*</span><span class="n">Full</span><span class="p">,</span><span class="o">*</span><span class="n">Mutex</span><span class="p">;</span>    
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">used</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">shm_id</span><span class="p">,</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">Empty</span> <span class="o">=</span> <span class="nf">sem_open</span><span class="p">(</span><span class="s">&#34;Empty&#34;</span><span class="p">,</span> <span class="n">BUFFER_SIZE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">Full</span> <span class="o">=</span> <span class="nf">sem_open</span><span class="p">(</span><span class="s">&#34;Full&#34;</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">Mutex</span> <span class="o">=</span> <span class="nf">sem_open</span><span class="p">(</span><span class="s">&#34;Mutex&#34;</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">((</span><span class="n">shm_id</span> <span class="o">=</span> <span class="nf">shmget</span><span class="p">(</span><span class="n">SHM_KEY</span><span class="p">,</span> <span class="n">BUFFER_SIZE</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;shmget failed!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>    
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">((</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span> <span class="p">)</span><span class="nf">shmat</span><span class="p">(</span><span class="n">shm_id</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;link error!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">sem_wait</span><span class="p">(</span><span class="n">Full</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">sem_wait</span><span class="p">(</span><span class="n">Mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;pid %d:</span><span class="se">\t</span><span class="s">consumer consumes item %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="nf">getpid</span><span class="p">(),</span> <span class="n">p</span><span class="p">[</span><span class="n">location</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="nf">sem_post</span><span class="p">(</span><span class="n">Mutex</span><span class="p">);</span>     
</span></span><span class="line"><span class="cl">        <span class="nf">sem_post</span><span class="p">(</span><span class="n">Empty</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">location</span>  <span class="o">=</span> <span class="p">(</span><span class="n">location</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">BUFFER_SIZE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="o">++</span><span class="n">used</span> <span class="o">==</span> <span class="n">PRODUCE_NUM</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">sem_unlink</span><span class="p">(</span><span class="s">&#34;Mutex&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">sem_unlink</span><span class="p">(</span><span class="s">&#34;Full&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">sem_unlink</span><span class="p">(</span><span class="s">&#34;Empty&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>    
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="7运行验证">7.运行验证<a hidden class="anchor" aria-hidden="true" href="#7运行验证">#</a></h3>
<p>运行bochs，输入：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">gcc -o pro producer.c
</span></span><span class="line"><span class="cl">gcc -o con consumer.c
</span></span></code></pre></td></tr></table>
</div>
</div><p>编译这两个程序，
然后输入</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">pro &gt; proOutput &amp;
</span></span><span class="line"><span class="cl">con &gt; conOutput &amp;
</span></span></code></pre></td></tr></table>
</div>
</div><p>来同时运行这两个程序，并将结果保存到proOutput和conOutput中。
最后输入sync,结果如下
<img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012340620.jpg" alt="img"  />
</p>
<p>关闭linux-0.11回到ubunt终端，输入sudo less hdc/usr/root/conOutput查看结果如下：
<img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012340699.png" alt="image-20230801234052652"  />
</p>


  </div>

  <footer class="post-footer">
    
<nav class="paginav">
  <a class="prev" href="https://chance7bin.github.io/posts/basic/asm/%E7%AC%AC5%E7%AB%A0-bx%E5%92%8Cloop%E6%8C%87%E4%BB%A4/">
    <span class="title">« 上一页</span>
    <br>
    <span>第5章 [BX]和loop指令</span>
  </a>
  <a class="next" href="https://chance7bin.github.io/posts/basic/asm/%E7%AC%AC6%E7%AB%A0-%E5%8C%85%E5%90%AB%E5%A4%9A%E4%B8%AA%E6%AE%B5%E7%9A%84%E7%A8%8B%E5%BA%8F/">
    <span class="title">下一页 »</span>
    <br>
    <span>第6章 包含多个段的程序</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://chance7bin.github.io/">Binb&#39;s Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
