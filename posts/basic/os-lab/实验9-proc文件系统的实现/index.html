<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>实验9 proc文件系统的实现 | Binb&#39;s Blog</title>
<meta name="keywords" content="操作系统, 实验">
<meta name="description" content="1.实验目的 掌握虚拟文件系统的实现原理； 实践文件、目录、文件系统等概念。 2.实验内容 /proc文件系统是了解系统信息的一个窗口，它不是普通意">
<meta name="author" content="chance7bin">
<link rel="canonical" href="https://chance7bin.github.io/posts/basic/os-lab/%E5%AE%9E%E9%AA%8C9-proc%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%9E%E7%8E%B0/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.be81eec981a615a87a88f121642d7eebde74d033438693944db2fd6b827284ff.css" integrity="" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.acb54fd32bbc1982428b8850317e45d076b95012730a5936667e6bc21777692a.js" integrity=""
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://chance7bin.github.io/img/%E7%BE%8E%E9%98%9F.jpg">
<link rel="icon" type="image/png" sizes="16x16" href="https://chance7bin.github.io/img/%E7%BE%8E%E9%98%9F.jpg">
<link rel="icon" type="image/png" sizes="32x32" href="https://chance7bin.github.io/img/%E7%BE%8E%E9%98%9F.jpg">
<link rel="apple-touch-icon" href="https://chance7bin.github.io/img/%E7%BE%8E%E9%98%9F.jpg">
<link rel="mask-icon" href="https://chance7bin.github.io/img/%E7%BE%8E%E9%98%9F.jpg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="实验9 proc文件系统的实现" />
<meta property="og:description" content="1.实验目的 掌握虚拟文件系统的实现原理； 实践文件、目录、文件系统等概念。 2.实验内容 /proc文件系统是了解系统信息的一个窗口，它不是普通意" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://chance7bin.github.io/posts/basic/os-lab/%E5%AE%9E%E9%AA%8C9-proc%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%9E%E7%8E%B0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-26T00:00:00+00:00" />
<meta property="article:modified_time" content="2022-05-26T00:00:00+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="实验9 proc文件系统的实现"/>
<meta name="twitter:description" content="1.实验目的 掌握虚拟文件系统的实现原理； 实践文件、目录、文件系统等概念。 2.实验内容 /proc文件系统是了解系统信息的一个窗口，它不是普通意"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "📚 文章",
      "item": "https://chance7bin.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "📕 计算机基础",
      "item": "https://chance7bin.github.io/posts/basic/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "hit-oslab",
      "item": "https://chance7bin.github.io/posts/basic/os-lab/"
    }, 
    {
      "@type": "ListItem",
      "position":  4 ,
      "name": "实验9 proc文件系统的实现",
      "item": "https://chance7bin.github.io/posts/basic/os-lab/%E5%AE%9E%E9%AA%8C9-proc%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%9E%E7%8E%B0/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "实验9 proc文件系统的实现",
  "name": "实验9 proc文件系统的实现",
  "description": "1.实验目的 掌握虚拟文件系统的实现原理； 实践文件、目录、文件系统等概念。 2.实验内容 /proc文件系统是了解系统信息的一个窗口，它不是普通意",
  "keywords": [
    "操作系统", "实验"
  ],
  "articleBody": "1.实验目的 掌握虚拟文件系统的实现原理； 实践文件、目录、文件系统等概念。 2.实验内容 /proc文件系统是了解系统信息的一个窗口，它不是普通意义上的文件系统，它是一个到运行中进程地址空间的访问接口。通过/proc，可以用标准Unix系统调用(比如open()、read()、write()等等)访问，就象访问一个普通文件一样。事实上，许多操作系统中的ps命令正是利用/proc来获取进程状态的。因此/proc文件系统是虚拟的文件系统，看似存在的文件实际并没有在硬盘上。其实，/proc是你了解自己系统的一个窗口，它实际存在于内存。\n在 Linux 0.11 上实现 procfs（proc 文件系统）内的 psinfo 结点。当读取此结点的内容时，可得到系统当前所有进程的状态信息。例如，用 cat 命令显示 /proc/psinfo 的内容，可得到：\n1 2 3 4 5 6 7 8 9 10 11 12 $ cat /proc/psinfo pid state father counter start_time 0 1 -1 0 0 1 1 0 28 1 4 1 1 1 73 3 1 1 27 63 6 0 4 12 817 $ cat /proc/hdinfo total_blocks: 62000; free_blocks: 39037; used_blocks: 22963; ... procfs 及其结点要在内核启动时自动创建。\n相关功能实现在 fs/proc.c 文件内。\n3.实验报告 完成实验后，在实验报告中回答如下问题：\n如果要求你在 psinfo 之外再实现另一个结点，具体内容自选，那么你会实现一个给出什么信息的结点？为什么？ 一次 read() 未必能读出所有的数据，需要继续 read()，直到把数据读空为止。而数次 read() 之间，进程的状态可能会发生变化。你认为后几次 read() 传给用户的数据，应该是变化后的，还是变化前的？ 如果是变化后的，那么用户得到的数据衔接部分是否会有混乱？如何防止混乱？ 如果是变化前的，那么该在什么样的情况下更新 psinfo 的内容？ 4.实验提示 本实验文档在 Linux 0.11 上实现 procfs（proc 文件系统）内的 psinfo 结点。当读取 psinfo 结点的内容时，可得到系统当前所有进程的状态信息。\n最后还给出来 hdinfo 结点实现的提示。\n4.1 procfs 简介 正式的 Linux 内核实现了 procfs，它是一个虚拟文件系统，通常被 mount（挂载） 到 /proc 目录上，通过虚拟文件和虚拟目录的方式提供访问系统参数的机会，所以有人称它为 “了解系统信息的一个窗口”。\n这些虚拟的文件和目录并没有真实地存在在磁盘上，而是内核中各种数据的一种直观表示。虽然是虚拟的，但它们都可以通过标准的系统调用（open()、read() 等）访问。\n例如，/proc/meminfo 中包含内存使用的信息，可以用 cat 命令显示其内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 $ cat /proc/meminfo MemTotal: 384780 kB MemFree: 13636 kB Buffers: 13928 kB Cached: 101680 kB SwapCached: 132 kB Active: 207764 kB Inactive: 45720 kB SwapTotal: 329324 kB SwapFree: 329192 kB Dirty: 0 kB Writeback: 0 kB …… 其实，Linux 的很多系统命令就是通过读取 /proc 实现的。例如 uname -a 的部分信息就来自 /proc/version，而 uptime 的部分信息来自 /proc/uptime 和 /proc/loadavg。\n关于 procfs 更多的信息请访问：http://en.wikipedia.org/wiki/Procfs\n4.2 基本思路 Linux 是通过文件系统接口实现 procfs，并在启动时自动将其 mount 到 /proc 目录上。\n此目录下的所有内容都是随着系统的运行自动建立、删除和更新的，而且它们完全存在于内存中，不占用任何外存空间。\nLinux 0.11 还没有实现虚拟文件系统，也就是，还没有提供增加新文件系统支持的接口。所以本实验只能在现有文件系统的基础上，通过打补丁的方式模拟一个 procfs。\nLinux 0.11 使用的是 Minix 的文件系统，这是一个典型的基于 inode 的文件系统，《注释》一书对它有详细描述。它的每个文件都要对应至少一个 inode，而 inode 中记录着文件的各种属性，包括文件类型。文件类型有普通文件、目录、字符设备文件和块设备文件等。在内核中，每种类型的文件都有不同的处理函数与之对应。我们可以增加一种新的文件类型——proc 文件，并在相应的处理函数内实现 procfs 要实现的功能。\n4.3 增加新文件类型 在 include/sys/stat.h 文件中定义了几种文件类型和相应的测试宏：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #define S_IFMT 00170000 // 普通文件 #define S_IFREG 0100000 // 块设备 #define S_IFBLK 0060000 // 目录 #define S_IFDIR 0040000 // 字符设备 #define S_IFCHR 0020000 #define S_IFIFO 0010000 //…… // 测试 m 是否是普通文件 #define S_ISREG(m) (((m) \u0026 S_IFMT) == S_IFREG) // 测试 m 是否是目录 #define S_ISDIR(m) (((m) \u0026 S_IFMT) == S_IFDIR) // 测试 m 是否是字符设备 #define S_ISCHR(m) (((m) \u0026 S_IFMT) == S_IFCHR) // 测试 m 是否是块设备 #define S_ISBLK(m) (((m) \u0026 S_IFMT) == S_IFBLK) #define S_ISFIFO(m) (((m) \u0026 S_IFMT) == S_IFIFO) 增加新的类型的方法分两步：\n（1）定义一个类型宏 S_IFPROC，其值应在 0010000 到 0100000 之间，但后四位八进制数必须是 0（这是 S_IFMT 的限制，分析测试宏可知原因），而且不能和已有的任意一个 S_IFXXX 相同； （2）定义一个测试宏 S_ISPROC(m)，形式仿照其它的 S_ISXXX(m) 注意，C 语言中以 “0” 直接接数字的常数是八进制数。\n4.4 让 mknod() 支持新的文件类型 psinfo 结点要通过 mknod() 系统调用建立，所以要让它支持新的文件类型。\n直接修改 fs/namei.c 文件中的 sys_mknod() 函数中的一行代码，如下：\n1 2 3 if (S_ISBLK(mode) || S_ISCHR(mode) || S_ISPROC(mode)) inode-\u003ei_zone[0] = dev; // 文件系统初始化 内核初始化的全部工作是在 main() 中完成，而 main() 在最后从内核态切换到用户态，并调用 init()。\ninit() 做的第一件事情就是挂载根文件系统：\n1 2 3 4 5 6 void init(void) { // …… setup((void *) \u0026drive_info); // …… } procfs 的初始化工作应该在根文件系统挂载之后开始。它包括两个步骤：\n（1）建立 /proc 目录；建立 /proc 目录下的各个结点。本实验只建立 /proc/psinfo。 （2）建立目录和结点分别需要调用 mkdir() 和 mknod() 系统调用。因为初始化时已经在用户态，所以不能直接调用 sys_mkdir() 和 sys_mknod()。必须在初始化代码所在文件中实现这两个系统调用的用户态接口，即 API： 1 2 3 4 5 6 #ifndef __LIBRARY__ #define __LIBRARY__ #endif _syscall2(int,mkdir,const char*,name,mode_t,mode) _syscall3(int,mknod,const char*,filename,mode_t,mode,dev_t,dev) mkdir() 时 mode 参数的值可以是 “0755”（对应 rwxr-xr-x），表示只允许 root 用户改写此目录，其它人只能进入和读取此目录。\nprocfs 是一个只读文件系统，所以用 mknod() 建立 psinfo 结点时，必须通过 mode 参数将其设为只读。建议使用 S_IFPROC|0444 做为 mode 值，表示这是一个 proc 文件，权限为 0444（r–r–r–），对所有用户只读。\nmknod() 的第三个参数 dev 用来说明结点所代表的设备编号。对于 procfs 来说，此编号可以完全自定义。proc 文件的处理函数将通过这个编号决定对应文件包含的信息是什么。例如，可以把 0 对应 psinfo，1 对应 meminfo，2 对应 cpuinfo。\n如此项工作完成得没有问题，那么编译、运行 0.11 内核后，用 ll /proc 可以看到：\n1 2 3 # ll /proc total 0 ?r--r--r-- 1 root root 0 ??? ?? ???? psinfo 此时可以试着读一下此文件：\n1 2 3 # cat /proc/psinfo (Read)inode-\u003ei_mode=XXX444 cat: /proc/psinfo: EINVAL inode-\u003ei_mode 就是通过 mknod() 设置的 mode。信息中的 XXX 和你设置的 S_IFPROC 有关。通过此值可以了解 mknod() 工作是否正常。这些信息说明内核在对 psinfo 进行读操作时不能正确处理，向 cat 返回了 EINVAL 错误。因为还没有实现处理函数，所以这是很正常的。\n这些信息至少说明，psinfo 被正确 open() 了。所以我们不需要对 sys_open() 动任何手脚，唯一要打补丁的，是 sys_read()。\n4.5 让 proc 文件可读 open() 没有变化，那么需要修改的就是 sys_read() 了。\n首先分析 sys_read（在文件 fs/read_write.c 中）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 int sys_read(unsigned int fd,char * buf,int count) { struct file * file; struct m_inode * inode; // …… inode = file-\u003ef_inode; if (inode-\u003ei_pipe) return (file-\u003ef_mode\u00261)?read_pipe(inode,buf,count):-EIO; if (S_ISCHR(inode-\u003ei_mode)) return rw_char(READ,inode-\u003ei_zone[0],buf,count,\u0026file-\u003ef_pos); if (S_ISBLK(inode-\u003ei_mode)) return block_read(inode-\u003ei_zone[0],\u0026file-\u003ef_pos,buf,count); if (S_ISDIR(inode-\u003ei_mode) || S_ISREG(inode-\u003ei_mode)) { if (count+file-\u003ef_pos \u003e inode-\u003ei_size) count = inode-\u003ei_size - file-\u003ef_pos; if (count\u003c=0) return 0; return file_read(inode,file,buf,count); } printk(\"(Read)inode-\u003ei_mode=%06o\\n\\r\",inode-\u003ei_mode); //这条信息很面善吧？ return -EINVAL; } 显然，要在这里一群 if 的排比中，加上 S_IFPROC() 的分支，进入对 proc 文件的处理函数。需要传给处理函数的参数包括：\ninode-\u003ei_zone[0]，这就是 mknod() 时指定的 dev ——设备编号 buf，指向用户空间，就是 read() 的第二个参数，用来接收数据 count，就是 read() 的第三个参数，说明 buf 指向的缓冲区大小 \u0026file-\u003ef_pos，f_pos 是上一次读文件结束时“文件位置指针”的指向。这里必须传指针，因为处理函数需要根据传给 buf 的数据量修改 f_pos 的值。 4.6 proc 文件的处理函数 proc 文件的处理函数的功能是根据设备编号，把不同的内容写入到用户空间的 buf。写入的数据要从 f_pos 指向的位置开始，每次最多写 count 个字节，并根据实际写入的字节数调整 f_pos 的值，最后返回实际写入的字节数。当设备编号表明要读的是 psinfo 的内容时，就要按照 psinfo 的形式组织数据。\n实现此函数可能要用到如下几个函数：\nmalloc() 函数 free() 函数 包含 linux/kernel.h 头文件后，就可以使用 malloc() 和 free() 函数。它们是可以被核心态代码调用的，唯一的限制是一次申请的内存大小不能超过一个页面。\n4.7 实现 sprintf() 函数 Linux 0.11 没有 sprintf()，可以参考 printf() 自己实现一个。\n可以借鉴如下代码：\n1 2 3 4 5 6 7 8 9 10 #include //…… int sprintf(char *buf, const char *fmt, ...) { va_list args; int i; va_start(args, fmt); i=vsprintf(buf, fmt, args); va_end(args); return i; } 4.8 cat 命令的实现 cat 是 Linux 下的一个常用命令，功能是将文件的内容打印到标准输出。\n它核心实现大体如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include #include int main(int argc, char* argv[]) { char buf[513] = {'\\0'}; int nread; int fd = open(argv[1], O_RDONLY, 0); while(nread = read(fd, buf, 512)) { buf[nread] = '\\0'; puts(buf); } return 0; } 4.9 psinfo 的内容 进程的信息就来源于内核全局结构数组 struct task_struct * task[NR_TASKS] 中，具体读取细节可参照 sched.c 中的函数 schedule()。\n可以借鉴一下代码：\n1 2 3 4 for(p = \u0026LAST_TASK ; p \u003e \u0026FIRST_TASK ; --p) if (*p) (*p)-\u003ecounter = ((*p)-\u003ecounter \u003e\u003e 1)+...; 4.10 hdinfo 的内容 硬盘总共有多少块，多少块空闲，有多少 inode 等信息都放在 super 块中，super 块可以通过 get_super() 函数获得。\n其中的信息可以借鉴如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 struct super_block * sb; sb = get_super(inode-\u003ei_dev); struct buffer_head * bh; total_blocks = sb-\u003es_nzones; for(i=0; is_zmap_blocks; i++) { bh = sb-\u003es_zmap[i]; p=(char *)bh-\u003eb_data; } 5.实验步骤 1.修改include/sys/stat.h文件 增加新文件类型，在此文件内新增proc文件的宏定义以及测试宏。\n1 2 3 4 5 6 7 8 9 //已有的宏定义 #define S_IFMT 00170000 //文件类型(都是8进制表示) #define S_IFREG 0100000\t//普通文件 #define S_IFCHAR 0020000 //字符设备文件 #define S_ISREG(m) (((m) \u0026 S_IFMT) == S_IFREG) //测试m是否是普通文件 #define S_ISCHAR(m) (((m) \u0026 S_IFMT) == S_IFCHAR) //测试m是否是字符设备文件 //proc文件的宏定义/宏函数 #define S_IFPROC 0030000 #define S_ISPROC(m) (((m) \u0026 S_IFMT) == S_IFPROC) //测试m是否是proc文件 截图如下： 2.修改namei.c文件 文件/proc/psinfo以及/proc/hdinfo索引节点需要通过mknod()系统调用建立，这里需要让它支持新的文件类型。可直接修改fs/namei.c文件中的sys_mknod()函数的一行代码，在其中增加关于proc文件系统的判断:\n1 2 3 4 5 6 if (S_ISBLK(mode) || S_ISCHR(mode) || S_ISPROC(mode)) inode-\u003ei_zone[0] = dev; // 文件系统初始化 inode-\u003ei_mtime = inode-\u003ei_atime = CURRENT_TIME; inode-\u003ei_dirt = 1; bh = add_entry(dir,basename,namelen,\u0026de); 截图如下： 3.修改init/main.c文件 main()函数在init后直接挂载了根文件系统，挂载之后就可以创建proc文件了，首先创建/proc文件目录，然后再建立该目录下的各个proc文件节点。在建立这些节点和目录时需要调用系统调用mkdir和mknod，因为初始化时在用户态了，所以不能直接调用，必须在初始化代码所在的文件中实现这两个系统调用的用户态接口。修改init/main.c，新增两个系统调用用户接口并接着修改init函数实现对其的调用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 static inline _syscall0(int,fork) static inline _syscall0(int,pause) static inline _syscall1(int,setup,void *,BIOS) static inline _syscall0(int,sync) /*新增mkdir和mknode系统调用*/ _syscall2(int,mkdir,const char*,name,mode_t,mode) _syscall3(int,mknod,const char *,filename,mode_t,mode,dev_t,dev) //....... setup((void *) \u0026drive_info); (void) open(\"/dev/tty0\",O_RDWR,0); (void) dup(0); (void) dup(0); mkdir(\"/proc\",0755); mknod(\"/proc/psinfo\",S_IFPROC|0444,0); mknod(\"/proc/hdinfo\",S_IFPROC|0444,1); mknod(\"/proc/inodeinfo\",S_IFPROC|0444,2); 截图如下： mkdir()时mode参数的值可以是“0755”（rwxr-xr-x），表示只允许root用户改写此目录，其它人只能进入和读取此目录。\nprocfs是一个只读文件系统，所以用mknod()建立psinfo结点时，必须通过mode参数将其设为只读。建议使用S_IFPROC|0444做为mode值，表示这是一个proc文件，权限为0444（r–r–r–），对所有用户只读。\nmknod()的第三个参数dev用来说明结点所代表的设备编号。对于procfs来说，此编号可以完全自定义。proc文件的处理函数将通过这个编号决定对应文件包含的信息是什么。例如，可以把0对应psinfo，1对应hdinfo，2对应inodeinfo。 现在可以重新编译运行系统，使用ll /proc可观察到下面的结果：\n这些信息说明内核在对 psinfo 进行读操作时不能正确处理，向 cat 返回了 EINVAL 错误。因为还没有实现处理函数，所以这是很正常的。这些信息至少说明，psinfo被正确open()了。所以我们不需要对sys_open()动任何手脚，唯一要打补丁的，是sys_read()。\n4.修改fs/read_write.c文件 为了让proc文件可读，修改fs/read_write.c添加extern，表示proc_read函数是从外部调用的。\n1 2 /*新增proc_read函数外部调用*/ extern int proc_read(int dev,unsigned long *pos,char* buf,int count); 截图如下： 然后在sys_read函数中仿照其他if语句，加上 S_IFPROC() 的分支，添加proc文件的proc_read()调用：\n1 2 3 4 5 6 7 if (inode-\u003ei_pipe) return (file-\u003ef_mode\u00261)?read_pipe(inode,buf,count):-EIO; /*新增proc_read调用*/ if (S_ISPROC(inode-\u003ei_mode)) return proc_read(inode-\u003ei_zone[0],\u0026file-\u003ef_pos,buf,count); if (S_ISCHR(inode-\u003ei_mode)) return rw_char(READ,inode-\u003ei_zone[0],buf,count,\u0026file-\u003ef_pos); 截图如下： 需要传给处理函数的参数包括：\ninode-\u003ei_zone[0]，这就是 mknod() 时指定的 dev ——设备编号\n\u0026file-\u003ef_pos，f_pos 是上一次读文件结束时“文件位置指针”的指向。这里必须传指针，因为处理函数需要根据传给 buf 的数据量修改 f_pos 的值。\nbuf，指向用户空间，用来接收数据\ncount，说明 buf 指向的缓冲区大小\n5.新增/fs/proc.c文件 proc文件的处理函数的功能是根据设备编号，把不同的内容写入到用户空间的buf。写入的数据要从 f_pos 指向的位置开始，每次最多写count个字节，并根据实际写入的字节数调整 f_pos 的值，最后返回实际写入的字节数。当设备编号表明要读的是psinfo的内容时，就要按照 psinfo 的形式组织数据。在fs目录下新增proc.c文件，文件信息如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 #include #include #include #include #include #include #define set_bit(bitnr,addr) ({ \\ register int __res ; \\ __asm__(\"bt %2,%3;setb %%al\":\"=a\" (__res):\"a\" (0),\"r\" (bitnr),\"m\" (*(addr))); \\ __res; }) char proc_buf[4096] ={'\\0'}; extern int vsprintf(char * buf, const char * fmt, va_list args); //Linux0.11没有sprintf()，该函数是用于输出结果到字符串中的，所以就实现一个，这里是通过vsprintf()实现的。 int sprintf(char *buf, const char *fmt, ...) { va_list args; int i; va_start(args, fmt); i=vsprintf(buf, fmt, args); va_end(args); return i; } int get_psinfo() { int read = 0; read += sprintf(proc_buf+read,\"%s\",\"pid\\tstate\\tfather\\tcounter\\tstart_time\\n\"); struct task_struct **p; for(p = \u0026FIRST_TASK ; p \u003c= \u0026LAST_TASK ; ++p) if (*p != NULL) { read += sprintf(proc_buf+read,\"%d\\t\",(*p)-\u003epid); read += sprintf(proc_buf+read,\"%d\\t\",(*p)-\u003estate); read += sprintf(proc_buf+read,\"%d\\t\",(*p)-\u003efather); read += sprintf(proc_buf+read,\"%d\\t\",(*p)-\u003ecounter); read += sprintf(proc_buf+read,\"%d\\n\",(*p)-\u003estart_time); } return read; } /* * 参考fs/super.c mount_root()函数 */ int get_hdinfo() { int read = 0; int i,used; struct super_block * sb; sb=get_super(0x301); /*磁盘设备号 3*256+1*/ /*Blocks信息*/ read += sprintf(proc_buf+read,\"Total blocks:%d\\n\",sb-\u003es_nzones); used = 0; i=sb-\u003es_nzones; while(--i \u003e= 0) { if(set_bit(i\u00268191,sb-\u003es_zmap[i\u003e\u003e13]-\u003eb_data)) used++; } read += sprintf(proc_buf+read,\"Used blocks:%d\\n\",used); read += sprintf(proc_buf+read,\"Free blocks:%d\\n\",sb-\u003es_nzones-used); /*Inodes 信息*/ read += sprintf(proc_buf+read,\"Total inodes:%d\\n\",sb-\u003es_ninodes); used = 0; i=sb-\u003es_ninodes+1; while(--i \u003e= 0) { if(set_bit(i\u00268191,sb-\u003es_imap[i\u003e\u003e13]-\u003eb_data)) used++; } read += sprintf(proc_buf+read,\"Used inodes:%d\\n\",used); read += sprintf(proc_buf+read,\"Free inodes:%d\\n\",sb-\u003es_ninodes-used); return read; } int get_inodeinfo() { int read = 0; int i; struct super_block * sb; struct m_inode *mi; sb=get_super(0x301); /*磁盘设备号 3*256+1*/ i=sb-\u003es_ninodes+1; i=0; while(++i \u003c sb-\u003es_ninodes+1) { if(set_bit(i\u00268191,sb-\u003es_imap[i\u003e\u003e13]-\u003eb_data)) { mi = iget(0x301,i); read += sprintf(proc_buf+read,\"inr:%d;zone[0]:%d\\n\",mi-\u003ei_num,mi-\u003ei_zone[0]); iput(mi); } if(read \u003e= 4000) { break; } } return read; } int proc_read(int dev, unsigned long * pos, char * buf, int count) { int i; if(*pos % 1024 == 0) { if(dev == 0) get_psinfo(); if(dev == 1) get_hdinfo(); if(dev == 2) get_inodeinfo(); } for(i=0;i\u003ccount;i++) { if(proc_buf[i+ *pos ] == '\\0') break; put_fs_byte(proc_buf[i+ *pos],buf + i+ *pos); } *pos += i; return i; } 新增过程截图如下： 6.修改fs/Makefile文件 1 2 3 4 5 6 7 8 OBJS=\topen.o read_write.o inode.o file_table.o buffer.o super.o \\ block_dev.o char_dev.o file_dev.o stat.o exec.o pipe.o namei.o \\ bitmap.o fcntl.o ioctl.o truncate.o proc.o //...... ### Dependencies: proc.o : proc.c ../include/linux/kernel.h ../include/linux/sched.h \\ ../include/linux/head.h ../include/linux/fs.h ../include/sys/types.h \\ ../include/linux/mm.h ../include/signal.h ../include/asm/segment.h 截图如下： 7.运行验证 重新编译运行linux-0.11 查看psinfo(当前系统进程状态信息)和hdinfo(硬盘信息)的信息，发现符合预期。\n回答问题 meminfo，可以获得内存相关信息，看那些程序占用内存较多，方便管理。 是变化前的，==在读取位置f_pos为0时才更新psinfo内容==。 该inode对应的i_zone[0]依然存在。也就是说，只是从inode映射中取消映射该inode，但是实际上硬盘上的数据还在。 ",
  "wordCount" : "6043",
  "inLanguage": "zh",
  "datePublished": "2022-05-26T00:00:00Z",
  "dateModified": "2022-05-26T00:00:00Z",
  "author":[{
    "@type": "Person",
    "name": "chance7bin"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://chance7bin.github.io/posts/basic/os-lab/%E5%AE%9E%E9%AA%8C9-proc%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%9E%E7%8E%B0/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Binb's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://chance7bin.github.io/img/%E7%BE%8E%E9%98%9F.jpg"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://chance7bin.github.io/" accesskey="h" title="Binb&#39;s Blog (Alt + H)">
                <img src="https://chance7bin.github.io/img/%E7%BE%8E%E9%98%9F.jpg" alt="" aria-label="logo"
                    height="35">Binb&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://chance7bin.github.io/search" title="🔍搜索 (Alt &#43; /)" accesskey=/>
                    <span>🔍搜索</span>
                </a>
            </li>
            <li>
                <a href="https://chance7bin.github.io/" title="🏠 主页">
                    <span>🏠 主页</span>
                </a>
            </li>
            <li>
                <a href="https://chance7bin.github.io/archives/" title="⏱️ 时间轴">
                    <span>⏱️ 时间轴</span>
                </a>
            </li>
            <li>
                <a href="https://chance7bin.github.io/posts" title="📚 文章">
                    <span>📚 文章</span>
                </a>
            </li>
            <li>
                <a href="https://chance7bin.github.io/tags" title="🔖 标签">
                    <span>🔖 标签</span>
                </a>
            </li>
            <li>
                <a href="https://github.com/chance7bin" title="GitHub">
                    <span>GitHub</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://chance7bin.github.io/">🏠 主页</a>&nbsp;»&nbsp;<a href="https://chance7bin.github.io/posts/">📚 文章</a>&nbsp;»&nbsp;<a href="https://chance7bin.github.io/posts/basic/">📕 计算机基础</a>&nbsp;»&nbsp;<a href="https://chance7bin.github.io/posts/basic/os-lab/">hit-oslab</a></div>
    <h1 class="post-title">
      实验9 proc文件系统的实现
    </h1>
    <div class="post-meta">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css">


<style>
    i[id*="post_meta_style"] {
        display: flex;
        align-items: center;
        margin: 0 0 10px 0;
    }

    .parent-post-meta {
        display: flex;
        flex-wrap: wrap;
        opacity: 0.8;
    }
</style>

<span class="parent-post-meta">
    <span id="post_meta_style_1">
        <span class="fa fa-calendar-check-o"></span>
        <span>2022-05-26
            &nbsp;&nbsp;
        </span>
    </span>
    
    
    
    
    
    
    
    <span id="post_meta_style_3">
        <span class="fa fa-file-word-o"></span>
        <span>6043字
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_4">
        <span class="fa fa-clock-o"></span>
        <span>13分钟
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_5">
        <span class="fa fa-user-o"></span>
        <span>chance7bin
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_6">
        <span class="fa fa-tags" style="opacity: 0.8"></span>
        <span>
            <span class="post-tags-meta">
                <a href="https://chance7bin.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="color: var(--secondary)!important;">操作系统</a>
                &nbsp;<a href="https://chance7bin.github.io/tags/%E5%AE%9E%E9%AA%8C/" style="color: var(--secondary)!important;">实验</a>
            </span>
        </span>
    </span>

    
</span>


      
      
      
      
      
      
      
          
          
          
              
              
              
              
          
      
    </div>
  </header>
   <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">目录</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#1%e5%ae%9e%e9%aa%8c%e7%9b%ae%e7%9a%84" aria-label="1.实验目的">1.实验目的</a></li>
                    <li>
                        <a href="#2%e5%ae%9e%e9%aa%8c%e5%86%85%e5%ae%b9" aria-label="2.实验内容">2.实验内容</a></li>
                    <li>
                        <a href="#3%e5%ae%9e%e9%aa%8c%e6%8a%a5%e5%91%8a" aria-label="3.实验报告">3.实验报告</a></li>
                    <li>
                        <a href="#4%e5%ae%9e%e9%aa%8c%e6%8f%90%e7%a4%ba" aria-label="4.实验提示">4.实验提示</a><ul>
                            
                    <li>
                        <a href="#41-procfs-%e7%ae%80%e4%bb%8b" aria-label="4.1 procfs 简介">4.1 procfs 简介</a></li>
                    <li>
                        <a href="#42-%e5%9f%ba%e6%9c%ac%e6%80%9d%e8%b7%af" aria-label="4.2 基本思路">4.2 基本思路</a></li>
                    <li>
                        <a href="#43-%e5%a2%9e%e5%8a%a0%e6%96%b0%e6%96%87%e4%bb%b6%e7%b1%bb%e5%9e%8b" aria-label="4.3 增加新文件类型">4.3 增加新文件类型</a></li>
                    <li>
                        <a href="#44-%e8%ae%a9-mknod-%e6%94%af%e6%8c%81%e6%96%b0%e7%9a%84%e6%96%87%e4%bb%b6%e7%b1%bb%e5%9e%8b" aria-label="4.4 让 mknod() 支持新的文件类型">4.4 让 mknod() 支持新的文件类型</a></li>
                    <li>
                        <a href="#45-%e8%ae%a9-proc-%e6%96%87%e4%bb%b6%e5%8f%af%e8%af%bb" aria-label="4.5 让 proc 文件可读">4.5 让 proc 文件可读</a></li>
                    <li>
                        <a href="#46-proc-%e6%96%87%e4%bb%b6%e7%9a%84%e5%a4%84%e7%90%86%e5%87%bd%e6%95%b0" aria-label="4.6 proc 文件的处理函数">4.6 proc 文件的处理函数</a></li>
                    <li>
                        <a href="#47-%e5%ae%9e%e7%8e%b0-sprintf-%e5%87%bd%e6%95%b0" aria-label="4.7 实现 sprintf() 函数">4.7 实现 sprintf() 函数</a></li>
                    <li>
                        <a href="#48-cat-%e5%91%bd%e4%bb%a4%e7%9a%84%e5%ae%9e%e7%8e%b0" aria-label="4.8 cat 命令的实现">4.8 cat 命令的实现</a></li>
                    <li>
                        <a href="#49-psinfo-%e7%9a%84%e5%86%85%e5%ae%b9" aria-label="4.9 psinfo 的内容">4.9 psinfo 的内容</a></li>
                    <li>
                        <a href="#410-hdinfo-%e7%9a%84%e5%86%85%e5%ae%b9" aria-label="4.10 hdinfo 的内容">4.10 hdinfo 的内容</a></li></ul>
                    </li>
                    <li>
                        <a href="#5%e5%ae%9e%e9%aa%8c%e6%ad%a5%e9%aa%a4" aria-label="5.实验步骤">5.实验步骤</a><ul>
                            
                    <li>
                        <a href="#1%e4%bf%ae%e6%94%b9includesysstath%e6%96%87%e4%bb%b6" aria-label="1.修改include/sys/stat.h文件">1.修改include/sys/stat.h文件</a></li>
                    <li>
                        <a href="#2%e4%bf%ae%e6%94%b9nameic%e6%96%87%e4%bb%b6" aria-label="2.修改namei.c文件">2.修改namei.c文件</a></li>
                    <li>
                        <a href="#3%e4%bf%ae%e6%94%b9initmainc%e6%96%87%e4%bb%b6" aria-label="3.修改init/main.c文件">3.修改init/main.c文件</a></li>
                    <li>
                        <a href="#4%e4%bf%ae%e6%94%b9fsread_writec%e6%96%87%e4%bb%b6" aria-label="4.修改fs/read_write.c文件">4.修改fs/read_write.c文件</a></li>
                    <li>
                        <a href="#5%e6%96%b0%e5%a2%9efsprocc%e6%96%87%e4%bb%b6" aria-label="5.新增/fs/proc.c文件">5.新增/fs/proc.c文件</a></li>
                    <li>
                        <a href="#6%e4%bf%ae%e6%94%b9fsmakefile%e6%96%87%e4%bb%b6" aria-label="6.修改fs/Makefile文件">6.修改fs/Makefile文件</a></li>
                    <li>
                        <a href="#7%e8%bf%90%e8%a1%8c%e9%aa%8c%e8%af%81" aria-label="7.运行验证">7.运行验证</a></li>
                    <li>
                        <a href="#%e5%9b%9e%e7%ad%94%e9%97%ae%e9%a2%98" aria-label="回答问题">回答问题</a>
                    </li>
                </ul>
                </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>
  <div class="post-content"><h2 id="1实验目的">1.实验目的<a hidden class="anchor" aria-hidden="true" href="#1实验目的">#</a></h2>
<ul>
<li>掌握虚拟文件系统的实现原理；</li>
<li>实践文件、目录、文件系统等概念。</li>
</ul>
<h2 id="2实验内容">2.实验内容<a hidden class="anchor" aria-hidden="true" href="#2实验内容">#</a></h2>
<p>/proc文件系统是了解系统信息的一个窗口，它不是普通意义上的文件系统，它是一个到运行中进程地址空间的访问接口。通过/proc，可以用标准Unix系统调用(比如open()、read()、write()等等)访问，就象访问一个普通文件一样。事实上，许多操作系统中的ps命令正是利用/proc来获取进程状态的。因此/proc文件系统是虚拟的文件系统，看似存在的文件实际并没有在硬盘上。其实，/proc是你了解自己系统的一个窗口，它实际存在于内存。</p>
<p>在 Linux 0.11 上实现 procfs（proc 文件系统）内的 psinfo 结点。当读取此结点的内容时，可得到系统当前所有进程的状态信息。例如，用 cat 命令显示 <code>/proc/psinfo</code> 的内容，可得到：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ cat /proc/psinfo
</span></span><span class="line"><span class="cl">pid    state    father    counter    start_time
</span></span><span class="line"><span class="cl"><span class="m">0</span>    <span class="m">1</span>    -1    <span class="m">0</span>    <span class="m">0</span>
</span></span><span class="line"><span class="cl"><span class="m">1</span>    <span class="m">1</span>    <span class="m">0</span>    <span class="m">28</span>    <span class="m">1</span>
</span></span><span class="line"><span class="cl"><span class="m">4</span>    <span class="m">1</span>    <span class="m">1</span>    <span class="m">1</span>    <span class="m">73</span>
</span></span><span class="line"><span class="cl"><span class="m">3</span>    <span class="m">1</span>    <span class="m">1</span>    <span class="m">27</span>    <span class="m">63</span>
</span></span><span class="line"><span class="cl"><span class="m">6</span>    <span class="m">0</span>    <span class="m">4</span>    <span class="m">12</span>    <span class="m">817</span>
</span></span><span class="line"><span class="cl">$ cat /proc/hdinfo
</span></span><span class="line"><span class="cl">total_blocks:    62000<span class="p">;</span>
</span></span><span class="line"><span class="cl">free_blocks:    39037<span class="p">;</span>
</span></span><span class="line"><span class="cl">used_blocks:    22963<span class="p">;</span>
</span></span><span class="line"><span class="cl">...
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>procfs</code> 及其结点要在内核启动时自动创建。</p>
<p>相关功能实现在 <code>fs/proc.c</code> 文件内。</p>
<h2 id="3实验报告">3.实验报告<a hidden class="anchor" aria-hidden="true" href="#3实验报告">#</a></h2>
<p>完成实验后，在实验报告中回答如下问题：</p>
<ul>
<li>如果要求你在 <code>psinfo</code> 之外再实现另一个结点，具体内容自选，那么你会实现一个给出什么信息的结点？为什么？</li>
<li>一次 <code>read()</code> 未必能读出所有的数据，需要继续 <code>read()</code>，直到把数据读空为止。而数次 <code>read()</code> 之间，进程的状态可能会发生变化。你认为后几次 <code>read()</code> 传给用户的数据，应该是变化后的，还是变化前的？
<ul>
<li>如果是变化后的，那么用户得到的数据衔接部分是否会有混乱？如何防止混乱？</li>
<li>如果是变化前的，那么该在什么样的情况下更新 <code>psinfo</code> 的内容？</li>
</ul>
</li>
</ul>
<h2 id="4实验提示">4.实验提示<a hidden class="anchor" aria-hidden="true" href="#4实验提示">#</a></h2>
<p>本实验文档在 Linux 0.11 上实现 <code>procfs</code>（proc 文件系统）内的 <code>psinfo</code> 结点。当读取 <code>psinfo</code> 结点的内容时，可得到系统当前所有进程的状态信息。</p>
<p>最后还给出来 <code>hdinfo</code> 结点实现的提示。</p>
<h3 id="41-procfs-简介">4.1 procfs 简介<a hidden class="anchor" aria-hidden="true" href="#41-procfs-简介">#</a></h3>
<p>正式的 Linux 内核实现了 <code>procfs</code>，它是一个虚拟文件系统，通常被 mount（挂载） 到 <code>/proc</code> 目录上，通过虚拟文件和虚拟目录的方式提供访问系统参数的机会，所以有人称它为 “了解系统信息的一个窗口”。</p>
<p>这些虚拟的文件和目录并没有真实地存在在磁盘上，而是内核中各种数据的一种直观表示。虽然是虚拟的，但它们都可以通过标准的系统调用（<code>open()</code>、<code>read()</code> 等）访问。</p>
<p>例如，<code>/proc/meminfo</code> 中包含内存使用的信息，可以用 cat 命令显示其内容：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ cat /proc/meminfo
</span></span><span class="line"><span class="cl">MemTotal:       <span class="m">384780</span> kB
</span></span><span class="line"><span class="cl">MemFree:         <span class="m">13636</span> kB
</span></span><span class="line"><span class="cl">Buffers:         <span class="m">13928</span> kB
</span></span><span class="line"><span class="cl">Cached:         <span class="m">101680</span> kB
</span></span><span class="line"><span class="cl">SwapCached:        <span class="m">132</span> kB
</span></span><span class="line"><span class="cl">Active:         <span class="m">207764</span> kB
</span></span><span class="line"><span class="cl">Inactive:        <span class="m">45720</span> kB
</span></span><span class="line"><span class="cl">SwapTotal:      <span class="m">329324</span> kB
</span></span><span class="line"><span class="cl">SwapFree:       <span class="m">329192</span> kB
</span></span><span class="line"><span class="cl">Dirty:               <span class="m">0</span> kB
</span></span><span class="line"><span class="cl">Writeback:           <span class="m">0</span> kB
</span></span><span class="line"><span class="cl">……
</span></span></code></pre></td></tr></table>
</div>
</div><p>其实，Linux 的很多系统命令就是通过读取 <code>/proc</code> 实现的。例如 <code>uname -a</code> 的部分信息就来自 <code>/proc/version</code>，而 <code>uptime</code> 的部分信息来自 <code>/proc/uptime</code> 和 <code>/proc/loadavg</code>。</p>
<p>关于 procfs 更多的信息请访问：http://en.wikipedia.org/wiki/Procfs</p>
<h3 id="42-基本思路">4.2 基本思路<a hidden class="anchor" aria-hidden="true" href="#42-基本思路">#</a></h3>
<p>Linux 是通过文件系统接口实现 <code>procfs</code>，并在启动时自动将其 mount 到 <code>/proc</code> 目录上。</p>
<p>此目录下的所有内容都是随着系统的运行自动建立、删除和更新的，而且它们完全存在于内存中，不占用任何外存空间。</p>
<p>Linux 0.11 还没有实现虚拟文件系统，也就是，还没有提供增加新文件系统支持的接口。所以本实验只能在现有文件系统的基础上，通过打补丁的方式模拟一个 <code>procfs</code>。</p>
<p>Linux 0.11 使用的是 Minix 的文件系统，这是一个典型的基于 <code>inode</code> 的文件系统，《注释》一书对它有详细描述。它的每个文件都要对应至少一个 inode，而 inode 中记录着文件的各种属性，包括文件类型。文件类型有普通文件、目录、字符设备文件和块设备文件等。在内核中，每种类型的文件都有不同的处理函数与之对应。我们可以增加一种新的文件类型——proc 文件，并在相应的处理函数内实现 procfs 要实现的功能。</p>
<h3 id="43-增加新文件类型">4.3 增加新文件类型<a hidden class="anchor" aria-hidden="true" href="#43-增加新文件类型">#</a></h3>
<p>在 <code>include/sys/stat.h</code> 文件中定义了几种文件类型和相应的测试宏：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#define S_IFMT  00170000
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 普通文件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define S_IFREG  0100000
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 块设备
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define S_IFBLK  0060000
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 目录
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define S_IFDIR  0040000
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 字符设备
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define S_IFCHR  0020000
</span></span></span><span class="line"><span class="cl"><span class="cp">#define S_IFIFO  0010000
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="c1">//……
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 测试 m 是否是普通文件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define S_ISREG(m)      (((m) &amp; S_IFMT) == S_IFREG)
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 测试 m 是否是目录
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define S_ISDIR(m)      (((m) &amp; S_IFMT) == S_IFDIR)
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 测试 m 是否是字符设备
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define S_ISCHR(m)      (((m) &amp; S_IFMT) == S_IFCHR)
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 测试 m 是否是块设备
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define S_ISBLK(m)      (((m) &amp; S_IFMT) == S_IFBLK)
</span></span></span><span class="line"><span class="cl"><span class="cp">#define S_ISFIFO(m)     (((m) &amp; S_IFMT) == S_IFIFO)
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>增加新的类型的方法分两步：</p>
<ul>
<li>（1）定义一个类型宏 <code>S_IFPROC</code>，其值应在 <code>0010000</code> 到 <code>0100000</code> 之间，但后四位八进制数必须是 0（这是 <code>S_IFMT</code> 的限制，分析测试宏可知原因），而且不能和已有的任意一个 <code>S_IFXXX</code> 相同；</li>
<li>（2）定义一个测试宏 <code>S_ISPROC(m)</code>，形式仿照其它的 <code>S_ISXXX(m)</code></li>
</ul>
<p>注意，C 语言中以 “0” 直接接数字的常数是八进制数。</p>
<h3 id="44-让-mknod-支持新的文件类型">4.4 让 mknod() 支持新的文件类型<a hidden class="anchor" aria-hidden="true" href="#44-让-mknod-支持新的文件类型">#</a></h3>
<p>psinfo 结点要通过 <code>mknod()</code> 系统调用建立，所以要让它支持新的文件类型。</p>
<p>直接修改 <code>fs/namei.c</code> 文件中的 <code>sys_mknod()</code> 函数中的一行代码，如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="nf">S_ISBLK</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="o">||</span> <span class="nf">S_ISCHR</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="o">||</span> <span class="nf">S_ISPROC</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">     <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_zone</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 文件系统初始化
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>内核初始化的全部工作是在 <code>main()</code> 中完成，而 <code>main()</code> 在最后从内核态切换到用户态，并调用 <code>init()</code>。</p>
<p><code>init()</code> 做的第一件事情就是挂载根文件系统：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="c1">//    ……
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">setup</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">drive_info</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">//    ……
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>procfs</code> 的初始化工作应该在根文件系统挂载之后开始。它包括两个步骤：</p>
<ul>
<li>（1）建立 <code>/proc</code> 目录；建立 <code>/proc</code> 目录下的各个结点。本实验只建立 <code>/proc/psinfo</code>。</li>
<li>（2）建立目录和结点分别需要调用 <code>mkdir()</code> 和 <code>mknod()</code> 系统调用。因为初始化时已经在用户态，所以不能直接调用 <code>sys_mkdir()</code> 和 <code>sys_mknod()</code>。必须在初始化代码所在文件中实现这两个系统调用的用户态接口，即 API：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#ifndef __LIBRARY__
</span></span></span><span class="line"><span class="cl"><span class="cp">#define __LIBRARY__
</span></span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="nf">_syscall2</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="n">mkdir</span><span class="p">,</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="kt">mode_t</span><span class="p">,</span><span class="n">mode</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nf">_syscall3</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="n">mknod</span><span class="p">,</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">,</span><span class="n">filename</span><span class="p">,</span><span class="kt">mode_t</span><span class="p">,</span><span class="n">mode</span><span class="p">,</span><span class="kt">dev_t</span><span class="p">,</span><span class="n">dev</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>mkdir()</code> 时 mode 参数的值可以是 “0755”（对应 <code>rwxr-xr-x</code>），表示只允许 root 用户改写此目录，其它人只能进入和读取此目录。</p>
<p>procfs 是一个只读文件系统，所以用 <code>mknod()</code> 建立 psinfo 结点时，必须通过 mode 参数将其设为只读。建议使用 <code>S_IFPROC|0444</code> 做为 mode 值，表示这是一个 proc 文件，权限为 0444（r&ndash;r&ndash;r&ndash;），对所有用户只读。</p>
<p><code>mknod()</code> 的第三个参数 dev 用来说明结点所代表的设备编号。对于 procfs 来说，此编号可以完全自定义。proc 文件的处理函数将通过这个编号决定对应文件包含的信息是什么。例如，可以把 0 对应 psinfo，1 对应 meminfo，2 对应 cpuinfo。</p>
<p>如此项工作完成得没有问题，那么编译、运行 0.11 内核后，用 <code>ll /proc</code> 可以看到：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># ll /proc</span>
</span></span><span class="line"><span class="cl">total <span class="m">0</span>
</span></span><span class="line"><span class="cl">?r--r--r--   <span class="m">1</span> root     root              <span class="m">0</span> ??? ??  ???? psinfo
</span></span></code></pre></td></tr></table>
</div>
</div><p>此时可以试着读一下此文件：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># cat /proc/psinfo</span>
</span></span><span class="line"><span class="cl"><span class="o">(</span>Read<span class="o">)</span>inode-&gt;i_mode<span class="o">=</span>XXX444
</span></span><span class="line"><span class="cl">cat: /proc/psinfo: EINVAL
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>inode-&gt;i_mode</code> 就是通过 <code>mknod()</code> 设置的 mode。信息中的 XXX 和你设置的 <code>S_IFPROC</code> 有关。通过此值可以了解 <code>mknod()</code> 工作是否正常。这些信息说明内核在对 <code>psinfo</code> 进行读操作时不能正确处理，向 cat 返回了 EINVAL 错误。因为还没有实现处理函数，所以这是很正常的。</p>
<p>这些信息至少说明，psinfo 被正确 <code>open()</code> 了。所以我们不需要对 <code>sys_open()</code> 动任何手脚，唯一要打补丁的，是 <code>sys_read()</code>。</p>
<h3 id="45-让-proc-文件可读">4.5 让 proc 文件可读<a hidden class="anchor" aria-hidden="true" href="#45-让-proc-文件可读">#</a></h3>
<p><code>open()</code> 没有变化，那么需要修改的就是 <code>sys_read()</code> 了。</p>
<p>首先分析 <code>sys_read</code>（在文件 <code>fs/read_write.c</code> 中）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">sys_read</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span><span class="kt">char</span> <span class="o">*</span> <span class="n">buf</span><span class="p">,</span><span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span> <span class="n">file</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">m_inode</span> <span class="o">*</span> <span class="n">inode</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">//    ……
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_inode</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_pipe</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">)</span><span class="o">?</span><span class="nf">read_pipe</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span><span class="n">buf</span><span class="p">,</span><span class="n">count</span><span class="p">)</span><span class="o">:-</span><span class="n">EIO</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nf">S_ISCHR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nf">rw_char</span><span class="p">(</span><span class="n">READ</span><span class="p">,</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_zone</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">buf</span><span class="p">,</span><span class="n">count</span><span class="p">,</span><span class="o">&amp;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nf">S_ISBLK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nf">block_read</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_zone</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="o">&amp;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="p">,</span><span class="n">buf</span><span class="p">,</span><span class="n">count</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nf">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">||</span> <span class="nf">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">count</span><span class="o">+</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_pos</span> <span class="o">&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">count</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">-</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">count</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nf">file_read</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span><span class="n">file</span><span class="p">,</span><span class="n">buf</span><span class="p">,</span><span class="n">count</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">printk</span><span class="p">(</span><span class="s">&#34;(Read)inode-&gt;i_mode=%06o</span><span class="se">\n\r</span><span class="s">&#34;</span><span class="p">,</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">);</span>    <span class="c1">//这条信息很面善吧？
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>显然，要在这里一群 if 的排比中，加上 <code>S_IFPROC()</code> 的分支，进入对 proc 文件的处理函数。需要传给处理函数的参数包括：</p>
<ul>
<li><code>inode-&gt;i_zone[0]</code>，这就是 <code>mknod()</code> 时指定的 <code>dev</code> ——设备编号</li>
<li><code>buf</code>，指向用户空间，就是 <code>read()</code> 的第二个参数，用来接收数据</li>
<li><code>count</code>，就是 <code>read()</code> 的第三个参数，说明 <code>buf</code> 指向的缓冲区大小</li>
<li><code>&amp;file-&gt;f_pos</code>，<code>f_pos</code> 是上一次读文件结束时“文件位置指针”的指向。这里必须传指针，因为处理函数需要根据传给 <code>buf</code> 的数据量修改 <code>f_pos</code> 的值。</li>
</ul>
<h3 id="46-proc-文件的处理函数">4.6 proc 文件的处理函数<a hidden class="anchor" aria-hidden="true" href="#46-proc-文件的处理函数">#</a></h3>
<p>proc 文件的处理函数的功能是根据设备编号，把不同的内容写入到用户空间的 buf。写入的数据要从 <code>f_pos</code> 指向的位置开始，每次最多写 count 个字节，并根据实际写入的字节数调整 <code>f_pos</code> 的值，最后返回实际写入的字节数。当设备编号表明要读的是 psinfo 的内容时，就要按照 psinfo 的形式组织数据。</p>
<p>实现此函数可能要用到如下几个函数：</p>
<ul>
<li>malloc() 函数</li>
<li>free() 函数</li>
</ul>
<p>包含 <code>linux/kernel.h</code> 头文件后，就可以使用 <code>malloc()</code> 和 <code>free()</code> 函数。它们是可以被核心态代码调用的，唯一的限制是一次申请的内存大小不能超过一个页面。</p>
<h3 id="47-实现-sprintf-函数">4.7 实现 sprintf() 函数<a hidden class="anchor" aria-hidden="true" href="#47-实现-sprintf-函数">#</a></h3>
<p>Linux 0.11 没有 <code>sprintf()</code>，可以参考 <code>printf()</code> 自己实现一个。</p>
<p>可以借鉴如下代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdarg.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="c1">//……
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">sprintf</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">va_list</span> <span class="n">args</span><span class="p">;</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">va_start</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">i</span><span class="o">=</span><span class="nf">vsprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">va_end</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="48-cat-命令的实现">4.8 cat 命令的实现<a hidden class="anchor" aria-hidden="true" href="#48-cat-命令的实现">#</a></h3>
<p>cat 是 Linux 下的一个常用命令，功能是将文件的内容打印到标准输出。</p>
<p>它核心实现大体如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">513</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="sc">&#39;\0&#39;</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">nread</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="nf">open</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">O_RDONLY</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">nread</span> <span class="o">=</span> <span class="nf">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">512</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">buf</span><span class="p">[</span><span class="n">nread</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nf">puts</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="49-psinfo-的内容">4.9 psinfo 的内容<a hidden class="anchor" aria-hidden="true" href="#49-psinfo-的内容">#</a></h3>
<p>进程的信息就来源于内核全局结构数组 <code>struct task_struct * task[NR_TASKS]</code> 中，具体读取细节可参照 <code>sched.c</code> 中的函数 <code>schedule()</code>。</p>
<p>可以借鉴一下代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">for</span><span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">LAST_TASK</span> <span class="p">;</span> <span class="n">p</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">FIRST_TASK</span> <span class="p">;</span> <span class="o">--</span><span class="n">p</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">counter</span> <span class="o">=</span> <span class="p">((</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">counter</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="p">...;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="410-hdinfo-的内容">4.10 hdinfo 的内容<a hidden class="anchor" aria-hidden="true" href="#410-hdinfo-的内容">#</a></h3>
<p>硬盘总共有多少块，多少块空闲，有多少 inode 等信息都放在 super 块中，super 块可以通过 <code>get_super()</code> 函数获得。</p>
<p>其中的信息可以借鉴如下代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span> <span class="n">sb</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">sb</span> <span class="o">=</span> <span class="nf">get_super</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_dev</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span> <span class="n">bh</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">total_blocks</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_nzones</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">is_zmap_blocks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">bh</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_zmap</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="n">p</span><span class="o">=</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="5实验步骤">5.实验步骤<a hidden class="anchor" aria-hidden="true" href="#5实验步骤">#</a></h2>
<h3 id="1修改includesysstath文件">1.修改include/sys/stat.h文件<a hidden class="anchor" aria-hidden="true" href="#1修改includesysstath文件">#</a></h3>
<p>增加新文件类型，在此文件内新增<em>proc</em>文件的宏定义以及测试宏。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">//已有的宏定义
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define S_IFMT 00170000 </span><span class="c1">//文件类型(都是8进制表示)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define S_IFREG 0100000	</span><span class="c1">//普通文件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define S_IFCHAR 0020000 </span><span class="c1">//字符设备文件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define S_ISREG(m)  (((m) &amp; S_IFMT) == S_IFREG) </span><span class="c1">//测试m是否是普通文件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define S_ISCHAR(m) (((m) &amp; S_IFMT) == S_IFCHAR) </span><span class="c1">//测试m是否是字符设备文件
</span></span></span><span class="line"><span class="cl"><span class="c1">//proc文件的宏定义/宏函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define S_IFPROC 0030000
</span></span></span><span class="line"><span class="cl"><span class="cp">#define S_ISPROC(m) (((m) &amp; S_IFMT) ==  S_IFPROC) </span><span class="c1">//测试m是否是proc文件
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>截图如下：
<img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012342719.png" alt="img"  />
</p>
<h3 id="2修改nameic文件">2.修改namei.c文件<a hidden class="anchor" aria-hidden="true" href="#2修改nameic文件">#</a></h3>
<p>文件/proc/psinfo以及/proc/hdinfo索引节点需要通过mknod()系统调用建立，这里需要让它支持新的文件类型。可直接修改fs/namei.c文件中的sys_mknod()函数的一行代码，在其中增加关于proc文件系统的判断:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="nf">S_ISBLK</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="o">||</span> <span class="nf">S_ISCHR</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="o">||</span> <span class="nf">S_ISPROC</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">     <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_zone</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 文件系统初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span> <span class="o">=</span> <span class="n">CURRENT_TIME</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_dirt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">bh</span> <span class="o">=</span> <span class="nf">add_entry</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span><span class="n">basename</span><span class="p">,</span><span class="n">namelen</span><span class="p">,</span><span class="o">&amp;</span><span class="n">de</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>截图如下：
<img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012342729.png" alt="img"  />
</p>
<h3 id="3修改initmainc文件">3.修改init/main.c文件<a hidden class="anchor" aria-hidden="true" href="#3修改initmainc文件">#</a></h3>
<p>main()函数在init后直接挂载了根文件系统，挂载之后就可以创建proc文件了，首先创建/proc文件目录，然后再建立该目录下的各个proc文件节点。在建立这些节点和目录时需要调用系统调用mkdir和mknod，因为初始化时在用户态了，所以不能直接调用，必须在初始化代码所在的文件中实现这两个系统调用的用户态接口。修改init/main.c，新增两个系统调用用户接口并接着修改init函数实现对其的调用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="kr">inline</span> <span class="nf">_syscall0</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="n">fork</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kr">inline</span> <span class="nf">_syscall0</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="n">pause</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kr">inline</span> <span class="nf">_syscall1</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="n">setup</span><span class="p">,</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span><span class="n">BIOS</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kr">inline</span> <span class="nf">_syscall0</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="n">sync</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="cm">/*新增mkdir和mknode系统调用*/</span>
</span></span><span class="line"><span class="cl"><span class="nf">_syscall2</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="n">mkdir</span><span class="p">,</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="kt">mode_t</span><span class="p">,</span><span class="n">mode</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nf">_syscall3</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="n">mknod</span><span class="p">,</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span><span class="n">filename</span><span class="p">,</span><span class="kt">mode_t</span><span class="p">,</span><span class="n">mode</span><span class="p">,</span><span class="kt">dev_t</span><span class="p">,</span><span class="n">dev</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl"><span class="c1">//.......   
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">	<span class="nf">setup</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">drive_info</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="nf">open</span><span class="p">(</span><span class="s">&#34;/dev/tty0&#34;</span><span class="p">,</span><span class="n">O_RDWR</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="nf">dup</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="nf">dup</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="nf">mkdir</span><span class="p">(</span><span class="s">&#34;/proc&#34;</span><span class="p">,</span><span class="mo">0755</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="nf">mknod</span><span class="p">(</span><span class="s">&#34;/proc/psinfo&#34;</span><span class="p">,</span><span class="n">S_IFPROC</span><span class="o">|</span><span class="mo">0444</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="nf">mknod</span><span class="p">(</span><span class="s">&#34;/proc/hdinfo&#34;</span><span class="p">,</span><span class="n">S_IFPROC</span><span class="o">|</span><span class="mo">0444</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="nf">mknod</span><span class="p">(</span><span class="s">&#34;/proc/inodeinfo&#34;</span><span class="p">,</span><span class="n">S_IFPROC</span><span class="o">|</span><span class="mo">0444</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>截图如下：
<img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012342755.png" alt="img"  />

<img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012342745.png" alt="img"  />
</p>
<p>mkdir()时mode参数的值可以是“0755”（rwxr-xr-x），表示只允许root用户改写此目录，其它人只能进入和读取此目录。</p>
<p>procfs是一个只读文件系统，所以用mknod()建立psinfo结点时，必须通过mode参数将其设为只读。建议使用S_IFPROC|0444做为mode值，表示这是一个proc文件，权限为0444（r&ndash;r&ndash;r&ndash;），对所有用户只读。</p>
<p>mknod()的第三个参数dev用来说明结点所代表的设备编号。对于procfs来说，此编号可以完全自定义。proc文件的处理函数将通过这个编号决定对应文件包含的信息是什么。例如，可以把0对应psinfo，1对应hdinfo，2对应inodeinfo。
现在可以重新编译运行系统，使用<code>ll /proc</code>可观察到下面的结果：</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012342740.png" alt="img"  />
</p>
<p>这些信息说明内核在对 psinfo 进行读操作时不能正确处理，向 cat 返回了 EINVAL 错误。因为还没有实现处理函数，所以这是很正常的。这些信息至少说明，psinfo被正确open()了。所以我们不需要对sys_open()动任何手脚，唯一要打补丁的，是sys_read()。</p>
<h3 id="4修改fsread_writec文件">4.修改fs/read_write.c文件<a hidden class="anchor" aria-hidden="true" href="#4修改fsread_writec文件">#</a></h3>
<p>为了让proc文件可读，修改fs/read_write.c添加extern，表示proc_read函数是从外部调用的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/*新增proc_read函数外部调用*/</span>
</span></span><span class="line"><span class="cl"><span class="k">extern</span> <span class="kt">int</span> <span class="nf">proc_read</span><span class="p">(</span><span class="kt">int</span> <span class="n">dev</span><span class="p">,</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">pos</span><span class="p">,</span><span class="kt">char</span><span class="o">*</span> <span class="n">buf</span><span class="p">,</span><span class="kt">int</span> <span class="n">count</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>截图如下：
<img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012342768.png" alt="image-20220413145744144"  />
</p>
<p>然后在sys_read函数中仿照其他if语句，加上 S_IFPROC() 的分支，添加proc文件的proc_read()调用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_pipe</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">)</span><span class="o">?</span><span class="nf">read_pipe</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span><span class="n">buf</span><span class="p">,</span><span class="n">count</span><span class="p">)</span><span class="o">:-</span><span class="n">EIO</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="cm">/*新增proc_read调用*/</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="nf">S_ISPROC</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nf">proc_read</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_zone</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="o">&amp;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="p">,</span><span class="n">buf</span><span class="p">,</span><span class="n">count</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="nf">S_ISCHR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nf">rw_char</span><span class="p">(</span><span class="n">READ</span><span class="p">,</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_zone</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">buf</span><span class="p">,</span><span class="n">count</span><span class="p">,</span><span class="o">&amp;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>截图如下：
<img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012342570.png" alt="img"  />
</p>
<p>需要传给处理函数的参数包括：</p>
<ul>
<li>
<p>inode-&gt;i_zone[0]，这就是 mknod() 时指定的 dev ——设备编号</p>
</li>
<li>
<p>&amp;file-&gt;f_pos，f_pos 是上一次读文件结束时“文件位置指针”的指向。这里必须传指针，因为处理函数需要根据传给 buf 的数据量修改 f_pos 的值。</p>
</li>
<li>
<p>buf，指向用户空间，用来接收数据</p>
</li>
<li>
<p>count，说明 buf 指向的缓冲区大小</p>
</li>
</ul>
<h3 id="5新增fsprocc文件">5.新增/fs/proc.c文件<a hidden class="anchor" aria-hidden="true" href="#5新增fsprocc文件">#</a></h3>
<p>proc文件的处理函数的功能是根据设备编号，把不同的内容写入到用户空间的buf。写入的数据要从 f_pos 指向的位置开始，每次最多写count个字节，并根据实际写入的字节数调整 f_pos 的值，最后返回实际写入的字节数。当设备编号表明要读的是psinfo的内容时，就要按照 psinfo 的形式组织数据。在fs目录下新增proc.c文件，文件信息如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;linux/kernel.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;linux/sched.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;asm/segment.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;linux/fs.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdarg.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#define set_bit(bitnr,addr) ({ \
</span></span></span><span class="line"><span class="cl"><span class="cp">register int __res ; \
</span></span></span><span class="line"><span class="cl"><span class="cp">__asm__(&#34;bt %2,%3;setb %%al&#34;:&#34;=a&#34; (__res):&#34;a&#34; (0),&#34;r&#34; (bitnr),&#34;m&#34; (*(addr))); \
</span></span></span><span class="line"><span class="cl"><span class="cp">__res; })
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">char</span> <span class="n">proc_buf</span><span class="p">[</span><span class="mi">4096</span><span class="p">]</span> <span class="o">=</span><span class="p">{</span><span class="sc">&#39;\0&#39;</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">extern</span> <span class="kt">int</span> <span class="nf">vsprintf</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span> <span class="n">buf</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">va_list</span> <span class="n">args</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//Linux0.11没有sprintf()，该函数是用于输出结果到字符串中的，所以就实现一个，这里是通过vsprintf()实现的。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">sprintf</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">va_list</span> <span class="n">args</span><span class="p">;</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="nf">va_start</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">i</span><span class="o">=</span><span class="nf">vsprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="nf">va_end</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">get_psinfo</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">read</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">read</span> <span class="o">+=</span> <span class="nf">sprintf</span><span class="p">(</span><span class="n">proc_buf</span><span class="o">+</span><span class="n">read</span><span class="p">,</span><span class="s">&#34;%s&#34;</span><span class="p">,</span><span class="s">&#34;pid</span><span class="se">\t</span><span class="s">state</span><span class="se">\t</span><span class="s">father</span><span class="se">\t</span><span class="s">counter</span><span class="se">\t</span><span class="s">start_time</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">**</span><span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span><span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">FIRST_TASK</span> <span class="p">;</span> <span class="n">p</span> <span class="o">&lt;=</span> <span class="o">&amp;</span><span class="n">LAST_TASK</span> <span class="p">;</span> <span class="o">++</span><span class="n">p</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> 	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> 	<span class="p">{</span>
</span></span><span class="line"><span class="cl"> 		<span class="n">read</span> <span class="o">+=</span> <span class="nf">sprintf</span><span class="p">(</span><span class="n">proc_buf</span><span class="o">+</span><span class="n">read</span><span class="p">,</span><span class="s">&#34;%d</span><span class="se">\t</span><span class="s">&#34;</span><span class="p">,(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> 		<span class="n">read</span> <span class="o">+=</span> <span class="nf">sprintf</span><span class="p">(</span><span class="n">proc_buf</span><span class="o">+</span><span class="n">read</span><span class="p">,</span><span class="s">&#34;%d</span><span class="se">\t</span><span class="s">&#34;</span><span class="p">,(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> 		<span class="n">read</span> <span class="o">+=</span> <span class="nf">sprintf</span><span class="p">(</span><span class="n">proc_buf</span><span class="o">+</span><span class="n">read</span><span class="p">,</span><span class="s">&#34;%d</span><span class="se">\t</span><span class="s">&#34;</span><span class="p">,(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">father</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> 		<span class="n">read</span> <span class="o">+=</span> <span class="nf">sprintf</span><span class="p">(</span><span class="n">proc_buf</span><span class="o">+</span><span class="n">read</span><span class="p">,</span><span class="s">&#34;%d</span><span class="se">\t</span><span class="s">&#34;</span><span class="p">,(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">counter</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> 		<span class="n">read</span> <span class="o">+=</span> <span class="nf">sprintf</span><span class="p">(</span><span class="n">proc_buf</span><span class="o">+</span><span class="n">read</span><span class="p">,</span><span class="s">&#34;%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">start_time</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> 	<span class="p">}</span>
</span></span><span class="line"><span class="cl"> 	<span class="k">return</span> <span class="n">read</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">*  参考fs/super.c mount_root()函数
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">get_hdinfo</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">read</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">used</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span> <span class="n">sb</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">sb</span><span class="o">=</span><span class="nf">get_super</span><span class="p">(</span><span class="mh">0x301</span><span class="p">);</span>  <span class="cm">/*磁盘设备号 3*256+1*/</span>
</span></span><span class="line"><span class="cl">	<span class="cm">/*Blocks信息*/</span>
</span></span><span class="line"><span class="cl">	<span class="n">read</span> <span class="o">+=</span> <span class="nf">sprintf</span><span class="p">(</span><span class="n">proc_buf</span><span class="o">+</span><span class="n">read</span><span class="p">,</span><span class="s">&#34;Total blocks:%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_nzones</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">used</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">i</span><span class="o">=</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_nzones</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">while</span><span class="p">(</span><span class="o">--</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span><span class="p">(</span><span class="nf">set_bit</span><span class="p">(</span><span class="n">i</span><span class="o">&amp;</span><span class="mi">8191</span><span class="p">,</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_zmap</span><span class="p">[</span><span class="n">i</span><span class="o">&gt;&gt;</span><span class="mi">13</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">			<span class="n">used</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="n">read</span> <span class="o">+=</span> <span class="nf">sprintf</span><span class="p">(</span><span class="n">proc_buf</span><span class="o">+</span><span class="n">read</span><span class="p">,</span><span class="s">&#34;Used blocks:%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">used</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">read</span> <span class="o">+=</span> <span class="nf">sprintf</span><span class="p">(</span><span class="n">proc_buf</span><span class="o">+</span><span class="n">read</span><span class="p">,</span><span class="s">&#34;Free blocks:%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_nzones</span><span class="o">-</span><span class="n">used</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="cm">/*Inodes 信息*/</span>
</span></span><span class="line"><span class="cl">	<span class="n">read</span> <span class="o">+=</span> <span class="nf">sprintf</span><span class="p">(</span><span class="n">proc_buf</span><span class="o">+</span><span class="n">read</span><span class="p">,</span><span class="s">&#34;Total inodes:%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_ninodes</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">used</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">i</span><span class="o">=</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_ninodes</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">while</span><span class="p">(</span><span class="o">--</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span><span class="p">(</span><span class="nf">set_bit</span><span class="p">(</span><span class="n">i</span><span class="o">&amp;</span><span class="mi">8191</span><span class="p">,</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_imap</span><span class="p">[</span><span class="n">i</span><span class="o">&gt;&gt;</span><span class="mi">13</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">			<span class="n">used</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="n">read</span> <span class="o">+=</span> <span class="nf">sprintf</span><span class="p">(</span><span class="n">proc_buf</span><span class="o">+</span><span class="n">read</span><span class="p">,</span><span class="s">&#34;Used inodes:%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">used</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">read</span> <span class="o">+=</span> <span class="nf">sprintf</span><span class="p">(</span><span class="n">proc_buf</span><span class="o">+</span><span class="n">read</span><span class="p">,</span><span class="s">&#34;Free inodes:%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_ninodes</span><span class="o">-</span><span class="n">used</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> 	<span class="k">return</span> <span class="n">read</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">get_inodeinfo</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">read</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span> <span class="n">sb</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">struct</span> <span class="n">m_inode</span> <span class="o">*</span><span class="n">mi</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">sb</span><span class="o">=</span><span class="nf">get_super</span><span class="p">(</span><span class="mh">0x301</span><span class="p">);</span>  <span class="cm">/*磁盘设备号 3*256+1*/</span>
</span></span><span class="line"><span class="cl">	<span class="n">i</span><span class="o">=</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_ninodes</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">while</span><span class="p">(</span><span class="o">++</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_ninodes</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span><span class="p">(</span><span class="nf">set_bit</span><span class="p">(</span><span class="n">i</span><span class="o">&amp;</span><span class="mi">8191</span><span class="p">,</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_imap</span><span class="p">[</span><span class="n">i</span><span class="o">&gt;&gt;</span><span class="mi">13</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">mi</span> <span class="o">=</span> <span class="nf">iget</span><span class="p">(</span><span class="mh">0x301</span><span class="p">,</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">			<span class="n">read</span> <span class="o">+=</span> <span class="nf">sprintf</span><span class="p">(</span><span class="n">proc_buf</span><span class="o">+</span><span class="n">read</span><span class="p">,</span><span class="s">&#34;inr:%d;zone[0]:%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">mi</span><span class="o">-&gt;</span><span class="n">i_num</span><span class="p">,</span><span class="n">mi</span><span class="o">-&gt;</span><span class="n">i_zone</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">			<span class="nf">iput</span><span class="p">(</span><span class="n">mi</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span><span class="p">(</span><span class="n">read</span> <span class="o">&gt;=</span> <span class="mi">4000</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">		<span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"> 	<span class="k">return</span> <span class="n">read</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">proc_read</span><span class="p">(</span><span class="kt">int</span> <span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl"> 	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="n">pos</span> <span class="o">%</span> <span class="mi">1024</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span><span class="p">(</span><span class="n">dev</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nf">get_psinfo</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span><span class="p">(</span><span class="n">dev</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nf">get_hdinfo</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span><span class="p">(</span><span class="n">dev</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nf">get_inodeinfo</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"> 	<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">count</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> 	<span class="p">{</span>
</span></span><span class="line"><span class="cl"> 		<span class="k">if</span><span class="p">(</span><span class="n">proc_buf</span><span class="p">[</span><span class="n">i</span><span class="o">+</span> <span class="o">*</span><span class="n">pos</span> <span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">          <span class="k">break</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"> 		<span class="nf">put_fs_byte</span><span class="p">(</span><span class="n">proc_buf</span><span class="p">[</span><span class="n">i</span><span class="o">+</span> <span class="o">*</span><span class="n">pos</span><span class="p">],</span><span class="n">buf</span> <span class="o">+</span> <span class="n">i</span><span class="o">+</span> <span class="o">*</span><span class="n">pos</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> 	<span class="p">}</span>
</span></span><span class="line"><span class="cl"> 	<span class="o">*</span><span class="n">pos</span> <span class="o">+=</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 	<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>新增过程截图如下：
<img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012342594.png" alt="img"  />
</p>
<h3 id="6修改fsmakefile文件">6.修改fs/Makefile文件<a hidden class="anchor" aria-hidden="true" href="#6修改fsmakefile文件">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="nv">OBJS</span><span class="o">=</span>	open.o read_write.o inode.o file_table.o buffer.o super.o <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>	block_dev.o char_dev.o file_dev.o stat.o exec.o pipe.o namei.o <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>	bitmap.o fcntl.o ioctl.o truncate.o proc.o
</span></span><span class="line"><span class="cl">//......
</span></span><span class="line"><span class="cl"><span class="c1">### Dependencies:</span>
</span></span><span class="line"><span class="cl">proc.o : proc.c ../include/linux/kernel.h ../include/linux/sched.h <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  ../include/linux/head.h ../include/linux/fs.h ../include/sys/types.h <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  ../include/linux/mm.h ../include/signal.h ../include/asm/segment.h
</span></span></code></pre></td></tr></table>
</div>
</div><p>截图如下：
<img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012342623.png" alt="img"  />
</p>
<h3 id="7运行验证">7.运行验证<a hidden class="anchor" aria-hidden="true" href="#7运行验证">#</a></h3>
<p>重新编译运行linux-0.11
<img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012342649.png" alt="img"  />
</p>
<p>查看psinfo(当前系统进程状态信息)和hdinfo(硬盘信息)的信息，发现符合预期。</p>
<h3 id="回答问题">回答问题<a hidden class="anchor" aria-hidden="true" href="#回答问题">#</a></h3>
<ol>
<li>meminfo，可以获得内存相关信息，看那些程序占用内存较多，方便管理。</li>
<li>是变化前的，==在读取位置f_pos为0时才更新psinfo内容==。
该inode对应的i_zone[0]依然存在。也就是说，只是从inode映射中取消映射该inode，但是实际上硬盘上的数据还在。</li>
</ol>


  </div>

  <footer class="post-footer">
    
<nav class="paginav">
  <a class="prev" href="https://chance7bin.github.io/posts/basic/asm/%E7%AC%AC7%E7%AB%A0-%E6%9B%B4%E7%81%B5%E6%B4%BB%E7%9A%84%E5%AE%9A%E4%BD%8D%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E7%9A%84%E6%96%B9%E6%B3%95/">
    <span class="title">« 上一页</span>
    <br>
    <span>第7章 更灵活的定位内存地址的方法</span>
  </a>
  <a class="next" href="https://chance7bin.github.io/posts/basic/asm/%E7%AC%AC8%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98/">
    <span class="title">下一页 »</span>
    <br>
    <span>第8章 数据处理的两个基本问题</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://chance7bin.github.io/">Binb&#39;s Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
