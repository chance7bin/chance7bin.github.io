<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>实验5 基于内核栈切换的进程切换 | Binb&#39;s Blog</title>
<meta name="keywords" content="操作系统, 实验">
<meta name="description" content="1.实验目的 深入理解进程和进程切换的概念； 综合应用进程、CPU 管理、PCB、LDT、内核栈、内核态等知识解决实际问题； 开始建立系统认识。 2.">
<meta name="author" content="chance7bin">
<link rel="canonical" href="https://chance7bin.github.io/posts/basic/os-lab/%E5%AE%9E%E9%AA%8C5-%E5%9F%BA%E4%BA%8E%E5%86%85%E6%A0%B8%E6%A0%88%E5%88%87%E6%8D%A2%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.be81eec981a615a87a88f121642d7eebde74d033438693944db2fd6b827284ff.css" integrity="" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.acb54fd32bbc1982428b8850317e45d076b95012730a5936667e6bc21777692a.js" integrity=""
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://chance7bin.github.io/img/%E7%BE%8E%E9%98%9F.jpg">
<link rel="icon" type="image/png" sizes="16x16" href="https://chance7bin.github.io/img/%E7%BE%8E%E9%98%9F.jpg">
<link rel="icon" type="image/png" sizes="32x32" href="https://chance7bin.github.io/img/%E7%BE%8E%E9%98%9F.jpg">
<link rel="apple-touch-icon" href="https://chance7bin.github.io/img/%E7%BE%8E%E9%98%9F.jpg">
<link rel="mask-icon" href="https://chance7bin.github.io/img/%E7%BE%8E%E9%98%9F.jpg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="实验5 基于内核栈切换的进程切换" />
<meta property="og:description" content="1.实验目的 深入理解进程和进程切换的概念； 综合应用进程、CPU 管理、PCB、LDT、内核栈、内核态等知识解决实际问题； 开始建立系统认识。 2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://chance7bin.github.io/posts/basic/os-lab/%E5%AE%9E%E9%AA%8C5-%E5%9F%BA%E4%BA%8E%E5%86%85%E6%A0%B8%E6%A0%88%E5%88%87%E6%8D%A2%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-20T00:00:00+00:00" />
<meta property="article:modified_time" content="2022-05-20T00:00:00+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="实验5 基于内核栈切换的进程切换"/>
<meta name="twitter:description" content="1.实验目的 深入理解进程和进程切换的概念； 综合应用进程、CPU 管理、PCB、LDT、内核栈、内核态等知识解决实际问题； 开始建立系统认识。 2."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "📚 文章",
      "item": "https://chance7bin.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "📕 计算机基础",
      "item": "https://chance7bin.github.io/posts/basic/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "hit-oslab",
      "item": "https://chance7bin.github.io/posts/basic/os-lab/"
    }, 
    {
      "@type": "ListItem",
      "position":  4 ,
      "name": "实验5 基于内核栈切换的进程切换",
      "item": "https://chance7bin.github.io/posts/basic/os-lab/%E5%AE%9E%E9%AA%8C5-%E5%9F%BA%E4%BA%8E%E5%86%85%E6%A0%B8%E6%A0%88%E5%88%87%E6%8D%A2%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "实验5 基于内核栈切换的进程切换",
  "name": "实验5 基于内核栈切换的进程切换",
  "description": "1.实验目的 深入理解进程和进程切换的概念； 综合应用进程、CPU 管理、PCB、LDT、内核栈、内核态等知识解决实际问题； 开始建立系统认识。 2.",
  "keywords": [
    "操作系统", "实验"
  ],
  "articleBody": "1.实验目的 深入理解进程和进程切换的概念； 综合应用进程、CPU 管理、PCB、LDT、内核栈、内核态等知识解决实际问题； 开始建立系统认识。 2.实验内容 现在的 Linux 0.11 采用 TSS（后面会有详细论述）和一条指令就能完成任务切换，虽然简单，但这指令的执行时间却很长，在实现任务切换时大概需要 200 多个时钟周期。\n而通过堆栈实现任务切换可能要更快，而且采用堆栈的切换还可以使用指令流水的并行优化技术，同时又使得 CPU 的设计变得简单。所以无论是 Linux 还是 Windows，进程/线程的切换都没有使用 Intel 提供的这种 TSS 切换手段，而都是通过堆栈实现的。\n本次实践项目就是将 Linux 0.11 中采用的 TSS 切换部分去掉，取而代之的是基于堆栈的切换程序。具体的说，就是将 Linux 0.11 中的 switch_to 实现去掉，写成一段基于堆栈切换的代码。\n本次实验包括如下内容：\n编写汇编程序 switch_to： 完成主体框架； 在主体框架下依次完成 PCB 切换、内核栈切换、LDT 切换等； 修改 fork()，由于是基于内核栈的切换，所以进程需要创建出能完成内核栈切换的样子。 修改 PCB，即 task_struct 结构，增加相应的内容域，同时处理由于修改了 task_struct 所造成的影响。 用修改后的 Linux 0.11 仍然可以启动、可以正常使用。 （选做）分析实验 3 的日志体会修改前后系统运行的差别。 3.实验报告 回答下面三个题：\n问题 1 针对下面的代码片段：\n1 2 3 movl tss,%ecx addl $4096,%ebx movl %ebx,ESP0(%ecx) 回答问题：\n（1）为什么要加 4096； （2）为什么没有设置 tss 中的 ss0。 问题 2 针对代码片段：\n1 2 3 4 *(--krnstack) = ebp; *(--krnstack) = ecx; *(--krnstack) = ebx; *(--krnstack) = 0; 回答问题：\n（1）子进程第一次执行时，eax=？为什么要等于这个数？哪里的工作让 eax 等于这样一个数？ （2）这段代码中的 ebx 和 ecx 来自哪里，是什么含义，为什么要通过这些代码将其写到子进程的内核栈中？ （3）这段代码中的 ebp 来自哪里，是什么含义，为什么要做这样的设置？可以不设置吗？为什么？ 问题 3 为什么要在切换完 LDT 之后要重新设置 fs=0x17？而且为什么重设操作要出现在切换完 LDT 之后，出现在 LDT 之前又会怎么样？\n4.实验提示 本次实验将 Linux 0.11 中采用的 TSS 切换部分去掉，取而代之的是基于堆栈的切换程序。具体的说，就是将 Linux 0.11 中的 switch_to （在 kernal/system_call.s 中）实现去掉，写成一段基于堆栈切换的代码。\n4.1 TSS 切换 在现在的 Linux 0.11 中，真正完成进程切换是依靠任务状态段（Task State Segment，简称 TSS）的切换来完成的。\n具体的说，在设计“Intel 架构”（即 x86 系统结构）时，每个任务（进程或线程）都对应一个独立的 TSS，TSS 就是内存中的一个结构体，里面包含了几乎所有的 CPU 寄存器的映像。有一个任务寄存器（Task Register，简称 TR）指向当前进程对应的 TSS 结构体，所谓的 TSS 切换就将 CPU 中几乎所有的寄存器都复制到 TR 指向的那个 TSS 结构体中保存起来，同时找到一个目标 TSS，即要切换到的下一个进程对应的 TSS，将其中存放的寄存器映像“扣在” CPU 上，就完成了执行现场的切换，如下图所示。\n图 1 基于 TSS 的进程切换\nIntel 架构不仅提供了 TSS 来实现任务切换，而且只要一条指令就能完成这样的切换，即图中的 ljmp 指令。\n具体的工作过程是：\n（1）首先用 TR 中存取的段选择符在 GDT 表中找到当前 TSS 的内存位置，由于 TSS 是一个段，所以需要用段表中的一个描述符来表示这个段，和在系统启动时论述的内核代码段是一样的，那个段用 GDT 中的某个表项来描述，还记得是哪项吗？是 8 对应的第 1 项。此处的 TSS 也是用 GDT 中的某个表项描述，而 TR 寄存器是用来表示这个段用 GDT 表中的哪一项来描述，所以 TR 和 CS、DS 等寄存器的功能是完全类似的。 （2）找到了当前的 TSS 段（就是一段内存区域）以后，将 CPU 中的寄存器映像存放到这段内存区域中，即拍了一个快照。 （3）存放了当前进程的执行现场以后，接下来要找到目标进程的现场，并将其扣在 CPU 上，找目标 TSS 段的方法也是一样的，因为找段都要从一个描述符表中找，描述 TSS 的描述符放在 GDT 表中，所以找目标 TSS 段也要靠 GDT 表，当然只要给出目标 TSS 段对应的描述符在 GDT 表中存放的位置——段选择子就可以了，仔细想想系统启动时那条著名的 jmpi 0, 8 指令，这个段选择子就放在 ljmp 的参数中，实际上就 jmpi 0, 8 中的 8。 （4）一旦将目标 TSS 中的全部寄存器映像扣在 CPU 上，就相当于切换到了目标进程的执行现场了，因为那里有目标进程停下时的 CS:EIP，所以此时就开始从目标进程停下时的那个 CS:EIP 处开始执行，现在目标进程就变成了当前进程，所以 TR 需要修改为目标 TSS 段在 GDT 表中的段描述符所在的位置，因为 TR 总是指向当前 TSS 段的段描述符所在的位置。 上面给出的这些工作都是一句长跳转指令 ljmp 段选择子:段内偏移，在段选择子指向的段描述符是 TSS 段时 CPU 解释执行的结果，所以基于 TSS 进行进程/线程切换的 switch_to 实际上就是一句 ljmp 指令：\n1 2 3 4 5 6 7 8 9 10 11 #define switch_to(n) { struct{long a,b;} tmp; __asm__( \"movw %%dx,%1\" \"ljmp %0\" ::\"m\"(*\u0026tmp.a), \"m\"(*\u0026tmp.b), \"d\"(TSS(n) ) } #define FIRST_TSS_ENTRY 4 #define TSS(n) (((unsigned long) n) \u003c\u003c 4) + (FIRST_TSS_ENTRY \u003c\u003c 3)) GDT 表的结构如下图所示，所以第一个 TSS 表项，即 0 号进程的 TSS 表项在第 4 个位置上，4«3，即 4 * 8，相当于 TSS 在 GDT 表中开始的位置，TSS（n）找到的是进程 n 的 TSS 位置，所以还要再加上 n«4，即 n * 16，因为每个进程对应有 1 个 TSS 和 1 个 LDT，每个描述符的长度都是 8 个字节，所以是乘以 16，其中 LDT 的作用就是上面论述的那个映射表，关于这个表的详细论述要等到内存管理一章。TSS(n) = n * 16 + 4 * 8，得到就是进程 n（切换到的目标进程）的 TSS 选择子，将这个值放到 dx 寄存器中，并且又放置到结构体 tmp 中 32 位长整数 b 的前 16 位，现在 64 位 tmp 中的内容是前 32 位为空，这个 32 位数字是段内偏移，就是 jmpi 0, 8 中的 0；接下来的 16 位是 n * 16 + 4 * 8，这个数字是段选择子，就是 jmpi 0, 8 中的 8，再接下来的 16 位也为空。所以 swith_to 的核心实际上就是 ljmp 空, n*16+4*8，现在和前面给出的基于 TSS 的进程切换联系在一起了。\n图 2 GDT 表中的内容\n4.2 本次实验的内容 虽然用一条指令就能完成任务切换，但这指令的执行时间却很长，这条 ljmp 指令在实现任务切换时大概需要 200 多个时钟周期。而通过堆栈实现任务切换可能要更快，而且采用堆栈的切换还可以使用指令流水的并行优化技术，同时又使得 CPU 的设计变得简单。所以无论是 Linux 还是 Windows，进程/线程的切换都没有使用 Intel 提供的这种 TSS 切换手段，而都是通过堆栈实现的。\n本次实践项目就是将 Linux 0.11 中采用的 TSS 切换部分去掉，取而代之的是基于堆栈的切换程序。具体的说，就是将 Linux 0.11 中的 switch_to 实现去掉，写成一段基于堆栈切换的代码。\n在现在的 Linux 0.11 中，真正完成进程切换是依靠任务状态段（Task State Segment，简称 TSS）的切换来完成的。具体的说，在设计“Intel 架构”（即 x86 系统结构）时，每个任务（进程或线程）都对应一个独立的 TSS，TSS 就是内存中的一个结构体，里面包含了几乎所有的 CPU 寄存器的映像。有一个任务寄存器（Task Register，简称 TR）指向当前进程对应的 TSS 结构体，所谓的 TSS 切换就将 CPU 中几乎所有的寄存器都复制到 TR 指向的那个 TSS 结构体中保存起来，同时找到一个目标 TSS，即要切换到的下一个进程对应的 TSS，将其中存放的寄存器映像“扣在”CPU 上，就完成了执行现场的切换。\n要实现基于内核栈的任务切换，主要完成如下三件工作：\n（1）重写 switch_to； （2）将重写的 switch_to 和 schedule() 函数接在一起； （3）修改现在的 fork()。 4.3 schedule 与 switch_to 目前 Linux 0.11 中工作的 schedule() 函数是首先找到下一个进程的数组位置 next，而这个 next 就是 GDT 中的 n，所以这个 next 是用来找到切换后目标 TSS 段的段描述符的，一旦获得了这个 next 值，直接调用上面剖析的那个宏展开 switch_to(next);就能完成如图 TSS 切换所示的切换了。\n现在，我们不用 TSS 进行切换，而是采用切换内核栈的方式来完成进程切换，所以在新的 switch_to 中将用到当前进程的 PCB、目标进程的 PCB、当前进程的内核栈、目标进程的内核栈等信息。由于 Linux 0.11 进程的内核栈和该进程的 PCB 在同一页内存上（一块 4KB 大小的内存），其中 PCB 位于这页内存的低地址，栈位于这页内存的高地址；另外，由于当前进程的 PCB 是用一个全局变量 current 指向的，所以只要告诉新 switch_to()函数一个指向目标进程 PCB 的指针就可以了。同时还要将 next 也传递进去，虽然 TSS(next)不再需要了，但是 LDT(next)仍然是需要的，也就是说，现在每个进程不用有自己的 TSS 了，因为已经不采用 TSS 进程切换了，但是每个进程需要有自己的 LDT，地址分离地址还是必须要有的，而进程切换必然要涉及到 LDT 的切换。\n综上所述，需要将目前的 schedule() 函数（在 kernal/sched.c 中）做稍许修改，即将下面的代码：\n1 2 3 4 5 6 if ((*p)-\u003estate == TASK_RUNNING \u0026\u0026 (*p)-\u003ecounter \u003e c) c = (*p)-\u003ecounter, next = i; //...... switch_to(next); 修改为：\n1 2 3 4 5 6 if ((*p)-\u003estate == TASK_RUNNING \u0026\u0026 (*p)-\u003ecounter \u003e c) c = (*p)-\u003ecounter, next = i, pnext = *p; //....... switch_to(pnext, LDT(next)); 4.4 实现 switch_to 实现 switch_to 是本次实践项目中最重要的一部分。\n由于要对内核栈进行精细的操作，所以需要用汇编代码来完成函数 switch_to 的编写。\n这个函数依次主要完成如下功能：由于是 C 语言调用汇编，所以需要首先在汇编中处理栈帧，即处理 ebp 寄存器；接下来要取出表示下一个进程 PCB 的参数，并和 current 做一个比较，如果等于 current，则什么也不用做；如果不等于 current，就开始进程切换，依次完成 PCB 的切换、TSS 中的内核栈指针的重写、内核栈的切换、LDT 的切换以及 PC 指针（即 CS:EIP）的切换。\nEBP 和 ESP 详解\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 switch_to: pushl %ebp movl %esp,%ebp pushl %ecx pushl %ebx pushl %eax movl 8(%ebp),%ebx cmpl %ebx,current je 1f ! 切换PCB ! ... ! TSS中的内核栈指针的重写 ! ... ! 切换内核栈 ! ... ! 切换LDT ! ... movl $0x17,%ecx mov %cx,%fs ! 和后面的 clts 配合来处理协处理器，由于和主题关系不大，此处不做论述 cmpl %eax,last_task_used_math jne 1f clts 1: popl %eax popl %ebx popl %ecx popl %ebp ret 虽然看起来完成了挺多的切换，但实际上每个部分都只有很简单的几条指令。完成 PCB 的切换可以采用下面两条指令，其中 ebx 是从参数中取出来的下一个进程的 PCB 指针，\n1 2 movl %ebx,%eax xchgl %eax,current 经过这两条指令以后，eax 指向现在的当前进程，ebx 指向下一个进程，全局变量 current 也指向下一个进程。\nTSS 中的内核栈指针的重写可以用下面三条指令完成，其中宏 ESP0 = 4，struct tss_struct *tss = \u0026(init_task.task.tss); 也是定义了一个全局变量，和 current 类似，用来指向那一段 0 号进程的 TSS 内存。\n前面已经详细论述过，在中断的时候，要找到内核栈位置，并将用户态下的 SS:ESP，CS:EIP 以及 EFLAGS 这五个寄存器压到内核栈中，这是沟通用户栈（用户态）和内核栈（内核态）的关键桥梁，而找到内核栈位置就依靠 TR 指向的当前 TSS。\n现在虽然不使用 TSS 进行任务切换了，但是 Intel 的这态中断处理机制还要保持，所以仍然需要有一个当前 TSS，这个 TSS 就是我们定义的那个全局变量 tss，即 0 号进程的 tss，所有进程都共用这个 tss，任务切换时不再发生变化。\n1 2 3 movl tss,%ecx addl $4096,%ebx movl %ebx,ESP0(%ecx) 定义 ESP0 = 4 是因为 TSS 中内核栈指针 esp0 就放在偏移为 4 的地方，看一看 tss 的结构体定义就明白了。\n完成内核栈的切换也非常简单，和我们前面给出的论述完全一致，将寄存器 esp（内核栈使用到当前情况时的栈顶位置）的值保存到当前 PCB 中，再从下一个 PCB 中的对应位置上取出保存的内核栈栈顶放入 esp 寄存器，这样处理完以后，再使用内核栈时使用的就是下一个进程的内核栈了。\n由于现在的 Linux 0.11 的 PCB 定义中没有保存内核栈指针这个域（kernelstack），所以需要加上，而宏 KERNEL_STACK 就是你加的那个位置，当然将 kernelstack 域加在 task_struct 中的哪个位置都可以，但是在某些汇编文件中（主要是在 kernal/system_call.s 中）有些关于操作这个结构一些汇编硬编码，所以一旦增加了 kernelstack，这些硬编码需要跟着修改，由于第一个位置，即 long state 出现的汇编硬编码很多，所以 kernelstack 千万不要放置在 task_struct 中的第一个位置，当放在其他位置时，修改 kernal/system_call.s 中的那些硬编码就可以了。\n1 2 3 4 5 KERNEL_STACK = 12 movl %esp,KERNEL_STACK(%eax) ! 再取一下 ebx，因为前面修改过 ebx 的值 movl 8(%ebp),%ebx movl KERNEL_STACK(%ebx),%esp task_struct 的定义：\n1 2 3 4 5 6 7 // 在 include/linux/sched.h 中 struct task_struct { long state; long counter; long priority; long kernelstack; //...... 由于这里将 PCB 结构体的定义改变了，所以在产生 0 号进程的 PCB 初始化时也要跟着一起变化，需要将原来的 #define INIT_TASK { 0,15,15, 0,{{},},0,... 修改为 #define INIT_TASK { 0,15,15,PAGE_SIZE+(long)\u0026init_task, 0,{{},},0,...，即在 PCB 的第四项中增加关于内核栈栈指针的初始化。\n再下一个切换就是 LDT 的切换了，指令 movl 12(%ebp),%ecx 负责取出对应 LDT(next)的那个参数，指令 lldt %cx 负责修改 LDTR 寄存器，一旦完成了修改，下一个进程在执行用户态程序时使用的映射表就是自己的 LDT 表了，地址空间实现了分离。\n最后一个切换是关于 PC 的切换，和前面论述的一致，依靠的就是 switch_to 的最后一句指令 ret，虽然简单，但背后发生的事却很多：schedule() 函数的最后调用了这个 switch_to 函数，所以这句指令 ret 就返回到下一个进程（目标进程）的 schedule() 函数的末尾，遇到的是}，继续 ret 回到调用的 schedule() 地方，是在中断处理中调用的，所以回到了中断处理中，就到了中断返回的地址，再调用 iret 就到了目标进程的用户态程序去执行，和书中论述的内核态线程切换的五段论是完全一致的。\n这里还有一个地方需要格外注意，那就是 switch_to 代码中在切换完 LDT 后的两句，即：\n1 2 3 ! 切换 LDT 之后 movl $0x17,%ecx mov %cx,%fs 这两句代码的含义是重新取一下段寄存器 fs 的值，这两句话必须要加、也必须要出现在切换完 LDT 之后，这是因为在实践项目 2 中曾经看到过 fs 的作用——通过 fs 访问进程的用户态内存，LDT 切换完成就意味着切换了分配给进程的用户态内存地址空间，所以前一个 fs 指向的是上一个进程的用户态内存，而现在需要执行下一个进程的用户态内存，所以就需要用这两条指令来重取 fs。\n不过，细心的读者可能会发现：fs 是一个选择子，即 fs 是一个指向描述符表项的指针，这个描述符才是指向实际的用户态内存的指针，所以上一个进程和下一个进程的 fs 实际上都是 0x17，真正找到不同的用户态内存是因为两个进程查的 LDT 表不一样，所以这样重置一下 fs=0x17 有用吗，有什么用？要回答这个问题就需要对段寄存器有更深刻的认识，实际上段寄存器包含两个部分：显式部分和隐式部分，如下图给出实例所示，就是那个著名的 jmpi 0, 8，虽然我们的指令是让 cs=8，但在执行这条指令时，会在段表（GDT）中找到 8 对应的那个描述符表项，取出基地址和段限长，除了完成和 eip 的累加算出 PC 以外，还会将取出的基地址和段限长放在 cs 的隐藏部分，即图中的基地址 0 和段限长 7FF。为什么要这样做？下次执行 jmp 100 时，由于 cs 没有改过，仍然是 8，所以可以不再去查 GDT 表，而是直接用其隐藏部分中的基地址 0 和 100 累加直接得到 PC，增加了执行指令的效率。现在想必明白了为什么重新设置 fs=0x17 了吧？而且为什么要出现在切换完 LDT 之后？\n图 3 段寄存器中的两个部分\n4.5 修改 fork 开始修改 fork() 了，和书中论述的原理一致，就是要把进程的用户栈、用户程序和其内核栈通过压在内核栈中的 SS:ESP，CS:IP 关联在一起。\n另外，由于 fork() 这个叉子的含义就是要让父子进程共用同一个代码、数据和堆栈，现在虽然是使用内核栈完成任务切换，但 fork() 的基本含义不会发生变化。\n将上面两段描述联立在一起，修改 fork() 的核心工作就是要形成如下图所示的子进程内核栈结构。\n图 4 fork 进程的父子进程结构\n不难想象，对 fork() 的修改就是对子进程的内核栈的初始化，在 fork() 的核心实现 copy_process 中，p = (struct task_struct *) get_free_page();用来完成申请一页内存作为子进程的 PCB，而 p 指针加上页面大小就是子进程的内核栈位置，所以语句 krnstack = (long *) (PAGE_SIZE + (long) p); 就可以找到子进程的内核栈位置，接下来就是初始化 krnstack 中的内容了。\n1 2 3 4 5 *(--krnstack) = ss \u0026 0xffff; *(--krnstack) = esp; *(--krnstack) = eflags; *(--krnstack) = cs \u0026 0xffff; *(--krnstack) = eip; 这五条语句就完成了上图所示的那个重要的关联，因为其中 ss,esp 等内容都是 copy_proces() 函数的参数，这些参数来自调用 copy_proces() 的进程的内核栈中，就是父进程的内核栈中，所以上面给出的指令不就是将父进程内核栈中的前五个内容拷贝到子进程的内核栈中，图中所示的关联不也就是一个拷贝吗？\n接下来的工作就需要和 switch_to 接在一起考虑了，故事从哪里开始呢？回顾一下前面给出来的 switch_to，应该从 “切换内核栈” 完事的那个地方开始，现在到子进程的内核栈开始工作了，接下来做的四次弹栈以及 ret 处理使用的都是子进程内核栈中的东西，\n1 2 3 4 5 1: popl %eax popl %ebx popl %ecx popl %ebp ret 为了能够顺利完成这些弹栈工作，子进程的内核栈中应该有这些内容，所以需要对 krnstack 进行初始化：\n1 2 3 4 5 *(--krnstack) = ebp; *(--krnstack) = ecx; *(--krnstack) = ebx; // 这里的 0 最有意思。 *(--krnstack) = 0; 现在到了 ret 指令了，这条指令要从内核栈中弹出一个 32 位数作为 EIP 跳去执行，所以需要弄一个函数地址（仍然是一段汇编程序，所以这个地址是这段汇编程序开始处的标号）并将其初始化到栈中。我们弄的一个名为 first_return_from_kernel 的汇编标号，然后可以用语句 *(--krnstack) = (long) first_return_from_kernel; 将这个地址初始化到子进程的内核栈中，现在执行 ret 以后就会跳转到 first_return_from_kernel 去执行了。\n想一想 first_return_from_kernel 要完成什么工作？PCB 切换完成、内核栈切换完成、LDT 切换完成，接下来应该那个“内核级线程切换五段论”中的最后一段切换了，即完成用户栈和用户代码的切换，依靠的核心指令就是 iret，当然在切换之前应该回复一下执行现场，主要就是 eax,ebx,ecx,edx,esi,edi,gs,fs,es,ds 等寄存器的恢复.\n下面给出了 first_return_from_kernel 的核心代码，当然 edx 等寄存器的值也应该先初始化到子进程内核栈，即 krnstack 中。\n1 2 3 4 5 6 7 8 popl %edx popl %edi popl %esi pop %gs pop %fs pop %es pop %ds iret 最后别忘了将存放在 PCB 中的内核栈指针修改到初始化完成时内核栈的栈顶，即：\n1 p-\u003ekernelstack = stack; 实验步骤 1.修改/kernel/system_call.s文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 .globl system_call,sys_fork,timer_interrupt,sys_execve .globl hd_interrupt,floppy_interrupt,parallel_interrupt .globl device_not_available, coprocessor_error # 以上是原代码部分，以下是需要新建的代码 # system_call.s # 汇编语言中定义的方法可以被其他调用需要 .globl switch_to .globl first_return_from_kernel # 硬编码改变 these are offsets into the task-struct ESP0 = 4 KERNEL_STACK = 12 state\t= 0\t# these are offsets into the task-struct. counter\t= 4 priority = 8 kernelstack = 12 signal\t= 16 sigaction = 20\t# MUST be 16 (=len of sigaction) blocked = (37*16) switch_to: pushl %ebp movl %esp,%ebp pushl %ecx pushl %ebx pushl %eax movl 8(%ebp),%ebx cmpl %ebx,current je 1f # switch_to PCB movl %ebx,%eax xchgl %eax,current # rewrite TSS pointer movl tss,%ecx addl $4096,%ebx movl %ebx,ESP0(%ecx) # switch_to system core stack movl %esp,KERNEL_STACK(%eax) movl 8(%ebp),%ebx movl KERNEL_STACK(%ebx),%esp # switch_to LDT movl 12(%ebp), %ecx lldt %cx movl $0x17,%ecx mov %cx,%fs # nonsense cmpl %eax,last_task_used_math jne 1f clts 1: popl %eax popl %ebx popl %ecx popl %ebp ret .align 2 first_return_from_kernel: popl %edx popl %edi popl %esi pop %gs pop %fs pop %es pop %ds iret 该段代码完成的工作如下： 1.pushl %ebp 首先在汇编中处理栈帧，即处理 ebp 寄存器 2.cmpl %ebx,current 接下来要取出表示下一个进程 PCB 的参数，并和 current 做一个比较，如果等于 current，则什么也不用做。不等于 current，就开始进程切换。 3.switch_to PCB 完成 PCB 的切换 ebx是从参数中取出来的下一个进程的 PCB 指针，经过两条指令以后，eax 指向现在的当前进程，ebx指向下一个进程，全局变量 current 也指向下一个进程。 4.rewrite TSS pointer TSS 中的内核栈指针的重写 中断处理时需要寻找当前进程的内核栈，否则就不能从用户栈切到内核栈(中断处理没法完成)，内核栈的寻找是借助当前进程TSS中存放的信息来完成的。 5.switch_to system core stack内核栈的切换 将寄存器 esp（内核栈使用到当前情况时的栈顶位置）的值保存到当前 PCB 中，再从下一个 PCB 中的对应位置上取出保存的内核栈栈顶放入 esp寄存器，这样处理完以后，再使用内核栈时使用的就是下一个进程的内核栈了。 6.switch_to LDT LDT的切换 指令 movl 12(%ebp),%ecx 负责取出对应 LDT(next)的那个参数，指令 lldt %cx 负责修改 LDTR 寄存器，一旦完成了修改，下一个进程在执行用户态程序时使用的映射表就是自己的 LDT 表了，地址空间实现了分离。 最后，通过FS操作系统才能访问进程的用户态内存。这里LDT切换完成意味着切换到了新的用户态地址空间，所以需要重置FS。 代码截图如下（部分）: 2.修改/include/linux/sched.h文件 注释掉原来switch_to宏函数，截图如下： 基于堆栈的切换程序要做到承上启下：\n承上：基于堆栈的切换，要用到当前进程(current指向)与目标进程的PCB，当前进程与目标进程的内核栈等 Linux 0.11 进程的内核栈和该进程的 PCB 在同一页内存上（一块 4KB 大小的内存），其中 PCB 位于这页内存的低地址，栈位于这页内存的高地址 启下：要将next传递下去，虽然 TSS(next)不再需要了，但是 LDT(next)仍然是需要的。 之前的进程控制块(pcb)中是没有保存内核栈信息的寄存器的，所以需要在sched.h中的task_struct(也就是pcb)中添加kernelstack。 1 2 3 4 5 6 7 8 9 10 struct task_struct { /* these are hardcoded - don't touch */ long state;\t/* -1 unrunnable, 0 runnable, \u003e0 stopped */ long counter; long priority; //新增kernelstack long kernelstack; long signal; struct sigaction sigaction[32]; //...... 代码截图如下： 由于这里将 PCB 结构体的定义改变了，所以在产生 0 号进程的 PCB 初始化时也要跟着一起变化，需要修改 #define INIT_TASK，即在 PCB 的第四项中增加关于内核栈栈指针的初始化。\n1 2 3 #define INIT_TASK \\ /* state etc */\t{ 0,15,15,PAGE_SIZE+(long)\u0026init_task, \\ //...... 代码截图如下: 3.修改/kernel/sched.c文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 // 添加的代码,定义tss struct task_struct *tss= \u0026(init_task.task.tss); void schedule(void) { int i,next,c; struct task_struct ** p; struct task_struct *pnext = NULL; // 添加的代码,赋值初始化任务的指针 /* check alarm, wake up any interruptible tasks that have got a signal */ for(p = \u0026LAST_TASK ; p \u003e \u0026FIRST_TASK ; --p) if (*p) { if ((*p)-\u003ealarm \u0026\u0026 (*p)-\u003ealarm \u003c jiffies) { (*p)-\u003esignal |= (1\u003c\u003c(SIGALRM-1)); (*p)-\u003ealarm = 0; } if (((*p)-\u003esignal \u0026 ~(_BLOCKABLE \u0026 (*p)-\u003eblocked)) \u0026\u0026 (*p)-\u003estate==TASK_INTERRUPTIBLE) (*p)-\u003estate=TASK_RUNNING;\t} /* this is the scheduler proper: */ while (1) { c = -1; next = 0; // 添加的代码. 如果系统没有进程可以调度时传递进去的是一个空值，系统宕机， // 所以加上这句，这样就可以在next=0时不会有空指针传递 pnext = task[next]; i = NR_TASKS; p = \u0026task[NR_TASKS]; while (--i) { if (!*--p) continue; if ((*p)-\u003estate == TASK_RUNNING \u0026\u0026 (*p)-\u003ecounter\u003e c) c = (*p)-\u003ecounter, next = i, pnext=*p;// 修改添加的代码 } if (c) break; for(p = \u0026LAST_TASK ; p \u003e \u0026FIRST_TASK ; --p) if (*p) (*p)-\u003ecounter = ((*p)-\u003ecounter \u003e\u003e 1) + (*p)-\u003epriority; } //switch_to(next); switch_to(pnext, _LDT(next)); // 修改添加的代码 } 更改截图如下： 4.修改fork.c文件 对fork()的修改就是对子进程的内核栈的初始化，在fork()的核心实现copy_process中，p = (struct task_struct) get_free_page();用来完成申请一页内存作为子进程的PCB，而p指针加上页面大小就是子进程的内核栈位置. 所以需要再定义一个指针变量krnstack, 并将其初始化为内核栈顶指针, 然后再根据传递进来的参数把前一个进程的PCB中各种信息都保存到当前栈中。 可以将原代码copy_process函数注释，替换为以下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 //fork.c //6th extern void first_return_from_kernel(void); //fork.c copy_process() int copy_process(int nr,long ebp,long edi,long esi,long gs,long none, long ebx,long ecx,long edx, long fs,long es,long ds, long eip,long cs,long eflags,long esp,long ss) { struct task_struct *p; int i; struct file *f; long * krnstack; //1st p = (struct task_struct *) get_free_page(); if (!p) return -EAGAIN; task[nr] = p; *p = *current; /* NOTE! this doesn't copy the supervisor stack */ p-\u003estate = TASK_UNINTERRUPTIBLE; p-\u003epid = last_pid; p-\u003efather = current-\u003epid; p-\u003ecounter = p-\u003epriority; p-\u003esignal = 0; p-\u003ealarm = 0; p-\u003eleader = 0; /* process leadership doesn't inherit */ p-\u003eutime = p-\u003estime = 0; p-\u003ecutime = p-\u003ecstime = 0; p-\u003estart_time = jiffies; if (last_task_used_math == current) __asm__(\"clts ; fnsave %0\"::\"m\" (p-\u003etss.i387)); if (copy_mem(nr,p)) { task[nr] = NULL; free_page((long) p); return -EAGAIN; } //2nd krnstack = (long *) (PAGE_SIZE + (long) p); *(--krnstack) = ss \u0026 0xffff; *(--krnstack) = esp; *(--krnstack) = eflags; *(--krnstack) = cs \u0026 0xffff; *(--krnstack) = eip; *(--krnstack) = ds \u0026 0xffff; *(--krnstack) = es \u0026 0xffff; *(--krnstack) = fs \u0026 0xffff; *(--krnstack) = gs \u0026 0xffff; *(--krnstack) = esi; *(--krnstack) = edi; *(--krnstack) = edx; //3rd *(--krnstack) = first_return_from_kernel; //4th *(--krnstack) = ebp; *(--krnstack) = ecx; *(--krnstack) = ebx; *(--krnstack) = 0; //5th p-\u003ekernelstack = krnstack; for (i=0; i\u003cNR_OPEN;i++) if ((f=p-\u003efilp[i])) f-\u003ef_count++; if (current-\u003epwd) current-\u003epwd-\u003ei_count++; if (current-\u003eroot) current-\u003eroot-\u003ei_count++; if (current-\u003eexecutable) current-\u003eexecutable-\u003ei_count++; set_tss_desc(gdt+(nr\u003c\u003c1)+FIRST_TSS_ENTRY,\u0026(p-\u003etss)); set_ldt_desc(gdt+(nr\u003c\u003c1)+FIRST_LDT_ENTRY,\u0026(p-\u003eldt)); p-\u003estate = TASK_RUNNING; /* do this last, just in case */ return last_pid; } 5.验证结果 经过验证，用修改后的 Linux 0.11 仍然可以启动、可以正常使用。\n",
  "wordCount" : "8959",
  "inLanguage": "zh",
  "datePublished": "2022-05-20T00:00:00Z",
  "dateModified": "2022-05-20T00:00:00Z",
  "author":[{
    "@type": "Person",
    "name": "chance7bin"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://chance7bin.github.io/posts/basic/os-lab/%E5%AE%9E%E9%AA%8C5-%E5%9F%BA%E4%BA%8E%E5%86%85%E6%A0%B8%E6%A0%88%E5%88%87%E6%8D%A2%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Binb's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://chance7bin.github.io/img/%E7%BE%8E%E9%98%9F.jpg"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://chance7bin.github.io/" accesskey="h" title="Binb&#39;s Blog (Alt + H)">
                <img src="https://chance7bin.github.io/img/%E7%BE%8E%E9%98%9F.jpg" alt="" aria-label="logo"
                    height="35">Binb&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://chance7bin.github.io/search" title="🔍搜索 (Alt &#43; /)" accesskey=/>
                    <span>🔍搜索</span>
                </a>
            </li>
            <li>
                <a href="https://chance7bin.github.io/" title="🏠 主页">
                    <span>🏠 主页</span>
                </a>
            </li>
            <li>
                <a href="https://chance7bin.github.io/archives/" title="⏱️ 时间轴">
                    <span>⏱️ 时间轴</span>
                </a>
            </li>
            <li>
                <a href="https://chance7bin.github.io/posts" title="📚 文章">
                    <span>📚 文章</span>
                </a>
            </li>
            <li>
                <a href="https://chance7bin.github.io/tags" title="🔖 标签">
                    <span>🔖 标签</span>
                </a>
            </li>
            <li>
                <a href="https://github.com/chance7bin" title="GitHub">
                    <span>GitHub</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://chance7bin.github.io/">🏠 主页</a>&nbsp;»&nbsp;<a href="https://chance7bin.github.io/posts/">📚 文章</a>&nbsp;»&nbsp;<a href="https://chance7bin.github.io/posts/basic/">📕 计算机基础</a>&nbsp;»&nbsp;<a href="https://chance7bin.github.io/posts/basic/os-lab/">hit-oslab</a></div>
    <h1 class="post-title">
      实验5 基于内核栈切换的进程切换
    </h1>
    <div class="post-meta">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css">


<style>
    i[id*="post_meta_style"] {
        display: flex;
        align-items: center;
        margin: 0 0 10px 0;
    }

    .parent-post-meta {
        display: flex;
        flex-wrap: wrap;
        opacity: 0.8;
    }
</style>

<span class="parent-post-meta">
    <span id="post_meta_style_1">
        <span class="fa fa-calendar-check-o"></span>
        <span>2022-05-20
            &nbsp;&nbsp;
        </span>
    </span>
    
    
    
    
    
    
    
    <span id="post_meta_style_3">
        <span class="fa fa-file-word-o"></span>
        <span>8959字
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_4">
        <span class="fa fa-clock-o"></span>
        <span>18分钟
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_5">
        <span class="fa fa-user-o"></span>
        <span>chance7bin
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_6">
        <span class="fa fa-tags" style="opacity: 0.8"></span>
        <span>
            <span class="post-tags-meta">
                <a href="https://chance7bin.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="color: var(--secondary)!important;">操作系统</a>
                &nbsp;<a href="https://chance7bin.github.io/tags/%E5%AE%9E%E9%AA%8C/" style="color: var(--secondary)!important;">实验</a>
            </span>
        </span>
    </span>

    
</span>


      
      
      
      
      
      
      
          
          
          
              
              
              
              
          
      
    </div>
  </header>
   <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">目录</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#1%e5%ae%9e%e9%aa%8c%e7%9b%ae%e7%9a%84" aria-label="1.实验目的">1.实验目的</a></li>
                    <li>
                        <a href="#2%e5%ae%9e%e9%aa%8c%e5%86%85%e5%ae%b9" aria-label="2.实验内容">2.实验内容</a></li>
                    <li>
                        <a href="#3%e5%ae%9e%e9%aa%8c%e6%8a%a5%e5%91%8a" aria-label="3.实验报告">3.实验报告</a><ul>
                            
                    <li>
                        <a href="#%e9%97%ae%e9%a2%98-1" aria-label="问题 1">问题 1</a></li>
                    <li>
                        <a href="#%e9%97%ae%e9%a2%98-2" aria-label="问题 2">问题 2</a></li>
                    <li>
                        <a href="#%e9%97%ae%e9%a2%98-3" aria-label="问题 3">问题 3</a></li></ul>
                    </li>
                    <li>
                        <a href="#4%e5%ae%9e%e9%aa%8c%e6%8f%90%e7%a4%ba" aria-label="4.实验提示">4.实验提示</a><ul>
                            
                    <li>
                        <a href="#41-tss-%e5%88%87%e6%8d%a2" aria-label="4.1 TSS 切换">4.1 TSS 切换</a></li>
                    <li>
                        <a href="#42-%e6%9c%ac%e6%ac%a1%e5%ae%9e%e9%aa%8c%e7%9a%84%e5%86%85%e5%ae%b9" aria-label="4.2 本次实验的内容">4.2 本次实验的内容</a></li>
                    <li>
                        <a href="#43-schedule-%e4%b8%8e-switch_to" aria-label="4.3 schedule 与 switch_to">4.3 schedule 与 switch_to</a></li>
                    <li>
                        <a href="#44-%e5%ae%9e%e7%8e%b0-switch_to" aria-label="4.4 实现 switch_to">4.4 实现 switch_to</a></li>
                    <li>
                        <a href="#45-%e4%bf%ae%e6%94%b9-fork" aria-label="4.5 修改 fork">4.5 修改 fork</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e5%ae%9e%e9%aa%8c%e6%ad%a5%e9%aa%a4" aria-label="实验步骤">实验步骤</a><ul>
                            
                    <li>
                        <a href="#1%e4%bf%ae%e6%94%b9kernelsystem_calls%e6%96%87%e4%bb%b6" aria-label="1.修改/kernel/system_call.s文件">1.修改/kernel/system_call.s文件</a></li>
                    <li>
                        <a href="#2%e4%bf%ae%e6%94%b9includelinuxschedh%e6%96%87%e4%bb%b6" aria-label="2.修改/include/linux/sched.h文件">2.修改/include/linux/sched.h文件</a></li>
                    <li>
                        <a href="#3%e4%bf%ae%e6%94%b9kernelschedc%e6%96%87%e4%bb%b6" aria-label="3.修改/kernel/sched.c文件">3.修改/kernel/sched.c文件</a></li>
                    <li>
                        <a href="#4%e4%bf%ae%e6%94%b9forkc%e6%96%87%e4%bb%b6" aria-label="4.修改fork.c文件">4.修改fork.c文件</a></li>
                    <li>
                        <a href="#5%e9%aa%8c%e8%af%81%e7%bb%93%e6%9e%9c" aria-label="5.验证结果">5.验证结果</a>
                    </li>
                </ul>
                </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>
  <div class="post-content"><h2 id="1实验目的">1.实验目的<a hidden class="anchor" aria-hidden="true" href="#1实验目的">#</a></h2>
<ul>
<li>深入理解进程和进程切换的概念；</li>
<li>综合应用进程、CPU 管理、PCB、LDT、内核栈、内核态等知识解决实际问题；</li>
<li>开始建立系统认识。</li>
</ul>
<h2 id="2实验内容">2.实验内容<a hidden class="anchor" aria-hidden="true" href="#2实验内容">#</a></h2>
<p>现在的 Linux 0.11 采用 TSS（后面会有详细论述）和一条指令就能完成任务切换，虽然简单，但这指令的执行时间却很长，在实现任务切换时大概需要 200 多个时钟周期。</p>
<p>而通过堆栈实现任务切换可能要更快，而且采用堆栈的切换还可以使用指令流水的并行优化技术，同时又使得 CPU 的设计变得简单。所以无论是 Linux 还是 Windows，进程/线程的切换都没有使用 Intel 提供的这种 TSS 切换手段，而都是通过堆栈实现的。</p>
<p>本次实践项目就是将 Linux 0.11 中采用的 TSS 切换部分去掉，取而代之的是基于堆栈的切换程序。具体的说，就是将 Linux 0.11 中的 <code>switch_to</code> 实现去掉，写成一段基于堆栈切换的代码。</p>
<p>本次实验包括如下内容：</p>
<ul>
<li>编写汇编程序 <code>switch_to</code>：</li>
<li>完成主体框架；</li>
<li>在主体框架下依次完成 PCB 切换、内核栈切换、LDT 切换等；</li>
<li>修改 <code>fork()</code>，由于是基于内核栈的切换，所以进程需要创建出能完成内核栈切换的样子。</li>
<li>修改 PCB，即 <code>task_struct</code> 结构，增加相应的内容域，同时处理由于修改了 task_struct 所造成的影响。</li>
<li>用修改后的 Linux 0.11 仍然可以启动、可以正常使用。</li>
<li>（选做）分析实验 3 的日志体会修改前后系统运行的差别。</li>
</ul>
<h2 id="3实验报告">3.实验报告<a hidden class="anchor" aria-hidden="true" href="#3实验报告">#</a></h2>
<p>回答下面三个题：</p>
<h3 id="问题-1">问题 1<a hidden class="anchor" aria-hidden="true" href="#问题-1">#</a></h3>
<p>针对下面的代码片段：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">movl tss,%ecx
</span></span><span class="line"><span class="cl">addl $4096,%ebx
</span></span><span class="line"><span class="cl">movl %ebx,ESP0(%ecx)
</span></span></code></pre></td></tr></table>
</div>
</div><p>回答问题：</p>
<ul>
<li>（1）为什么要加 4096；</li>
<li>（2）为什么没有设置 tss 中的 ss0。</li>
</ul>
<h3 id="问题-2">问题 2<a hidden class="anchor" aria-hidden="true" href="#问题-2">#</a></h3>
<p>针对代码片段：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="o">*</span><span class="p">(</span><span class="o">--</span><span class="n">krnstack</span><span class="p">)</span> <span class="o">=</span> <span class="n">ebp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="o">*</span><span class="p">(</span><span class="o">--</span><span class="n">krnstack</span><span class="p">)</span> <span class="o">=</span> <span class="n">ecx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="o">*</span><span class="p">(</span><span class="o">--</span><span class="n">krnstack</span><span class="p">)</span> <span class="o">=</span> <span class="n">ebx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="o">*</span><span class="p">(</span><span class="o">--</span><span class="n">krnstack</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>回答问题：</p>
<ul>
<li>（1）子进程第一次执行时，eax=？为什么要等于这个数？哪里的工作让 eax 等于这样一个数？</li>
<li>（2）这段代码中的 ebx 和 ecx 来自哪里，是什么含义，为什么要通过这些代码将其写到子进程的内核栈中？</li>
<li>（3）这段代码中的 ebp 来自哪里，是什么含义，为什么要做这样的设置？可以不设置吗？为什么？</li>
</ul>
<h3 id="问题-3">问题 3<a hidden class="anchor" aria-hidden="true" href="#问题-3">#</a></h3>
<p>为什么要在切换完 LDT 之后要重新设置 fs=0x17？而且为什么重设操作要出现在切换完 LDT 之后，出现在 LDT 之前又会怎么样？</p>
<h2 id="4实验提示">4.实验提示<a hidden class="anchor" aria-hidden="true" href="#4实验提示">#</a></h2>
<p>本次实验将 Linux 0.11 中采用的 TSS 切换部分去掉，取而代之的是基于堆栈的切换程序。具体的说，就是将 Linux 0.11 中的 <code>switch_to</code> （在 kernal/system_call.s 中）实现去掉，写成一段基于堆栈切换的代码。</p>
<h3 id="41-tss-切换">4.1 TSS 切换<a hidden class="anchor" aria-hidden="true" href="#41-tss-切换">#</a></h3>
<p>在现在的 Linux 0.11 中，真正完成进程切换是依靠任务状态段（Task State Segment，简称 TSS）的切换来完成的。</p>
<p>具体的说，在设计“Intel 架构”（即 x86 系统结构）时，每个任务（进程或线程）都对应一个独立的 TSS，TSS 就是内存中的一个结构体，里面包含了几乎所有的 CPU 寄存器的映像。有一个任务寄存器（Task Register，简称 TR）指向当前进程对应的 TSS 结构体，所谓的 TSS 切换就将 CPU 中几乎所有的寄存器都复制到 TR 指向的那个 TSS 结构体中保存起来，同时找到一个目标 TSS，即要切换到的下一个进程对应的 TSS，将其中存放的寄存器映像“扣在” CPU 上，就完成了执行现场的切换，如下图所示。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012340650.png" alt="图片描述信息"  />
</p>
<p>图 1 基于 TSS 的进程切换</p>
<p>Intel 架构不仅提供了 TSS 来实现任务切换，而且只要一条指令就能完成这样的切换，即图中的 ljmp 指令。</p>
<p>具体的工作过程是：</p>
<ul>
<li>（1）首先用 TR 中存取的段选择符在 GDT 表中找到当前 TSS 的内存位置，由于 TSS 是一个段，所以需要用段表中的一个描述符来表示这个段，和在系统启动时论述的内核代码段是一样的，那个段用 GDT 中的某个表项来描述，还记得是哪项吗？是 8 对应的第 1 项。此处的 TSS 也是用 GDT 中的某个表项描述，而 TR 寄存器是用来表示这个段用 GDT 表中的哪一项来描述，所以 TR 和 CS、DS 等寄存器的功能是完全类似的。</li>
<li>（2）找到了当前的 TSS 段（就是一段内存区域）以后，将 CPU 中的寄存器映像存放到这段内存区域中，即拍了一个快照。</li>
<li>（3）存放了当前进程的执行现场以后，接下来要找到目标进程的现场，并将其扣在 CPU 上，找目标 TSS 段的方法也是一样的，因为找段都要从一个描述符表中找，描述 TSS 的描述符放在 GDT 表中，所以找目标 TSS 段也要靠 GDT 表，当然只要给出目标 TSS 段对应的描述符在 GDT 表中存放的位置——段选择子就可以了，仔细想想系统启动时那条著名的 <code>jmpi 0, 8</code> 指令，这个段选择子就放在 ljmp 的参数中，实际上就 <code>jmpi 0, 8</code> 中的 8。</li>
<li>（4）一旦将目标 TSS 中的全部寄存器映像扣在 CPU 上，就相当于切换到了目标进程的执行现场了，因为那里有目标进程停下时的 <code>CS:EIP</code>，所以此时就开始从目标进程停下时的那个 <code>CS:EIP</code> 处开始执行，现在目标进程就变成了当前进程，所以 TR 需要修改为目标 TSS 段在 GDT 表中的段描述符所在的位置，因为 TR 总是指向当前 TSS 段的段描述符所在的位置。</li>
</ul>
<p>上面给出的这些工作都是一句长跳转指令 <code>ljmp 段选择子:段内偏移</code>，在段选择子指向的段描述符是 TSS 段时 CPU 解释执行的结果，所以基于 TSS 进行进程/线程切换的 <code>switch_to</code> 实际上就是一句 <code>ljmp</code> 指令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#define switch_to(n) {
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="k">struct</span><span class="p">{</span><span class="kt">long</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">;}</span> <span class="n">tmp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">__asm__</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="s">&#34;movw %%dx,%1&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="s">&#34;ljmp %0&#34;</span> <span class="o">::</span><span class="s">&#34;m&#34;</span><span class="p">(</span><span class="o">*&amp;</span><span class="n">tmp</span><span class="p">.</span><span class="n">a</span><span class="p">),</span> <span class="s">&#34;m&#34;</span><span class="p">(</span><span class="o">*&amp;</span><span class="n">tmp</span><span class="p">.</span><span class="n">b</span><span class="p">),</span> <span class="s">&#34;d&#34;</span><span class="p">(</span><span class="nf">TSS</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#define FIRST_TSS_ENTRY 4
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#define TSS(n) (((unsigned long) n) &lt;&lt; 4) + (FIRST_TSS_ENTRY &lt;&lt; 3))
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>GDT 表的结构如下图所示，所以第一个 TSS 表项，即 0 号进程的 TSS 表项在第 4 个位置上，4&laquo;3，即 <code>4 * 8</code>，相当于 TSS 在 GDT 表中开始的位置，TSS（n）找到的是进程 n 的 TSS 位置，所以还要再加上 n&laquo;4，即 <code>n * 16</code>，因为每个进程对应有 1 个 TSS 和 1 个 LDT，每个描述符的长度都是 8 个字节，所以是乘以 16，其中 LDT 的作用就是上面论述的那个映射表，关于这个表的详细论述要等到内存管理一章。<code>TSS(n) = n * 16 + 4 * 8</code>，得到就是进程 n（切换到的目标进程）的 TSS 选择子，将这个值放到 dx 寄存器中，并且又放置到结构体 tmp 中 32 位长整数 b 的前 16 位，现在 64 位 tmp 中的内容是前 32 位为空，这个 32 位数字是段内偏移，就是 <code>jmpi 0, 8</code> 中的 0；接下来的 16 位是 <code>n * 16 + 4 * 8</code>，这个数字是段选择子，就是 <code>jmpi 0, 8</code> 中的 8，再接下来的 16 位也为空。所以 swith_to 的核心实际上就是 <code>ljmp 空, n*16+4*8</code>，现在和前面给出的基于 TSS 的进程切换联系在一起了。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012340651.png" alt="图片描述信息"  />
</p>
<p>图 2 GDT 表中的内容</p>
<h3 id="42-本次实验的内容">4.2 本次实验的内容<a hidden class="anchor" aria-hidden="true" href="#42-本次实验的内容">#</a></h3>
<p>虽然用一条指令就能完成任务切换，但这指令的执行时间却很长，这条 ljmp 指令在实现任务切换时大概需要 200 多个时钟周期。而通过堆栈实现任务切换可能要更快，而且采用堆栈的切换还可以使用指令流水的并行优化技术，同时又使得 CPU 的设计变得简单。所以无论是 Linux 还是 Windows，进程/线程的切换都没有使用 Intel 提供的这种 TSS 切换手段，而都是通过堆栈实现的。</p>
<p>本次实践项目就是将 Linux 0.11 中采用的 TSS 切换部分去掉，取而代之的是基于堆栈的切换程序。具体的说，就是将 Linux 0.11 中的 switch_to 实现去掉，写成一段基于堆栈切换的代码。</p>
<p>在现在的 Linux 0.11 中，真正完成进程切换是依靠任务状态段（Task State Segment，简称 TSS）的切换来完成的。具体的说，在设计“Intel 架构”（即 x86 系统结构）时，每个任务（进程或线程）都对应一个独立的 TSS，TSS 就是内存中的一个结构体，里面包含了几乎所有的 CPU 寄存器的映像。有一个任务寄存器（Task Register，简称 TR）指向当前进程对应的 TSS 结构体，所谓的 TSS 切换就将 CPU 中几乎所有的寄存器都复制到 TR 指向的那个 TSS 结构体中保存起来，同时找到一个目标 TSS，即要切换到的下一个进程对应的 TSS，将其中存放的寄存器映像“扣在”CPU 上，就完成了执行现场的切换。</p>
<p>要实现基于内核栈的任务切换，主要完成如下三件工作：</p>
<ul>
<li>（1）重写 <code>switch_to</code>；</li>
<li>（2）将重写的 <code>switch_to</code> 和 <code>schedule()</code> 函数接在一起；</li>
<li>（3）修改现在的 <code>fork()</code>。</li>
</ul>
<h3 id="43-schedule-与-switch_to">4.3 schedule 与 switch_to<a hidden class="anchor" aria-hidden="true" href="#43-schedule-与-switch_to">#</a></h3>
<p>目前 Linux 0.11 中工作的 schedule() 函数是首先找到下一个进程的数组位置 next，而这个 next 就是 GDT 中的 n，所以这个 next 是用来找到切换后目标 TSS 段的段描述符的，一旦获得了这个 next 值，直接调用上面剖析的那个宏展开 switch_to(next);就能完成如图 TSS 切换所示的切换了。</p>
<p>现在，我们不用 TSS 进行切换，而是采用切换内核栈的方式来完成进程切换，所以在新的 switch_to 中将用到当前进程的 PCB、目标进程的 PCB、当前进程的内核栈、目标进程的内核栈等信息。由于 Linux 0.11 进程的内核栈和该进程的 PCB 在同一页内存上（一块 4KB 大小的内存），其中 PCB 位于这页内存的低地址，栈位于这页内存的高地址；另外，<code>由于当前进程的 PCB 是用一个全局变量 current 指向的，所以只要告诉新 switch_to()函数一个指向目标进程 PCB 的指针就可以了</code>。同时还要将 next 也传递进去，虽然 TSS(next)不再需要了，但是 LDT(next)仍然是需要的，也就是说，现在每个进程不用有自己的 TSS 了，因为已经不采用 TSS 进程切换了，但是每个进程需要有自己的 LDT，地址分离地址还是必须要有的，而进程切换必然要涉及到 LDT 的切换。</p>
<p>综上所述，需要将目前的 <code>schedule()</code> 函数（在 <code>kernal/sched.c</code> 中）做稍许修改，即将下面的代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">TASK_RUNNING</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">counter</span> <span class="o">&gt;</span> <span class="n">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">counter</span><span class="p">,</span> <span class="n">next</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//......
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nf">switch_to</span><span class="p">(</span><span class="n">next</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>修改为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">TASK_RUNNING</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">counter</span> <span class="o">&gt;</span> <span class="n">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">counter</span><span class="p">,</span> <span class="n">next</span> <span class="o">=</span> <span class="n">i</span><span class="p">,</span> <span class="n">pnext</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//.......
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nf">switch_to</span><span class="p">(</span><span class="n">pnext</span><span class="p">,</span> <span class="nf">LDT</span><span class="p">(</span><span class="n">next</span><span class="p">));</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="44-实现-switch_to">4.4 实现 switch_to<a hidden class="anchor" aria-hidden="true" href="#44-实现-switch_to">#</a></h3>
<p>实现 <code>switch_to</code> 是本次实践项目中最重要的一部分。</p>
<p>由于要对内核栈进行精细的操作，所以需要用汇编代码来完成函数 <code>switch_to</code> 的编写。</p>
<p>这个函数依次主要完成如下功能：由于是 C 语言调用汇编，所以需要首先在汇编中处理栈帧，即处理 <code>ebp</code> 寄存器；接下来要取出表示下一个进程 PCB 的参数，并和 <code>current</code> 做一个比较，如果等于 current，则什么也不用做；如果不等于 current，就开始进程切换，依次完成 PCB 的切换、TSS 中的内核栈指针的重写、内核栈的切换、LDT 的切换以及 PC 指针（即 CS:EIP）的切换。</p>
<p><a href="https://blog.csdn.net/yu97271486/article/details/80425089">EBP 和 ESP 详解</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">switch_to:
</span></span><span class="line"><span class="cl">    pushl %ebp
</span></span><span class="line"><span class="cl">    movl %esp,%ebp
</span></span><span class="line"><span class="cl">    pushl %ecx
</span></span><span class="line"><span class="cl">    pushl %ebx
</span></span><span class="line"><span class="cl">    pushl %eax
</span></span><span class="line"><span class="cl">    movl 8(%ebp),%ebx
</span></span><span class="line"><span class="cl">    cmpl %ebx,current
</span></span><span class="line"><span class="cl">    je 1f
</span></span><span class="line"><span class="cl">! 切换PCB
</span></span><span class="line"><span class="cl">    ! ...
</span></span><span class="line"><span class="cl">! TSS中的内核栈指针的重写
</span></span><span class="line"><span class="cl">    ! ...
</span></span><span class="line"><span class="cl">! 切换内核栈
</span></span><span class="line"><span class="cl">    ! ...
</span></span><span class="line"><span class="cl">! 切换LDT
</span></span><span class="line"><span class="cl">    ! ...
</span></span><span class="line"><span class="cl">    movl $0x17,%ecx
</span></span><span class="line"><span class="cl">    mov %cx,%fs
</span></span><span class="line"><span class="cl">! 和后面的 clts 配合来处理协处理器，由于和主题关系不大，此处不做论述
</span></span><span class="line"><span class="cl">    cmpl %eax,last_task_used_math
</span></span><span class="line"><span class="cl">    jne 1f
</span></span><span class="line"><span class="cl">    clts
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">1:    popl %eax
</span></span><span class="line"><span class="cl">    popl %ebx
</span></span><span class="line"><span class="cl">    popl %ecx
</span></span><span class="line"><span class="cl">    popl %ebp
</span></span><span class="line"><span class="cl">ret
</span></span></code></pre></td></tr></table>
</div>
</div><p>虽然看起来完成了挺多的切换，但实际上每个部分都只有很简单的几条指令。完成 PCB 的切换可以采用下面两条指令，其中 ebx 是从参数中取出来的下一个进程的 PCB 指针，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">movl %ebx,%eax
</span></span><span class="line"><span class="cl">xchgl %eax,current
</span></span></code></pre></td></tr></table>
</div>
</div><p>经过这两条指令以后，eax 指向现在的当前进程，ebx 指向下一个进程，全局变量 current 也指向下一个进程。</p>
<p>TSS 中的内核栈指针的重写可以用下面三条指令完成，其中宏 <code>ESP0 = 4</code>，<code>struct tss_struct *tss = &amp;(init_task.task.tss);</code> 也是定义了一个全局变量，和 current 类似，用来指向那一段 0 号进程的 TSS 内存。</p>
<p>前面已经详细论述过，在中断的时候，要找到内核栈位置，并将用户态下的 <code>SS:ESP</code>，<code>CS:EIP</code> 以及 <code>EFLAGS</code> 这五个寄存器压到内核栈中，这是沟通用户栈（用户态）和内核栈（内核态）的关键桥梁，而找到内核栈位置就依靠 TR 指向的当前 TSS。</p>
<p>现在虽然不使用 TSS 进行任务切换了，但是 Intel 的这态中断处理机制还要保持，所以仍然需要有一个当前 TSS，这个 TSS 就是我们定义的那个全局变量 tss，即 0 号进程的 tss，所有进程都共用这个 tss，任务切换时不再发生变化。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">movl tss,%ecx
</span></span><span class="line"><span class="cl">addl $4096,%ebx
</span></span><span class="line"><span class="cl">movl %ebx,ESP0(%ecx)
</span></span></code></pre></td></tr></table>
</div>
</div><p>定义 <code>ESP0 = 4</code> 是因为 TSS 中内核栈指针 esp0 就放在偏移为 4 的地方，看一看 tss 的结构体定义就明白了。</p>
<p>完成内核栈的切换也非常简单，和我们前面给出的论述完全一致，将寄存器 esp（内核栈使用到当前情况时的栈顶位置）的值保存到当前 PCB 中，再从下一个 PCB 中的对应位置上取出保存的内核栈栈顶放入 esp 寄存器，这样处理完以后，再使用内核栈时使用的就是下一个进程的内核栈了。</p>
<p>由于现在的 Linux 0.11 的 PCB 定义中没有保存内核栈指针这个域（kernelstack），所以需要加上，而宏 <code>KERNEL_STACK</code> 就是你加的那个位置，当然将 kernelstack 域加在 task_struct 中的哪个位置都可以，但是在某些汇编文件中（主要是在 <code>kernal/system_call.s</code> 中）有些关于操作这个结构一些汇编硬编码，所以一旦增加了 kernelstack，这些硬编码需要跟着修改，由于第一个位置，即 long state 出现的汇编硬编码很多，所以 kernelstack 千万不要放置在 task_struct 中的第一个位置，当放在其他位置时，修改 <code>kernal/system_call.s</code> 中的那些硬编码就可以了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">KERNEL_STACK = 12
</span></span><span class="line"><span class="cl">movl %esp,KERNEL_STACK(%eax)
</span></span><span class="line"><span class="cl">! 再取一下 ebx，因为前面修改过 ebx 的值
</span></span><span class="line"><span class="cl">movl 8(%ebp),%ebx
</span></span><span class="line"><span class="cl">movl KERNEL_STACK(%ebx),%esp
</span></span></code></pre></td></tr></table>
</div>
</div><p>task_struct 的定义：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// 在 include/linux/sched.h 中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="n">task_struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">long</span> <span class="n">state</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">long</span> <span class="n">counter</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">long</span> <span class="n">priority</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">long</span> <span class="n">kernelstack</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">//......
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>由于这里将 PCB 结构体的定义改变了，所以在产生 0 号进程的 PCB 初始化时也要跟着一起变化，需要将原来的 <code>#define INIT_TASK { 0,15,15, 0,{{},},0,...</code> 修改为 <code>#define INIT_TASK { 0,15,15,PAGE_SIZE+(long)&amp;init_task, 0,{{},},0,...</code>，即在 PCB 的第四项中增加关于内核栈栈指针的初始化。</p>
<p>再下一个切换就是 LDT 的切换了，指令 <code>movl 12(%ebp),%ecx</code> 负责取出对应 LDT(next)的那个参数，指令 <code>lldt %cx</code> 负责修改 LDTR 寄存器，一旦完成了修改，下一个进程在执行用户态程序时使用的映射表就是自己的 LDT 表了，地址空间实现了分离。</p>
<p>最后一个切换是关于 PC 的切换，和前面论述的一致，依靠的就是 <code>switch_to</code> 的最后一句指令 ret，虽然简单，但背后发生的事却很多：<code>schedule()</code> 函数的最后调用了这个 <code>switch_to</code> 函数，所以这句指令 ret 就返回到下一个进程（目标进程）的 <code>schedule()</code> 函数的末尾，遇到的是}，继续 ret 回到调用的 <code>schedule()</code> 地方，是在中断处理中调用的，所以回到了中断处理中，就到了中断返回的地址，再调用 iret 就到了目标进程的用户态程序去执行，和书中论述的内核态线程切换的五段论是完全一致的。</p>
<p>这里还有一个地方需要格外注意，那就是 switch_to 代码中在切换完 LDT 后的两句，即：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">! 切换 LDT 之后
</span></span><span class="line"><span class="cl">movl $0x17,%ecx
</span></span><span class="line"><span class="cl">mov %cx,%fs
</span></span></code></pre></td></tr></table>
</div>
</div><p>这两句代码的含义是重新取一下段寄存器 fs 的值，这两句话必须要加、也必须要出现在切换完 LDT 之后，这是因为在实践项目 2 中曾经看到过 fs 的作用——通过 fs 访问进程的用户态内存，LDT 切换完成就意味着切换了分配给进程的用户态内存地址空间，所以前一个 fs 指向的是上一个进程的用户态内存，而现在需要执行下一个进程的用户态内存，所以就需要用这两条指令来重取 fs。</p>
<p>不过，细心的读者可能会发现：fs 是一个选择子，即 fs 是一个指向描述符表项的指针，这个描述符才是指向实际的用户态内存的指针，所以上一个进程和下一个进程的 fs 实际上都是 0x17，真正找到不同的用户态内存是因为两个进程查的 LDT 表不一样，所以这样重置一下 <code>fs=0x17</code> 有用吗，有什么用？要回答这个问题就需要对段寄存器有更深刻的认识，实际上段寄存器包含两个部分：显式部分和隐式部分，如下图给出实例所示，就是那个著名的 <code>jmpi 0, 8</code>，虽然我们的指令是让 <code>cs=8</code>，但在执行这条指令时，会在段表（GDT）中找到 8 对应的那个描述符表项，取出基地址和段限长，除了完成和 eip 的累加算出 PC 以外，还会将取出的基地址和段限长放在 cs 的隐藏部分，即图中的基地址 0 和段限长 7FF。为什么要这样做？下次执行 <code>jmp 100</code> 时，由于 cs 没有改过，仍然是 8，所以可以不再去查 GDT 表，而是直接用其隐藏部分中的基地址 0 和 100 累加直接得到 PC，增加了执行指令的效率。现在想必明白了为什么重新设置 fs=0x17 了吧？而且为什么要出现在切换完 LDT 之后？</p>
<img src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012340657.png" alt="图片描述信息" style="zoom:150%;" /> 
<p>图 3 段寄存器中的两个部分</p>
<h3 id="45-修改-fork">4.5 修改 fork<a hidden class="anchor" aria-hidden="true" href="#45-修改-fork">#</a></h3>
<p>开始修改 fork() 了，和书中论述的原理一致，就是要把进程的用户栈、用户程序和其内核栈通过压在内核栈中的 <code>SS:ESP</code>，<code>CS:IP</code> 关联在一起。</p>
<p>另外，由于 fork() 这个叉子的含义就是要让父子进程共用同一个代码、数据和堆栈，现在虽然是使用内核栈完成任务切换，但 fork() 的基本含义不会发生变化。</p>
<p>将上面两段描述联立在一起，修改 fork() 的核心工作就是要形成如下图所示的子进程内核栈结构。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012340662.png" alt="图片描述信息"  />
</p>
<p>图 4 fork 进程的父子进程结构</p>
<p>不难想象，对 fork() 的修改就是对子进程的内核栈的初始化，在 fork() 的核心实现 <code>copy_process</code> 中，<code>p = (struct task_struct *) get_free_page();</code>用来完成申请一页内存作为子进程的 PCB，而 p 指针加上页面大小就是子进程的内核栈位置，所以语句 <code>krnstack = (long *) (PAGE_SIZE + (long) p);</code> 就可以找到子进程的内核栈位置，接下来就是初始化 krnstack 中的内容了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="o">*</span><span class="p">(</span><span class="o">--</span><span class="n">krnstack</span><span class="p">)</span> <span class="o">=</span> <span class="n">ss</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="o">*</span><span class="p">(</span><span class="o">--</span><span class="n">krnstack</span><span class="p">)</span> <span class="o">=</span> <span class="n">esp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="o">*</span><span class="p">(</span><span class="o">--</span><span class="n">krnstack</span><span class="p">)</span> <span class="o">=</span> <span class="n">eflags</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="o">*</span><span class="p">(</span><span class="o">--</span><span class="n">krnstack</span><span class="p">)</span> <span class="o">=</span> <span class="n">cs</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="o">*</span><span class="p">(</span><span class="o">--</span><span class="n">krnstack</span><span class="p">)</span> <span class="o">=</span> <span class="n">eip</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这五条语句就完成了上图所示的那个重要的关联，因为其中 ss,esp 等内容都是 <code>copy_proces()</code> 函数的参数，这些参数来自调用 <code>copy_proces()</code> 的进程的内核栈中，就是父进程的内核栈中，所以上面给出的指令不就是将父进程内核栈中的前五个内容拷贝到子进程的内核栈中，图中所示的关联不也就是一个拷贝吗？</p>
<p>接下来的工作就需要和 switch_to 接在一起考虑了，故事从哪里开始呢？回顾一下前面给出来的 switch_to，应该从 “切换内核栈” 完事的那个地方开始，现在到子进程的内核栈开始工作了，接下来做的四次弹栈以及 ret 处理使用的都是子进程内核栈中的东西，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">1: popl %eax
</span></span><span class="line"><span class="cl">    popl %ebx
</span></span><span class="line"><span class="cl">    popl %ecx
</span></span><span class="line"><span class="cl">    popl %ebp
</span></span><span class="line"><span class="cl">ret
</span></span></code></pre></td></tr></table>
</div>
</div><p>为了能够顺利完成这些弹栈工作，子进程的内核栈中应该有这些内容，所以需要对 krnstack 进行初始化：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="o">*</span><span class="p">(</span><span class="o">--</span><span class="n">krnstack</span><span class="p">)</span> <span class="o">=</span> <span class="n">ebp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="o">*</span><span class="p">(</span><span class="o">--</span><span class="n">krnstack</span><span class="p">)</span> <span class="o">=</span> <span class="n">ecx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="o">*</span><span class="p">(</span><span class="o">--</span><span class="n">krnstack</span><span class="p">)</span> <span class="o">=</span> <span class="n">ebx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 这里的 0 最有意思。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">*</span><span class="p">(</span><span class="o">--</span><span class="n">krnstack</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>现在到了 ret 指令了，这条指令要从内核栈中弹出一个 32 位数作为 EIP 跳去执行，所以需要弄一个函数地址（仍然是一段汇编程序，所以这个地址是这段汇编程序开始处的标号）并将其初始化到栈中。我们弄的一个名为 <code>first_return_from_kernel</code> 的汇编标号，然后可以用语句 <code>*(--krnstack) = (long) first_return_from_kernel;</code> 将这个地址初始化到子进程的内核栈中，现在执行 ret 以后就会跳转到 <code>first_return_from_kernel</code> 去执行了。</p>
<p>想一想 <code>first_return_from_kernel</code> 要完成什么工作？PCB 切换完成、内核栈切换完成、LDT 切换完成，接下来应该那个“内核级线程切换五段论”中的最后一段切换了，即完成用户栈和用户代码的切换，依靠的核心指令就是 iret，当然在切换之前应该回复一下执行现场，主要就是 <code>eax,ebx,ecx,edx,esi,edi,gs,fs,es,ds</code> 等寄存器的恢复.</p>
<p>下面给出了 <code>first_return_from_kernel</code> 的核心代码，当然 edx 等寄存器的值也应该先初始化到子进程内核栈，即 krnstack 中。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">popl %edx
</span></span><span class="line"><span class="cl">popl %edi
</span></span><span class="line"><span class="cl">popl %esi
</span></span><span class="line"><span class="cl">pop %gs
</span></span><span class="line"><span class="cl">pop %fs
</span></span><span class="line"><span class="cl">pop %es
</span></span><span class="line"><span class="cl">pop %ds
</span></span><span class="line"><span class="cl">iret
</span></span></code></pre></td></tr></table>
</div>
</div><p>最后别忘了将存放在 PCB 中的内核栈指针修改到初始化完成时内核栈的栈顶，即：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">p</span><span class="o">-&gt;</span><span class="n">kernelstack</span> <span class="o">=</span> <span class="n">stack</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="实验步骤">实验步骤<a hidden class="anchor" aria-hidden="true" href="#实验步骤">#</a></h2>
<h3 id="1修改kernelsystem_calls文件">1.修改/kernel/system_call.s文件<a hidden class="anchor" aria-hidden="true" href="#1修改kernelsystem_calls文件">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">.globl system_call,sys_fork,timer_interrupt,sys_execve
</span></span><span class="line"><span class="cl">.globl hd_interrupt,floppy_interrupt,parallel_interrupt
</span></span><span class="line"><span class="cl">.globl device_not_available, coprocessor_error
</span></span><span class="line"><span class="cl"># 以上是原代码部分，以下是需要新建的代码
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># system_call.s
</span></span><span class="line"><span class="cl"># 汇编语言中定义的方法可以被其他调用需要
</span></span><span class="line"><span class="cl">.globl switch_to
</span></span><span class="line"><span class="cl">.globl first_return_from_kernel
</span></span><span class="line"><span class="cl"># 硬编码改变 these are offsets into the task-struct
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">ESP0 = 4
</span></span><span class="line"><span class="cl">KERNEL_STACK = 12
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">state	= 0		# these are offsets into the task-struct.
</span></span><span class="line"><span class="cl">counter	= 4
</span></span><span class="line"><span class="cl">priority = 8
</span></span><span class="line"><span class="cl">kernelstack = 12
</span></span><span class="line"><span class="cl">signal	= 16
</span></span><span class="line"><span class="cl">sigaction = 20		# MUST be 16 (=len of sigaction)
</span></span><span class="line"><span class="cl">blocked = (37*16)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">switch_to:
</span></span><span class="line"><span class="cl">    pushl %ebp
</span></span><span class="line"><span class="cl">    movl %esp,%ebp
</span></span><span class="line"><span class="cl">    pushl %ecx
</span></span><span class="line"><span class="cl">    pushl %ebx
</span></span><span class="line"><span class="cl">    pushl %eax
</span></span><span class="line"><span class="cl">    movl 8(%ebp),%ebx
</span></span><span class="line"><span class="cl">    cmpl %ebx,current
</span></span><span class="line"><span class="cl">    je 1f
</span></span><span class="line"><span class="cl"># switch_to PCB
</span></span><span class="line"><span class="cl">    movl %ebx,%eax
</span></span><span class="line"><span class="cl">	xchgl %eax,current
</span></span><span class="line"><span class="cl"># rewrite TSS pointer
</span></span><span class="line"><span class="cl">    movl tss,%ecx
</span></span><span class="line"><span class="cl">    addl $4096,%ebx
</span></span><span class="line"><span class="cl">    movl %ebx,ESP0(%ecx)
</span></span><span class="line"><span class="cl"># switch_to system core stack
</span></span><span class="line"><span class="cl">    movl %esp,KERNEL_STACK(%eax)
</span></span><span class="line"><span class="cl">    movl 8(%ebp),%ebx
</span></span><span class="line"><span class="cl">    movl KERNEL_STACK(%ebx),%esp
</span></span><span class="line"><span class="cl"># switch_to LDT
</span></span><span class="line"><span class="cl">	movl 12(%ebp), %ecx
</span></span><span class="line"><span class="cl">    lldt %cx
</span></span><span class="line"><span class="cl">    movl $0x17,%ecx
</span></span><span class="line"><span class="cl">	mov %cx,%fs
</span></span><span class="line"><span class="cl"># nonsense
</span></span><span class="line"><span class="cl">    cmpl %eax,last_task_used_math 
</span></span><span class="line"><span class="cl">    jne 1f
</span></span><span class="line"><span class="cl">    clts
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">1:    popl %eax
</span></span><span class="line"><span class="cl">    popl %ebx
</span></span><span class="line"><span class="cl">    popl %ecx
</span></span><span class="line"><span class="cl">    popl %ebp
</span></span><span class="line"><span class="cl">ret
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">.align 2
</span></span><span class="line"><span class="cl">first_return_from_kernel: 
</span></span><span class="line"><span class="cl">    popl %edx
</span></span><span class="line"><span class="cl">    popl %edi
</span></span><span class="line"><span class="cl">    popl %esi
</span></span><span class="line"><span class="cl">    pop %gs
</span></span><span class="line"><span class="cl">    pop %fs
</span></span><span class="line"><span class="cl">    pop %es
</span></span><span class="line"><span class="cl">    pop %ds
</span></span><span class="line"><span class="cl">    iret
</span></span></code></pre></td></tr></table>
</div>
</div><p>该段代码完成的工作如下：
1.<strong>pushl %ebp</strong>
首先在汇编中处理栈帧，即处理 ebp 寄存器
2.<strong>cmpl %ebx,current</strong>
接下来要取出表示下一个进程 PCB 的参数，并和 current 做一个比较，如果等于 current，则什么也不用做。不等于 current，就开始进程切换。
3.<strong>switch_to PCB 完成 PCB 的切换</strong>
ebx是从参数中取出来的下一个进程的 PCB 指针，经过两条指令以后，eax 指向现在的当前进程，ebx指向下一个进程，全局变量 current 也指向下一个进程。
4.<strong>rewrite TSS pointer TSS 中的内核栈指针的重写</strong>
中断处理时需要寻找当前进程的内核栈，否则就不能从用户栈切到内核栈(中断处理没法完成)，内核栈的寻找是借助当前进程TSS中存放的信息来完成的。
5.<strong>switch_to system core stack内核栈的切换</strong>
将寄存器 esp（内核栈使用到当前情况时的栈顶位置）的值保存到当前 PCB 中，再从下一个 PCB 中的对应位置上取出保存的内核栈栈顶放入 esp寄存器，这样处理完以后，再使用内核栈时使用的就是下一个进程的内核栈了。
6.<strong>switch_to LDT LDT的切换</strong>
指令 movl 12(%ebp),%ecx 负责取出对应 LDT(next)的那个参数，指令 lldt %cx 负责修改 LDTR 寄存器，一旦完成了修改，下一个进程在执行用户态程序时使用的映射表就是自己的 LDT 表了，地址空间实现了分离。
最后，通过FS操作系统才能访问进程的用户态内存。这里LDT切换完成意味着切换到了新的用户态地址空间，所以需要重置FS。
代码截图如下（部分）:
<img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012340665.png" alt="img"  />
</p>
<h3 id="2修改includelinuxschedh文件">2.修改/include/linux/sched.h文件<a hidden class="anchor" aria-hidden="true" href="#2修改includelinuxschedh文件">#</a></h3>
<p>注释掉原来switch_to宏函数，截图如下：
<img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012340674.png" alt="img"  />
</p>
<p>基于堆栈的切换程序要做到承上启下：</p>
<ul>
<li>承上：基于堆栈的切换，要用到当前进程(current指向)与目标进程的PCB，当前进程与目标进程的内核栈等
Linux 0.11 进程的内核栈和该进程的 PCB 在同一页内存上（一块 4KB 大小的内存），其中 PCB 位于这页内存的低地址，栈位于这页内存的高地址</li>
<li>启下：要将next传递下去，虽然 TSS(next)不再需要了，但是 LDT(next)仍然是需要的。
之前的进程控制块(pcb)中是没有保存内核栈信息的寄存器的，所以需要在sched.h中的task_struct(也就是pcb)中添加kernelstack。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">task_struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* these are hardcoded - don&#39;t touch */</span>
</span></span><span class="line"><span class="cl">	<span class="kt">long</span> <span class="n">state</span><span class="p">;</span>	<span class="cm">/* -1 unrunnable, 0 runnable, &gt;0 stopped */</span>
</span></span><span class="line"><span class="cl">	<span class="kt">long</span> <span class="n">counter</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">long</span> <span class="n">priority</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//新增kernelstack
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">long</span> <span class="n">kernelstack</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">long</span> <span class="n">signal</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">struct</span> <span class="n">sigaction</span> <span class="n">sigaction</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//......
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>代码截图如下：
<img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012340177.png" alt="img"  />
</p>
<p>由于这里将 PCB 结构体的定义改变了，所以在产生 0 号进程的 PCB 初始化时也要跟着一起变化，需要修改 #define INIT_TASK，即在 PCB 的第四项中增加关于内核栈栈指针的初始化。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#define INIT_TASK \
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="cm">/* state etc */</span><span class="cp">	{ 0,15,15,PAGE_SIZE+(long)&amp;init_task, \
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="c1">//......
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>代码截图如下:
<img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012340204.png" alt="img"  />
</p>
<h3 id="3修改kernelschedc文件">3.修改/kernel/sched.c文件<a hidden class="anchor" aria-hidden="true" href="#3修改kernelschedc文件">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// 添加的代码,定义tss
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tss</span><span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">init_task</span><span class="p">.</span><span class="n">task</span><span class="p">.</span><span class="n">tss</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">schedule</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">next</span><span class="p">,</span><span class="n">c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">**</span> <span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">pnext</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="c1">// 添加的代码,赋值初始化任务的指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cm">/* check alarm, wake up any interruptible tasks that have got a signal */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">for</span><span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">LAST_TASK</span> <span class="p">;</span> <span class="n">p</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">FIRST_TASK</span> <span class="p">;</span> <span class="o">--</span><span class="n">p</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">alarm</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">alarm</span> <span class="o">&lt;</span> <span class="n">jiffies</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">signal</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">SIGALRM</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">					<span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">alarm</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">(((</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">signal</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">_BLOCKABLE</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">blocked</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">			<span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">state</span><span class="o">==</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">					<span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">state</span><span class="o">=</span><span class="n">TASK_RUNNING</span><span class="p">;</span>			
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/* this is the scheduler proper: */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">c</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">next</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 添加的代码. 如果系统没有进程可以调度时传递进去的是一个空值，系统宕机，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 所以加上这句，这样就可以在next=0时不会有空指针传递
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">pnext</span> <span class="o">=</span> <span class="n">task</span><span class="p">[</span><span class="n">next</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">		
</span></span><span class="line"><span class="cl">		<span class="n">i</span> <span class="o">=</span> <span class="n">NR_TASKS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">task</span><span class="p">[</span><span class="n">NR_TASKS</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">		<span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">(</span><span class="o">!*--</span><span class="n">p</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">TASK_RUNNING</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">counter</span><span class="o">&gt;</span> <span class="n">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">counter</span><span class="p">,</span> <span class="n">next</span> <span class="o">=</span> <span class="n">i</span><span class="p">,</span> <span class="n">pnext</span><span class="o">=*</span><span class="n">p</span><span class="p">;</span><span class="c1">// 修改添加的代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span><span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">LAST_TASK</span> <span class="p">;</span> <span class="n">p</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">FIRST_TASK</span> <span class="p">;</span> <span class="o">--</span><span class="n">p</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">counter</span> <span class="o">=</span> <span class="p">((</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">counter</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">						<span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">priority</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//switch_to(next);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">switch_to</span><span class="p">(</span><span class="n">pnext</span><span class="p">,</span> <span class="nf">_LDT</span><span class="p">(</span><span class="n">next</span><span class="p">));</span> <span class="c1">// 修改添加的代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>更改截图如下：
<img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012340229.png" alt="img"  />
</p>
<h3 id="4修改forkc文件">4.修改fork.c文件<a hidden class="anchor" aria-hidden="true" href="#4修改forkc文件">#</a></h3>
<p>对fork()的修改就是对子进程的内核栈的初始化，在fork()的核心实现copy_process中，p = (struct task_struct) get_free_page();用来完成申请一页内存作为子进程的PCB，而p指针加上页面大小就是子进程的内核栈位置. 所以需要再定义一个指针变量krnstack, 并将其初始化为内核栈顶指针, 然后再根据传递进来的参数把前一个进程的PCB中各种信息都保存到当前栈中。
可以将原代码copy_process函数注释，替换为以下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">//fork.c
</span></span></span><span class="line"><span class="cl"><span class="c1">//6th
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">extern</span> <span class="kt">void</span> <span class="nf">first_return_from_kernel</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//fork.c copy_process()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">copy_process</span><span class="p">(</span><span class="kt">int</span> <span class="n">nr</span><span class="p">,</span><span class="kt">long</span> <span class="n">ebp</span><span class="p">,</span><span class="kt">long</span> <span class="n">edi</span><span class="p">,</span><span class="kt">long</span> <span class="n">esi</span><span class="p">,</span><span class="kt">long</span> <span class="n">gs</span><span class="p">,</span><span class="kt">long</span> <span class="n">none</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="kt">long</span> <span class="n">ebx</span><span class="p">,</span><span class="kt">long</span> <span class="n">ecx</span><span class="p">,</span><span class="kt">long</span> <span class="n">edx</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="kt">long</span> <span class="n">fs</span><span class="p">,</span><span class="kt">long</span> <span class="n">es</span><span class="p">,</span><span class="kt">long</span> <span class="n">ds</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="kt">long</span> <span class="n">eip</span><span class="p">,</span><span class="kt">long</span> <span class="n">cs</span><span class="p">,</span><span class="kt">long</span> <span class="n">eflags</span><span class="p">,</span><span class="kt">long</span> <span class="n">esp</span><span class="p">,</span><span class="kt">long</span> <span class="n">ss</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">long</span> <span class="o">*</span> <span class="n">krnstack</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">//1st
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="p">)</span> <span class="nf">get_free_page</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">task</span><span class="p">[</span><span class="n">nr</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">*</span><span class="n">current</span><span class="p">;</span>    <span class="cm">/* NOTE! this doesn&#39;t copy the supervisor stack */</span>
</span></span><span class="line"><span class="cl">    <span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">p</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">=</span> <span class="n">last_pid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">p</span><span class="o">-&gt;</span><span class="n">father</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">p</span><span class="o">-&gt;</span><span class="n">counter</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">priority</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">p</span><span class="o">-&gt;</span><span class="n">signal</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">p</span><span class="o">-&gt;</span><span class="n">alarm</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">p</span><span class="o">-&gt;</span><span class="n">leader</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>        <span class="cm">/* process leadership doesn&#39;t inherit */</span>
</span></span><span class="line"><span class="cl">    <span class="n">p</span><span class="o">-&gt;</span><span class="n">utime</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">stime</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">p</span><span class="o">-&gt;</span><span class="n">cutime</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">cstime</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">p</span><span class="o">-&gt;</span><span class="n">start_time</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">last_task_used_math</span> <span class="o">==</span> <span class="n">current</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">__asm__</span><span class="p">(</span><span class="s">&#34;clts ; fnsave %0&#34;</span><span class="o">::</span><span class="s">&#34;m&#34;</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">tss</span><span class="p">.</span><span class="n">i387</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nf">copy_mem</span><span class="p">(</span><span class="n">nr</span><span class="p">,</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">task</span><span class="p">[</span><span class="n">nr</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nf">free_page</span><span class="p">((</span><span class="kt">long</span><span class="p">)</span> <span class="n">p</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">//2nd
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">krnstack</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">+</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">p</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="p">(</span><span class="o">--</span><span class="n">krnstack</span><span class="p">)</span> <span class="o">=</span> <span class="n">ss</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="p">(</span><span class="o">--</span><span class="n">krnstack</span><span class="p">)</span> <span class="o">=</span> <span class="n">esp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="p">(</span><span class="o">--</span><span class="n">krnstack</span><span class="p">)</span> <span class="o">=</span> <span class="n">eflags</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="p">(</span><span class="o">--</span><span class="n">krnstack</span><span class="p">)</span> <span class="o">=</span> <span class="n">cs</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="p">(</span><span class="o">--</span><span class="n">krnstack</span><span class="p">)</span> <span class="o">=</span> <span class="n">eip</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="p">(</span><span class="o">--</span><span class="n">krnstack</span><span class="p">)</span> <span class="o">=</span> <span class="n">ds</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="p">(</span><span class="o">--</span><span class="n">krnstack</span><span class="p">)</span> <span class="o">=</span> <span class="n">es</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="p">(</span><span class="o">--</span><span class="n">krnstack</span><span class="p">)</span> <span class="o">=</span> <span class="n">fs</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="p">(</span><span class="o">--</span><span class="n">krnstack</span><span class="p">)</span> <span class="o">=</span> <span class="n">gs</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="p">(</span><span class="o">--</span><span class="n">krnstack</span><span class="p">)</span> <span class="o">=</span> <span class="n">esi</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="p">(</span><span class="o">--</span><span class="n">krnstack</span><span class="p">)</span> <span class="o">=</span> <span class="n">edi</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="p">(</span><span class="o">--</span><span class="n">krnstack</span><span class="p">)</span> <span class="o">=</span> <span class="n">edx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">//3rd
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="o">*</span><span class="p">(</span><span class="o">--</span><span class="n">krnstack</span><span class="p">)</span> <span class="o">=</span> <span class="n">first_return_from_kernel</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">//4th
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">*</span><span class="p">(</span><span class="o">--</span><span class="n">krnstack</span><span class="p">)</span> <span class="o">=</span> <span class="n">ebp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="p">(</span><span class="o">--</span><span class="n">krnstack</span><span class="p">)</span> <span class="o">=</span> <span class="n">ecx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="p">(</span><span class="o">--</span><span class="n">krnstack</span><span class="p">)</span> <span class="o">=</span> <span class="n">ebx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="p">(</span><span class="o">--</span><span class="n">krnstack</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">//5th
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">p</span><span class="o">-&gt;</span><span class="n">kernelstack</span> <span class="o">=</span> <span class="n">krnstack</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">NR_OPEN</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">((</span><span class="n">f</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">filp</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
</span></span><span class="line"><span class="cl">            <span class="n">f</span><span class="o">-&gt;</span><span class="n">f_count</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">pwd</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">current</span><span class="o">-&gt;</span><span class="n">pwd</span><span class="o">-&gt;</span><span class="n">i_count</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">current</span><span class="o">-&gt;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">i_count</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">executable</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">current</span><span class="o">-&gt;</span><span class="n">executable</span><span class="o">-&gt;</span><span class="n">i_count</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">set_tss_desc</span><span class="p">(</span><span class="n">gdt</span><span class="o">+</span><span class="p">(</span><span class="n">nr</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">FIRST_TSS_ENTRY</span><span class="p">,</span><span class="o">&amp;</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">tss</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="nf">set_ldt_desc</span><span class="p">(</span><span class="n">gdt</span><span class="o">+</span><span class="p">(</span><span class="n">nr</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">FIRST_LDT_ENTRY</span><span class="p">,</span><span class="o">&amp;</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ldt</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">TASK_RUNNING</span><span class="p">;</span>    <span class="cm">/* do this last, just in case */</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">last_pid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012340273.png" alt="img"  />
</p>
<h3 id="5验证结果">5.验证结果<a hidden class="anchor" aria-hidden="true" href="#5验证结果">#</a></h3>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012340969.png" alt="img"  />
</p>
<p>经过验证，用修改后的 Linux 0.11 仍然可以启动、可以正常使用。</p>


  </div>

  <footer class="post-footer">
    
<nav class="paginav">
  <a class="prev" href="https://chance7bin.github.io/posts/basic/pattern/%E8%A1%8C%E4%B8%BA%E6%A8%A1%E5%BC%8F/">
    <span class="title">« 上一页</span>
    <br>
    <span>行为模式</span>
  </a>
  <a class="next" href="https://chance7bin.github.io/posts/basic/os/%E4%BA%94%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/">
    <span class="title">下一页 »</span>
    <br>
    <span>五、存储管理</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://chance7bin.github.io/">Binb&#39;s Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
