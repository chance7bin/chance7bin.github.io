<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>图解TCPIP | Binb&#39;s Blog</title>
<meta name="keywords" content="计算机网络, TCPIP">
<meta name="description" content="写在前面 该篇博客是我在看《图解TCPIP》这本书时记录的学习笔记✍~~ 第1章 网络基础知识 计算机网络，根据其规模可分为==WAN（Wide Area N">
<meta name="author" content="chance7bin">
<link rel="canonical" href="https://chance7bin.github.io/posts/basic/network/%E5%9B%BE%E8%A7%A3tcpip/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.be81eec981a615a87a88f121642d7eebde74d033438693944db2fd6b827284ff.css" integrity="" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.acb54fd32bbc1982428b8850317e45d076b95012730a5936667e6bc21777692a.js" integrity=""
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://chance7bin.github.io/img/%E7%BE%8E%E9%98%9F.jpg">
<link rel="icon" type="image/png" sizes="16x16" href="https://chance7bin.github.io/img/%E7%BE%8E%E9%98%9F.jpg">
<link rel="icon" type="image/png" sizes="32x32" href="https://chance7bin.github.io/img/%E7%BE%8E%E9%98%9F.jpg">
<link rel="apple-touch-icon" href="https://chance7bin.github.io/img/%E7%BE%8E%E9%98%9F.jpg">
<link rel="mask-icon" href="https://chance7bin.github.io/img/%E7%BE%8E%E9%98%9F.jpg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="图解TCPIP" />
<meta property="og:description" content="写在前面 该篇博客是我在看《图解TCPIP》这本书时记录的学习笔记✍~~ 第1章 网络基础知识 计算机网络，根据其规模可分为==WAN（Wide Area N" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://chance7bin.github.io/posts/basic/network/%E5%9B%BE%E8%A7%A3tcpip/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-16T00:00:00+00:00" />
<meta property="article:modified_time" content="2022-05-16T00:00:00+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="图解TCPIP"/>
<meta name="twitter:description" content="写在前面 该篇博客是我在看《图解TCPIP》这本书时记录的学习笔记✍~~ 第1章 网络基础知识 计算机网络，根据其规模可分为==WAN（Wide Area N"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "📚 文章",
      "item": "https://chance7bin.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "📕 计算机基础",
      "item": "https://chance7bin.github.io/posts/basic/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "计算机网络",
      "item": "https://chance7bin.github.io/posts/basic/network/"
    }, 
    {
      "@type": "ListItem",
      "position":  4 ,
      "name": "图解TCPIP",
      "item": "https://chance7bin.github.io/posts/basic/network/%E5%9B%BE%E8%A7%A3tcpip/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "图解TCPIP",
  "name": "图解TCPIP",
  "description": "写在前面 该篇博客是我在看《图解TCPIP》这本书时记录的学习笔记✍~~ 第1章 网络基础知识 计算机网络，根据其规模可分为==WAN（Wide Area N",
  "keywords": [
    "计算机网络", "TCPIP"
  ],
  "articleBody": "写在前面 该篇博客是我在看《图解TCPIP》这本书时记录的学习笔记✍~~\n第1章 网络基础知识 计算机网络，根据其规模可分为==WAN（Wide Area Network，广域 网）==（指覆盖多个远距离区域的远程网络。比广域网再小一级的、连接整个城市的网络叫==城域网（MAN，Metropolitan Area Network）==。） 和==LAN（Local Area Network，局域网）==（指一个楼层、一栋楼或一个 校园等相对较小的区域内的网络。） 。\n互联网是由许多独立发展的网络通信技术融合而成。能够使它们之间不断融合并实现统一的正是==TCP/IP技术==。==TCP/IP是通信协议的统称==。\n1.协议 表1.2 各种网络体系结构及其协议\n==协议==就是计算机与计算机之间通过网络实现通信时事先达成的一种“约定”。这种“约定”使那些由不同厂商的设备、不同的CPU以及不同的操作系统组成的计算机之间，只要遵循相同的协议就能够实现通信。\n协议的标准化\nISO（International Organization for Standards，国际标准化组织。）制定了一个国际标准OSI（Open Systems Interconnection，开放式通信系统互联参考模型。） ，对通信系统进行了标准化。现在，OSI所定义的协议虽然并没有得到普及，但是在OSI协议设计之初作为其指导方针的OSI参考模型却常被用于网络协议的制定当中。\n本书将要说明的TCP/IP并非ISO（International Organization for Standards，国际标准化组织）所制定的某种国际标准。而是由 IETF（Internet Engineering Task Force） 所建议的、致力于推进其标准化作业的一种协议。\n2.协议的分层 ISO在制定标准化OSI之前，对网络体系结构相关的问题进行了充分的讨论，最终提出了作为通信协议设计指标的OSI参考模型。这一模型将通信协议中必要的功能分成了7层。通过这些分层，使得那些比较复杂的网络协议更加简单化。\n在这一模型中，每个分层都接收由它下一层所提供的特定服务，并且负责为自己的上一层提供特定的服务。==上下层之间==进行交互时所遵循的约定叫做==“接口”==。==同一层之间==的交互所遵循的约定叫做==“协议”==。\nOSI协议与OSI参考模型 OSI（参考模型）将通信功能划分为7个分层，称作==OSI参考模型==。==OSI协议==（是为了让异构的计算机之间能够相互通信的、由ISO和ITU-T推进其标准化的一种网络体系结构）以OSI参考模型为基础界定了每个阶层的协议和每个阶层之间接口相关的标准。遵循OSI协议的产品叫OSI产品，而它们所遵循的通信则被称为OSI通信。\nOSI参考模型中各个分层的作用 ■ 应用层\n为应用程序提供服务并规定应用程序中通信相关的细节。包括文件传输、电子邮件、远程登录（虚拟终端）等协议。\n■ 表示层\n将应用处理的信息转换为适合网络传输的格式，或将来自下一层的数据转换为上层能够处理的格式。因此它主要负责数据格式的转换。具体来说，就是将设备固有的数据格式转换为网络标准传输格式。不同设备对同一比特流解释的结果可能会不同。因此，使它们保持一致是这一层的主要作用。\n■ 会话层\n负责建立和断开通信连接（数据流动的逻辑通路），以及数据的分割等数据传输相关的管理。\n■ 传输层\n==起着可靠传输的作用==。只在通信双方节点上进行处理，而无需在路由器上处理。 ==（会话层负责决定建立连接和断开连接的时机，而传输层进行实际的建立和断开处理）==\n■ 网络层\n将数据传输到目标地址。目标地址可以是多个网络通过路由器连接而成的某一个地址。因此这一层主要负责寻址和路由选择。 （网络层的作用是在网络与网络相互连接的环境中，将数据从发送端主机发送到接收端主机。两端主机之间虽然有众多数据链路，但能够将数据从主机A送到主机B也都是网络层的功劳。）\n■ 数据链路层\n负责物理层面上互连的、节点之间的通信传输。例如与1个以太网相连的2个节点之间的通信。将0、1序列划分为具有意义的数据帧传送给对端（数据帧的生成与接收）。\n■ 物理层\n负责0、1比特流（0、1序列）与电压的高低、光的闪灭之间的互换。\n3.传输方式的分类 面向有连接型与面向无连接型 通过网络发送数据，大致可以分为面向有连接与面向无连接两种类型（面向无连接型包括以太网、IP、UDP等协议。面向有连接型包括ATM、帧中继、TCP等协议） 。\n电路交换与分组交换 目前，网络通信方式大致分为两种——==电路交换==和==分组交换==。电路交换技术的历史相对久远，主要用于过去的电话网。而分组交换技术则是一种较新的通信方式，从20世纪60年代后半叶才开始逐渐被人们认可。本书着力介绍的==TCP/IP==，正是采用了==分组交换技术==。\n图1.31 电路交换与分组交换的特点\n根据接收端数量分类 单播（Unicast）\n字面上，“Uni”表示“1”，“Cast”意为“投掷”。组合起来就是指1对1通信。早先的固定电话就是单播通信的一个典型例子。\n广播（Broadcast）\n它指是将消息从1台主机发送给与之相连的所有其他主机。广播通信的一个典型例子就是电视播放，它将电视信号一齐发送给非特定的多个接收对象。\n多播（Multicast）\n多播与广播类似，也是将消息发给多个接收主机。不同之处在于多播要限定某一组主机作为接收端。多播通信最典型的例子就是电视会议。\n任播（Anycast）\n任播是指在特定的多台主机中选出一台作为接收端的一种通信方式。虽然，这种方式与多播有相似之处，都是面向特定的一群主机，但是它的行为却与多播不同。任播通信从目标主机群中选择一台最符合网络条件的主机作为目标主机发送消息。通常，所被选中的那台特定主机将返回一个单播信号，随后发送端主机会只跟这台主机进行通信。\n==任播在实际网络中的应用有DNS根域名解析服务器。==\n4.地址 MAC地址和IP地址在标识一个通信主体时虽然都具有唯一性，但是它们当中只有IP地址具有层次性。\n5.网络的构成要素 搭建一套网络环境要涉及各种各样的电缆和网络设备。在此仅介绍连接计算机与计算机的硬件设备。\n传输速率与吞吐量\n在数据传输的过程中，==两个设备之间数据流动的物理速度称为传输速率。==单位为bps（Bits Per Second，每秒比特数）。从严格意义上讲，各种传输媒介中信号的流动速度是恒定的。因此，即使数据链路的传输速率不相同，也不会出现传输的速度忽快忽慢的情况（因为光和电流的传输速度是恒定的。） 。==传输速率高也不是指单位数据流动的速度有多快，而是指单位时间内传输的数据量有多少。==\n以我们生活中的道路交通为例，低速数据链路就如同车道较少无法让很多车同时通过的情况。与之相反，高速数据链路就相当于有多个车道，一次允许更多车辆行驶的道路。==传输速率又称作带宽（Bandwidth）。带宽越大网络传输能力就越强。==\n此外，==主机之间实际的传输速率被称作吞吐量。==其单位与带宽相同，都是bps（Bits Per Second）。吞吐量这个词不仅衡量带宽，同时也衡量主机的CPU处理能力、网络的拥堵程度、报文中数据字段的占有份额（不含报文首部，只计算数据字段本身）等信息。\n网卡\n任何一台计算机连接网络时，必须要使用==网卡（全称为网络接口卡，Network Interface Card，简称NIC）==。网络接口卡（NIC（集成了连接局域网功能的设备。有时会被集成到计算机的主板中，有时也可以单独插入扩展槽使用。Network Information Center的缩写也是NIC，所以要注意区分。） ）==有时也被叫做网络适配器、网卡、LAN卡==。\n中继器\n中继器（Repeater）是在OSI模型的第1层——物理层面上延长网络的设备。由电缆传过来的电信号或光信号经由中继器的波形调整和放大再传给另一个电缆。\n有些中继器可以提供多个端口服务。这种中继器被称作==中继集线器或集线器==。因此，集线器（中继集线器也可以简称为集线器或Hub） 也可以看作是多口中继器，每个端口都可以成为一个中继器。\n网桥/2层交换机\n网桥是在OSI模型的第2层——数据链路层面上连接两个网络的设备。它能够识别数据链路层中的==数据帧==（与分组数据意思大致相同，但是在数据链路层中通常习惯称为帧） ，并将这些数据帧临时存储于内存，再重新生成信号作为一个全新的帧转发给相连的另一个网段。\n这类功能是==OSI参考模型的第2层（数据链路层）所具有的功能==。为此，有时也把==网桥称作2层交换机==（L2交换机）。\n以太网等网络中经常使用的==交换集线器==（Hub（==具有网桥功能的Hub叫做交换集线器==。只有中继器功能的Hub叫做集线器。）），==现在基本也属于网桥的一种==。交换集线器中连接电缆的每个端口都能提供类似网桥的功能。\n路由器/3层交换机\n==路由器是在OSI模型的第3层——网络层面上连接两个网络、并对分组报文进行转发的设备==。网桥是根据物理地址（MAC地址）进行处理，而路由器/3层交换机则是根据IP地址进行处理的。由此，TCP/IP中网络层的地址就成为了IP地址。\n4～7层交换机\n4～7层交换机负责处理==OSI模型中从传输层至应用层的数据==。如果用TCP/IP分层模型来表述，==4～7层交换机就是以TCP等协议的传输层及其上面的应用层为基础，分析收发数据，并对其进行特定的处理。==\n==应用场景==：\n==负载均衡器==（对于并发访问量非常大的一个企业级Web站点使用一台服务器不足以满足前端的访问需求） ==带宽控制==（实际通信当中，在网络比较拥堵的时候，优先处理像语音这类对及时性要求较高的通信请求，放缓处理像邮件或数据转发等稍有延迟也并无大碍的通信请求） ==广域网加速器、特殊应用访问加速以及防火墙== 网关\n==网关是OSI参考模型中负责将从传输层到应用层的数据进行转换和转发的设备。==它与4～7层交换机一样都是处理传输层及以上的数据，但是网关不仅转发数据还负责对数据进行转换，它通常会使用一个表示层或应用层网关，在两个不能进行直接通信的协议之间进行翻译，最终实现两者之间的通信。\n一个非常典型的例子就是互联网邮件与手机邮件之间的转换服务。\n手机邮件有时可能会与互联网邮件互不兼容，这是由于它们在表示层和应用层中的“电子邮件协议”互不相同所导致的。那么，为什么连到互联网的电脑与手机之间能够互发电子邮件呢？如图1.47所示，互联网与手机之间设置了一道网关。网关负责读取完各种不同的协议后，==对它们逐一进行合理的转换，再将相应的数据转发出去。==这样一来即使应用的是不同电子邮件的协议，计算机与手机之间也能互相发送邮件。\n此外，在使用WWW（World Wide Web，万维网）时，为了控制网络流量以及出于安全的考虑，有时会使用代理服务器（Proxy Server）。这种代理服务器也是网关的一种，称为==应用网关==。有了代理服务器，客户端与服务器之间无需在网络层上直接通信，而是从传输层到应用层对数据和访问进行各种控制和处理。防火墙就是一款通过网关通信，针对不同应用提高安全性的产品。\n各种设备及其对应网络分层概览\n6.现代网络实态 每座大型城市的道路交通网中，或多或少都分布着高速公路。在计算机网络中有类似高速公路的部分，人们称为==“骨干”或“核心”==。正如其名，它们是计算机网络的中心。人们通常会选用高速路由器相互连接使之==快速传输大量数据==。\n网络中相应于高速公路==出入口==的部分被称作==“边缘网络”== 。常用的设备有多功能路由器（在路由器最基本的功能之上增加了按顺序/种类发送数据的功能，可以根据TCP/IP层的协议变换处理方法。） 和3层交换机。\n高速公路的出入口通常连接国道、省道，从而可以通往市区街道。==计算机网络中连接“边缘网络”的部分叫做“接入层”或“汇聚层”==。这样，==骨干网可以专注于如何提高业务传输性能和网络的生存性，而将具有业务智能化的高速路由器和交换机移到网络的边缘==。边缘网络的常用设备多为2层交换机或3层交换机。\n虚拟化和云\n抽奖、网游等网站，这些网站有一个共同的特点，那就是==具有明显的访问高峰点==。以提供抽奖的站点为例，在抽奖活动期间，白天或周末访问量都非常高，而在抽奖活动结束后基本无人问津。而且，在访问高峰期，网站又必须保证每一个用户都能正常访问，否则极可能会被起诉发生索赔事件。\n基于这样一个背景，出现了==虚拟化技术==。它是指当一个网站（也可以是其他系统）需要调整运营所使用的资源时，==并不增减服务器、存储设备、网络等实际的物理设备，而是利用软件将这些物理设备虚拟化==，在有必要增减资源的时候，通过软件按量增减的一种机制。通过此机制实现按需分配、按比例分配，对外提供可靠的服务。\n==利用虚拟化技术，根据使用者的情况动态调整必要资源的机制被人们称作“云”==。而且，将虚拟化的系统根据需要自动地进行动态管理的部分被称作==“智能协调层”==。它能够将服务器、存储、网络看作一个整体进行管理。有了“云”，网络的使用者就可以实现不论何时何地都可以只获取或只提供需要信息的机制。\n第2章 TCP/IP基础知识 TCP（Transmission Control Protocol）和IP（Internet Protocol）是互联网的众多通信协议中最为著名的。\n1.TCP/IP的标准化 20世纪90年代，ISO开展了OSI这一国际标准协议的标准化进程。 然而，OSI协议并没有得到普及，真正被广泛使用的是TCP/IP协议。\n究其原因，是由TCP/IP的标准化所致。==TCP/IP的标准化中有其他协议的标准化没有的要求==。这一点就是让TCP/IP更迅速地实现和普及的原动力。\nTCP/IP的具体含义 从字面意义上讲，有人可能会认为TCP/IP是指TCP与IP两种协议。实际生活当中有时也确实就是指这两种协议。然而在很多情况下，它只是==利用IP进行通信时所必须用到的协议群的统称==。具体来说，IP或ICMP、TCP或UDP、TELNET或FTP、以及HTTP等都属于TCP/IP的协议。它们与TCP或IP的关系紧密，是互联网必不可少的组成部分。==TCP/IP一词泛指这些协议==，因此，有时也称TCP/IP为网际协议族（网际协议族（Internet Protocol Suite）：组成网际协议的一组协议。）\nTCP/IP规范**——RFC** 前面提到TCP/IP的协议由IETF讨论制定。那些需要标准化的协议，被人们列入==RFC（Request For Comment）==（RFC从字面意义上看就是指征求意见表，属于一种征求协议相关意见的文档） 文档并在互联网上公布。RFC不仅记录了协议规范内容，还包含了协议的实现和运用的相关信息（==协议实现或运用相关的信息叫做FYI（For Your Information）==） ，以及实验方面的信息（==实验阶段的协议称作Experimental==） 。\nRFC文档通过编号组织每个协议的标准化请求。例如IP协议的规范由RFC279制定，TCP协议的规范由RFC793号文档决定。RFC的编码是既定的，一旦成为某一RFC的内容，就不能再对其进行随意修改。若要扩展已有某个协议规范的内容，一定要有一个全新编号的RFC文档对其进行记录。若要修改已有某个协议规范内容，则需要重新发行一个新的 RFC文档，同时，老的那份RFC作废。新的RFC文档会明确规定是扩展了哪个已有的RFC以及要作废哪个已有RFC。\n此时，有人提出每当对RFC进行修改时都要产生新的RFC编号太麻烦。为此，人们采用==STD（Standard）==（例如STD5表示包含ICMP的IP协议标准。因此，STD5由RFC791、RFC919、RFC922、RFC792、RFC950以及RFC1112 6个RFC组成） 方式管理编号。STD用来记载哪个编号制定哪个协议。因此，==同一个协议的规范内容即便发生了变化也不会导致STD编号发生变化==。\n今后，即使协议规范的内容改变也不会改变STD编号，但是有可能导致某个STD下的RFC编号视情况有所增减。\n此外，为了向互联网用户和管理者提供更有益的信息，与STD类似，FYI（For Your Information）也开始标注编号组织。FYI为了人们方便检索，也在其每个编号里涵盖了所涉及的RFC编号。即使更新内容，编号也不会发生变化。\nSTD1记录着所有要求协议标准化的RFC状态。到2012年1月为止，STD1相当于RFC5000（很多情况下会采用比较容易记忆的编号）。\n每个RFC的最新信息请参考http://www.rfc-editor.org/rfc/rfc××××.txt（其中××××为RFC编号）。\nSTD获取网址：http://www.rfc-editor.org/in-notes/std/\nFYI获取网址：http://www.rfc-editor.org/in-notes/fyi/ ID（I-D：Internet Draft）获取网址：http://www.rfc-editor.org/internet-drafts/\n2.互联网基础知识 互联网定义 “互联网”，英文单词为“Internet”。从字面上理解，internet指的是将多个网络连接使其构成一个更大的网络，所以internet一词本意为==网际网==。将两个以太网网段用路由器相连是互联网，将企业内部各部门的网络或公司的内网与其他企业相连接，并实现相互通信的网络也是互联网，甚至一个区域的网络与另一个区域的网络相互连接形成全世界规模 的网络也可以称作互联网。然而，现在“互联网”这个词的意思却有所变化。==当专门指代网络之间的连接时，可以使用“网际网”这个词==。\n==“互联网”是指由ARPANET（Advanced Research Projects Agency Network，阿帕网 ，也是全球互联网的鼻祖==发展而来、互连全世界的计算机网络。==现在，“互联网”已经是一个专有名词了，其对应的英文单词==“The Internet”==也早已成为固有名词（Internet指网际网，The Internet指互联网，首字母大写）（与Internet对应的另一种网络叫做Intranet。该网络是指使用Internet技术将企业内部的组织机构连接起来形成一个企业范围内的封闭网络，提供面向企业内部的通信服务） 。\n互联网与TCP/IP的关系 互联网进行通信时，需要相应的网络协议，TCP/IP原本就是为使用互联网而开发制定的协议族。因此，==互联网的协议就是TCP/IP，TCP/IP就是互联网的协议==。\n互联网的结构 互联网中的每个网络都是由==骨干网==（BackBone）和末端网（Stub）组成的。每个网络之间通过==NOC（Network Operation Center，网络操作中心）== 相连。如果网络的运营商不同，它的网络连接方式和使用方法也会不同。连接这种异构网络需要有==IX（Internet Exchange，网络交换中心）== 的支持。总之，互联网就是众多异构的网络通过IX互连的一个巨型网络。\n3.TCP/IP协议分层模型 TCP/IP与OSI参考模型 图2.8列出了TCP/IP与OSI分层之间的大致关系。不难看出，TCP/IP与OSI在分层模块上稍有区别。==OSI参考模型注重“通信协议必要的功能是什么”，而TCP/IP则更强调“在计算机上实现协议应该开发哪种程序”==。\n硬件（物理层） TCP/IP的最底层是负责数据传输的硬件。这种硬件就相当于以太网或电话线路等物理层的设备。\n网络接口层（数据链路层） 网络接口层（有时人们也将网络接口层与硬件层合并起来称作网络通信层。） 利用以太网中的数据链路层进行通信，因此属于接口层。 也就是说，把它当做让NIC起作用的“驱动程序”也无妨。驱动程序是在操作系统与硬件之间起桥梁作用的软件。\n互联网层（网络层） 互联网层使用IP协议，它相当于OSI模型中的第3层网络层。IP协议基于IP地址转发分包数据。\n==TCP/IP分层中的互联网层与传输层的功能通常由操作系统提供。尤其是路由器，它必须得实现通过互联网层转发分组数据包的功能==。\n此外，连接互联网的所有主机跟路由器必须都实现IP的功能。其他连接互联网的网络设备（如网桥、中继器或集线器）就没必要一定实现IP或TCP的功能（有时为了监控和管理网桥、中继器、集线器等设备，也需要让它们具备IP、TCP的功能。） 。\nIP\nIP是跨越网络传送数据包，使整个互联网都能收到数据的协议。IP协议使数据能够发送到地球的另一端，这期间它使用IP地址作为主机的标识。\nIP还隐含着数据链路层的功能。通过IP，相互通信的主机之间不论经过怎样的底层数据链路都能够实现通信。\n虽然IP也是分组交换的一种协议，但是它==不具有重发机制。即使分组数据包未能到达对端主机也不会重发。因此，属于非可靠性传输协议。==\nICMP（Internet Control Message Protocol）\nIP数据包在发送途中一旦发生异常导致无法到达对端目标地址时，需要给发送端发送一个发生异常的通知。ICMP就是为这一功能而制定的。它有时也被用来==诊断网络的健康状况==。\nARP\n从分组数据包的==IP地址中解析出物理地址（MAC地址）==的一种协议。\n传输层 TCP/IP的传输层有两个具有代表性的协议。该层的功能本身与OSI参考模型中的传输层类似。\n传输层最主要的功能就是能够让应用程序之间实现通信。计算机内部，通常同一时间运行着多个程序。为此，必须分清是哪些程序与哪些程序在进行通信。识别这些应用程序的是端口号。\nTCP\nTCP是一种面向有连接的传输层协议。它可以==保证两端通信主机之间的通信可达。TCP能够正确处理在传输过程中丢包、传输顺序乱掉等异常情况==。此外，TCP还能够有效利用带宽，缓解网络拥堵。\n然而，为了建立与断开连接，有时它需要至少7次的发包收包，导致网络流量的浪费。此外，为了提高网络的利用率，TCP协议中定义了各种各样复杂的规范，因此==不利于视频会议（音频、视频的数据量既定）等场合使用==。\nUDP\nUDP有别于TCP，它是一种面向==无连接的==传输层协议。==UDP不会关注对端是否真的收到了传送过去的数据==，如果需要检查对端是否收到分组数据包，或者对端是否连接到网络，则需要在应用程序中实现。\nUDP常用于==分组数据较少或多播、广播通信以及视频通信等多媒体领域==。\n应用层（会话层以上的分层） TCP/IP的分层中，将OSI参考模型中的==会话层、表示层和应用层的功能都集中到了应用程序中实现==。这些功能有时由一个单一的程序实现，有时也可能会由多个程序实现。因此，细看TCP/IP的应用程序功能会发现，它不仅实现OSI模型中应用层的内容，还要实现会话层与表示层的功能。\nWWW\nWWW（中文叫万维网，是一种互联网上数据读取的规范。有时也叫做Web、WWW或W3。） 可以说是互联网能够如此普及的一个重要原动力。\n浏览器与服务端之间通信所用的协议是HTTP（HyperText Transfer Protocol）。所传输数据的主要格式是HTML（HyperText Markup Language）。==WWW中的HTTP属于OSI应用层的协议，而HTML属于表示层的协议==。\n电子邮件（E-Mail）\n发送电子邮件时用到的协议叫做==SMTP（Simple Mail Tranfer Protocol）==。\n电子邮件的格式由==MIME==（在互联网上广泛使用的、用来定义邮件数据格式一种规范） ==协议==扩展以后，就可以发送声音、图像等各式各样的信息。甚至还可以修改邮件文字的大小、颜色（有时某些机能可能会因为邮件接收端软件的限制不能充分展现） 。这里提到的==MIME属于OSI参考模型的第6层——表示层==。\n文件传输（FTP）\n文件传输是指将保存在其他计算机硬盘上的文件转移到本地的硬盘上，或将本地硬盘的文件传送到其他机器硬盘上的意思。\n该过程使用的协议叫做==FTP（File Transfer Prototol）==。FTP很早就已经投入使用（最近在文件传输中使用WWW的HTTP的情况也在增加。） ， 传输过程中可以选择用二进制方式还是文本方式（用文本方式在Windows、MacOS或Unix等系统之间进行文件传输时，会自动修改换行符。这也属于表示层的功能） 。\n在FTP中进行文件传输时会建立两个TCP连接，分别是发出==传输请求时所要用到的控制连接与实际传输数据时所要用到的数据连接====（这两种连接的控制管理属于会话层的功能）== 。\n远程登录（TELNET与SSH）\n远程登录是指登录到远程的计算机上，使那台计算机上的程序得以运行的一种功能。TCP/IP网络中远程登录常用 TELNET（TELetypewriter NETwork的缩写。有时也称作默认协议） 和SSH（SSH是Secure SHell的缩写） 两种协议。其实还有很多其他可以实现远程登录的协议，如BSD UNIX系中rlogin的r命令协议以及X Window System中的X协议。\n网络管理（SNMP）\n在TCP/IP中进行网络管理时，采用==SNMP（Simple Network Management Protocol）协议==。使用SNMP管理的主机、网桥、路由器等称作==SNMP代理（Agent）==，而进行管理的那一段叫做==管理器（Manager）==。SNMP正是这个Manager与Agent所要用到的协议。\n在SNMP的代理端，保存着网络接口的信息、通信数据量、异常数据量以及设备温度等信息。这些信息可以通过MIB（Management Information Base）（MIB也被称为是一种可透过网络的结构变量） 访问。因此，在TCP/IP的网络管理中，==SNMP属于应用协议，MIB属于表示层协议==。\n一个网络范围越大，结构越复杂，就越需要对其进行有效的管理。而SNMP可以让管理员及时检查网络拥堵情况，及早发现故障，也可以为以后扩大网络收集必要的信息。\n4.TCP/IP分层模型与通信示例 TCP/IP是如何在媒介上进行传输的呢？本节将介绍使用TCP/IP时， 从应用层到物理媒介为止数据处理的流程。\n数据包首部 在下一 层的角度看，从上一分层收到的包全部都被认为是本层的数据。\n包、帧、数据包、段、消息\n以上五个述语都用来表述数据的单位，大致区分如下：\n包可以说是全能性述语。帧用于表示数据链路层中包的单位。而数据包是IP和UDP等网络层以上的分层中包的单位。段则表示TCP数据流中的信息。最后，消息是指应用协议中数据的单位。\n发送数据包 假设甲给乙发送电子邮件，内容为：“早上好”。而从TCP/IP通信上看，是从一台计算机A向另一台计算机B发送电子邮件。我们就通过这个例子来讲解一下TCP/IP通信的过程。\n① 应用程序处理\n② TCP模块的处理\n③ IP模块的处理\n④ 网络接口（以太网驱动）的处理\n经过数据链路的包 分组数据包（以下简称包）经过以太网的数据链路时的大致流程如图2.19所示。不过请注意，该图对各个包首部做了简化。\n每个包首部中至少都会包含两个信息：==一个是发送端和接收端地址，另一个是上一层的协议类型==。\n数据包接收处理 包的接收流程是发送流程的逆序过程。\n⑤ 网络接口（以太网驱动）的处理\n⑥ IP模块的处理\n⑦ TCP模块的处理\n⑧ 应用程序的处理\n第3章 数据链路 1.数据链路的作用 数据链路，指OSI参考模型中的数据链路层，有时也指以太网、无线局域网等通信手段。\nOSI参考模型中数据链路层的相关技术，包括MAC寻址（物理寻址）、介质共享、非公有网络、分组交换、环路检测、VLAN（Virtual Local Area Network，虚拟局域网）等。\n作为传输方式的数据链路：如以太网、WLAN（Wireless Local Area Network，无限局域网）、PPP（Point to Point Protocol，点对点协议）。\n数据链路也可以被视为网络传输中的最小单位。\n2.数据链路相关技术 MAC地址 MAC地址用于识别数据链路中互连的节点（如图3.4）。\nMAC地址长48比特，结构如图3.5所示。在使用网卡（NIC）的情况下，MAC地址一般会被烧入到ROM中。因此，任何一个网卡的MAC地址都是唯一的，在全世界都不会有重复（也有例外）\n共享介质型网络 从通信介质（通信，介质）的使用方法上看，网络可分为==共享介质型==和==非共享介质型==。\n==共享介质型网络指由多个设备共享一个通信介质的一种网络==。最早的以太网和FDDI就是介质共享型网络。在这种方式下，设备之间使用同一个载波信道进行发送和接收。为此，基本上==采用半双工通信方式==，并有必要对介质进行访问控制。\n共享介质型网络中有两种介质访问控制方式：一种是==争用方式==，另 一种是==令牌传递==方式。\n争用方式（Contention）是指==争夺获取数据传输的权力==，也叫 CSMA（载波监听多路访问）。这种方法通常令网络中的各个站（数据链路中很多情况下称节点为“站”。） 采用先到先得的方式占用信道 发送数据，如果多个站同时发送帧，则会产生冲突现象。也因此会导致网络拥堵与性能下降。\n在一部分以太网当中，采用了改良CSMA的另一种方式—— ==CSMA/CD==（Carrier Sense Multiple Access with Collision Detection） 方式。CSMA/CD要求每个站提前检查冲突，==一旦发生冲突，则尽早释放信道==。\n令牌传递方式是沿着令牌环发送一种叫做“令牌”的特殊报文，是控制传输的一种方式。==只有获得令牌的站才能发送数据==。这种方式有两个特点：一是不会有冲突，二是每个站都有通过平等循环获得令牌的机会。因此，即使网络拥堵也不会导致性能下降。\n非共享介质网络 非共享介质网络是指==不共享介质==，是对介质采取专用的一种传输控制方式。在这种方式下，网络中的每个站直连交换机，由交换机负责转发数据帧。此方式下，发送端与接收端并不共享通信介质，因此很多情况下采用==全双工通信方式==。\n半双工与全双工通信\n==半双工是指，只发送或只接收的通信方式==。它类似于无线电收发 器，若两端同时说话，是听不见对方说的话的。而==全双工==不同，它==允许在同一时间既可以发送数据也可以接收数据==。类似于电话，接打双方可以同时说话。\n采用CSMA/CD方式的以太网，如图3.7所示，首先要判断是否可以通信，如果可以就独占通信介质发送数据。因此，它像无线电收发器一样，不能同时接收和发送数据。\n同样是以太网，在使用交换机与双绞线电缆（亦或光纤电缆）的情况下，既可以通过交换机的端口与计算机之间进行一对一的连接，也可以通过相连电缆内部的收发线路分别进行接收和发送数据。因此，交换机的端口与计算机之间可以实现同时收发的全双工通信。\n根据MAC地址转发 以太网交换机就是持有多个端口（计算机设备的外部接口都称做端口。）的网桥。它们根据数据链路层中每个帧的目标MAC地址，决定从哪个网络接口发送数据。这时所参考的、用以记录发送接口的表就叫做转发表（Forwarding Table）。\n这种转发表的内容不需要使用者在每个终端或交换机上手工设置，而是可以自动生成。数据链路层的每个通过点在接到包时，会从中将源MAC地址以及曾经接收该地址发送的数据包的接口作为对应关系记录到转发表中。以某个MAC地址作为源地址的包由某一接口接收，实质上可以理解为该MAC地址就是该接口的目标。因此也可以说，以该MAC地址作为目标地址的包，经由该接口送出即可。这一过程也叫==自学过程==。\nVLAN 进行网络管理的时候，时常会遇到分散网络负载、变换部署网络设备的位置等情况。而有时管理员在做这些操作时，不得不修改网络的拓扑结构，这也就意味着必须进行硬件线路的改造。然而，如果采用带有VLAN技术的网桥（交换机），就不用实际修改网络布线，只需修改网络的结构即可。VLAN技术附加到网桥/2层交换机上，就可以切断所有VLAN之间的所有通信。因此，相比一般的网桥/2层交换机，VLAN可以过滤多余的包，提高网络的承载效率。\n那么VLAN究竟是什么？如图3.15所示，==该交换机按照其端口区分了多个网段，从而区分了广播数据传播的范围、减少了网络负载并提高了网络的安全性。==然而异构的两个网段之间，就需要利用具有路由功能的交换机（如3层交换机），或在各段中间通过路由器的连接才能实现通信。\n3.以太网 它的规范简单，易于NIC（网卡）及驱动程序实现。\n以太网连接形式 在以太网普及之初，一般采用多台终端使用同一根同轴电缆的==共享介质型连接方式==。\n而现在，随着互连设备的处理能力以及传输速度的提高，一般都采用==终端与交换机之间独占电缆==的方式实现以太网通信，如图3.18。\n以太网帧格式 以太网帧前端有一个叫做前导码（Preamble）的部分，它由0、1数字交替组合而成，表示一个以太网帧的开始，也是对端网卡能够确保与其同步的标志。如图3.19所示。前导码末尾是一个叫做SFD（Start Frame Delimiter）的域，它的值是“11”。在这个域之后就是以太网帧的本体（图3.20）。前导码与SFD合起来占8个字节。\n以太网帧本体的前端是以太网的首部，它总共占14个字节。分别是6个字节的目标MAC地址、6个字节的源MAC地址以及2个字节的上层协议类型。\n数据链路层分为两层\n可以将数据链路层分为==介质访问控制层（简称MAC（Media Access Control））== 和==逻辑链路控制层（简称LLC（Logical Link Control））== 。 介质访问控制层根据以太网或FDDI等不同数据链路所==特有的首部信息==进行控制。与之相比，逻辑链路层则根据以太网或FDDI等不同数据链路所==共有的帧头信息==进行控制。\n4.无线通信 无线通信通常使用电磁波、红外线、激光等方式进行传播数据。一般在办公室的局域网范围内组成的较高速的连接称为无线局域网。\n无线通信，依据通信距离可分为如表3.3所列出的类型。IEEE802委员会制定了无线PAN（Personal Area Network） （802.15）、无线 LAN（Local Area Network）（802.11）、无线MAN（Metropolitan Area Network） （802.16）以及无线RAN（Regional Area Network）（802.22）等无线标准。无线WAN（Wide Area Network） 的最典型代表就是手机通信。手机通过基站能够实现长距离通信。\nWi-Fi\n与音响中Hi-Fi（High Fidelity：高保真、高重现）这个词类似， ==Wi-Fi（Wireless Fidelity）==指高质量的无线LAN。\n5.PPP PPP（Point-to-Point Protocol）是指点对点，即1对1连接计算机的协议。PPP相当于位于OSI参考模型第2层的数据链路层。\nPPP不像以太网和FDDI。后两者不仅与OSI参考模型的数据链路层有关，还与第1层的物理层有关。具体来讲，以太网使用同轴电缆或双 绞线电缆，它可以决定其中的0、1该被解释为何种电子信号。与之相比，==PPP属于纯粹的数据链路层，与物理层没有任何关系。==换句话说，仅有PPP无法实现通信，还需要有物理层的支持。\nPPP可以使用电话线或ISDN、专线、ATM线路。此外，近些年人们更多是在用ADSL或有线电视==通过PPPoE（PPP over Ethernet）实现互联网接入==。PPPoE是在以太网的数据中加入PPP帧进行传输的一种方式。\n有些互联网接入服务商在以太网上利用==PPPoE（PPP over Ethernet）== 提供PPP功能。\n单纯的以太网没有验证功能，也没有建立和断开连接的处理，因此无法按时计费。而如果采用PPPoE管理以太网连接，就可以利用PPP的验证等功能使各家ISP可以有效地管理终端用户的使用。\n6.其他数据链路 ATM\nATM（Asynchronous Transfer Mode）是以一个叫做信元（5字节首部加48字节数据）的单位进行传输的数据链路，由于其线路占用时间短和能够高效传输大容量数据等特点主要用于广域网络的连接。\nPOS\nPOS（Packet over SDH/SONET）是一种在SDH（Synchronous Digital Hierarchy，同步数字体系） （SONET（Synchronous Optical NETwork，同步光纤网络） ）上进行包通信的一种协议。 SDH（SONET）是在光纤上传输数字信号的物理层规范。\nFDDI\nFDDI（Fiber Distributed Data Interface）叫做光纤分布式数据接口。 曾几何时，人们为了用光纤和双绞线实现100Mbps的传输速率，在主干网或计算机之间的高速连接上广泛使用了FDDI。但是由于后来高速LAN提供了Gbps级的传输速率，FDDI也就逐渐淡出了应用领域。\nToken Ring\n令牌环网（Token Ring）源自IBM开发的令牌环LAN技术，可以实现4Mbps或16Mbps传输速率。前面提到的FDDI实际上是扩展了Token Ring的一个产物。\n100VG-AnyLAN\n100VG-AnyLAN是IEEE802.12规范定义的一种网络协议。它以语音级的3类UTP电缆实现100Mbps的传输速率。它的数据帧格式既能应对以太网又能应对令牌环网。鉴于100Mbps以太网（100BASE-TX）的普及，100VG-AnyLAN也几乎不再被使用。\n光纤通道\n光纤通道（Fiber Channel）是实现高速数据通信的一种数据链路。 与其说它是一种网络，不如说它更像是SCSI那样类似于连接计算机周边设备的总线一样的规范。数据传输速率为133Mbpx～4Gbps。近些年被广泛用于搭建SAN（Storage Area Network，存储域网络。服务器与多台存储设备（硬盘、磁带备份）之间高速传输数据的网络系统。一般在企业当中用于保存超大容量数据） ，成为其主要数据链路。\nHIPPI\nHIPPI用于连接超大型计算机传输速率为800Mbps或1.6Gbps。铜缆的实际传输距离在25米以内，但是如果使用光纤作为传输介质时，可以延长到数公里。\nIEEE1394\n也叫FireWire或i.Link，是面向家庭的局域网，主要用于连接AV等计算机外围设备。数据传输速率为100～800Mbps以上。\nHDMI\nHDMI是High-Definition Multimedia Interface的缩写，意为高清晰度多媒体接口。它可以通过一根缆线实现图像和声音等数字信号的高品质传输。曾主要用于DVD/蓝光播放器、录像机、AV功放等设备与电视机、投影仪的连接，现在也逐渐开始用于计算机或平板电脑、数码相机与显示器的连接。\niSCSI\n它是将个人电脑连接硬盘的SCSI标准应用于TCP/IP网络上的一种标准（RFC3720、RFC3783） 。它把SCSI的命令和数据包含进IP包内，进行数据传输。由此，人们就可以像使用个人电脑内嵌的SCSI硬盘一样使用网络上直连的大规模硬盘了。\nInfiniBand\nInfiniBand是针对高端服务器的一种超高速传输接口技术。它最大的特点是高速、高可靠性以及低延迟。它支持多并发链接，将多个线缆（如4链接或12链接。）合并为一个线缆。可以实现从2Gbps至数百Gbps的传输速率。以后甚至还计划提供数千Gbps的高速传输速率。\nDOCSIS\nDOCSIS是有线电视（CATV）传输数据的行业标准，由MCNS（Multidedia Cable Network System Patners Limited） 制定。该标准定义了有线电视的同轴电缆与Cable Modem（电缆调制解调器）的连接及其与以太网进行转换的具体规范。此外，有一个叫做CableLabs（有线电视业界的研究开发机构）的组织对Cable Modem进行认证。\n高速PLC\n高速PLC（Power line Communication，高速电力线通信。） 是指在家里或办公室内利用电力线上数MHz～数十MHz频带范围，实现数十Mbps～200Mbps传输速率的一种通信方式。使用电力线不用重新布线，也能进行日常生活以及家电设备或办公设备的控制。然而，本不是为通信目的而设计的电力线在传输高频信号时，极容易收到电波干扰，一般仅限于室内（家里、办公室内）使用。\n7.公共网络 所谓的公共通信服务类似于电信运营商（如NTT、KDDI或软银等）提供的电话网络。人们通过与这些运营商签约、付费不仅可以实现联网还可以与距离遥远的机构组织进行通信。\n主要包括==模拟电话线路、移动通信、ADSL、FTTH、有线电视、专线、VPN以及公共无线LAN==等。\n第4章 IP协议 IP（Internet Protocol，网际协议）作为整个TCP/IP中至关重要的协议，主要负责==将数据包发送给最终的目标计算机==。因此，IP能够让世界上任何两台计算机之间进行通信。\n1.IP即网际协议 TCP/IP的心脏是互联网层。这一层主要由==IP（Internet Protocol）==和 ==ICMP（Internet Control Message Protocol）==两个协议组成。\n==IP（IPv4、IPv6）相当于OSI参考模型中的第3层——网络层==。 网络层的主要作用是“实现终端节点之间的通信”。这种终端节点之间的通信也叫“点对点（end-to-end）通信”。 从前面的章节可知，网络层的下一层——数据链路层的主要作用是在互连同一种数据链路的节点之间进行包传递。而一旦跨越多种数据链路，就需要借助网络层。==网络层可以跨越不同的数据链路==，即使是在不同的数据链路上也能实现两端节点之间的数据包传输。\n网络层与数据链路层的关系 数据链路层提供==直连两个设备之间==的通信功能。与之相比，作为网络层的IP则负责在==没有直连的两个网络之间==进行通信传输。那么为什么一定需要这样的两个层次呢？它们之间的区别又是什么呢？\n计算机网络中也需要数据链路层和网络层这个分层才能实现向最终目标地址的通信。\n2.IP基础知识 IP大致分为三大作用模块，它们是==IP寻址、路由（最终节点为止的转发）以及IP分包与组包==。\n主机与节点\n在互联网世界中，将那些配有IP地址的设备叫做“主机”。可以是超大型计算机，也可以是小型计算机。这是因为互联网在当初刚发明的时候，只能连接这类大型的设备，因此习惯上就将配有IP地址的设备称为“主机”。然而，准确地说，==主机的定义应该是指“配置有IP地址，但是不进行路由控制==（路由控制英文叫做Routing，是指中转分组数据包） 的设备”。==既配有IP地址又具有路由控制能力的设备叫做“路由器”==，跟主机有所区别。而==节点则是主机和路由器的统称==（这些都是IPv6的规范RFC2460中所使用的名词术语。在IPv4的规范RFC791中，将具有路由控制功能的设备叫做“网关”，然而现在都普遍叫做路由器（或3层交换机）） 。\n==路由控制（Routing）==是指将分组数据发送到最终目标地址的功能。即使网络非常复杂，也可以通过路由控制确定到达目标地址的通路。\n路由控制表\n为了将数据包发给目标主机，所有主机都维护着一张路由控制表（Routing Table）。该表记录IP数据在下一步应该发给哪个路由器。IP包将根据这个路由表在各个数据链路上传输。\n数据链路的抽象化\nIP是实现多个数据链路之间通信的协议。数据链路根据种类的不同各有特点。对这些不同数据链路的相异特性进行抽象化也是IP的重要作用之一。\n==IP分片处理（IP Fragmentation）==。顾名思义，所谓分片处理是指，将较大的IP包分成多个较小的IP包 。分片的包到了对端目标地址以后会再被组合起来传给上一层。即从IP的上次层看，它完全可以忽略数据包在途中的各个数据链路上的MTU，而只需要按照源地址发送的长度接收数据包。IP就是以这种方式抽象化了数据链路层，使得从上层更不容易看到底层网络构造的细节。\nIP属于面向无连接型\n==IP面向无连接。即在发包之前，不需要建立与对端目标地址之间的连接。==上层如果遇到需要发送给IP的数据，该数据会立即被压缩成IP包发送出去。\n为什么IP要采用面向无连接呢？\n主要有两点原因：一是为了简化，二是为了提速。面向连接比起面向无连接处理相对复杂。甚至管理每个连接本身就是一个相当繁琐的事情。此外，每次通信之前都要事先建立连接，又会降低处理速度。需要有连接时，可以委托上一层提供此项服务。因此，IP为了实现简单化与高速化采用面向无连接的方式。\n为了提高可靠性，==上一层的TCP采用面向有连接型==。\n3.IP地址的基础知识 IP地址的定义\nIP地址（IPv4地址）由==32位正整数==来表示。TCP/IP通信要求将这样的IP地址分配给每一个参与通信的主机。IP地址在计算机内部以二进制（二进制是指用0、1表示数字的方法。） 方式被处理。然而，由于人类社会并不习惯于采用二进制方式，需要采用一种特殊的标记方式。==那就是将32位的IP地址以每8位为一组，分成4组，每组以“.”隔开，再将每组数转换为十进制数==（这种方法也叫做“十进制点符号”（Dot- decimal notation）） 。\nIP地址由网络和主机两部分标识组成\nIP地址由==“网络标识（网络地址）”和“主机标识（主机地址）”==两部分组成（192.168.128.10/24中的“/24”表示从第1位开始到多少位属于网络标识。在这个例子中，192.168.128之前的都是该IP的网络地址）。\n网络标识在数据链路的每个段配置不同的值。网络标识必须保证==相互连接的每个段的地址不相重复==。而==相同段内相连的主机必须有相同的网络地址==。IP地址的==“主机标识”则不允许在同一个网段内重复出现==。\n究竟从第几位开始到第几位算是网络标识，又从第几位开始到第几位算是主机标识呢？关于这点，有约定俗成的两种类型。最初二者以==分类进行区别==。而现在基本以==子网掩码（网络前缀）==区分。不过，请读者注意，在有些情况下依据部分功能、系统和协议的需求，前一种的方法依然存在。\nIP地址的分类 IP地址分为四个级别，分别为A类、B类、C类、D类（还有一个一直未使用的E类。） 。它根据IP地址中从第1位到第4位的比特列对其网络标识和主机标识进行区分。\n■ A类地址\nA类IP地址是首位以“0”开头的地址。从第1位到第8位（去掉分类位剩下7位） 是它的网络标识。用十进制表示的话，0.0.0.0～127.0.0.0是A类的网络地址。A类地址的后24位相当于主机标识。因此，一个网段内可容纳的主机地址上限为16，777，214个 。\n■ B类地址\nB类IP地址是前两位为“10”的地址。从第1位到第16位（去掉分类位剩下14位）是它的网络标识。用十进制表示的话，128.0.0.1～ 191.255.0.0是B类的网络地址。B类地址的后16位相当于主机标识。因此，一个网段内可容纳的主机地址上限为65，534个。\n■ C类地址\nC类IP地址是前三位为“110”的地址。从第1位到第24位（去掉分类位剩下21位）是它的网络标识。用十进制表示的话，192.168.0.0～ 239.255.255.0是C类的网络地址。C类地址的后8位相当于主机标识。因此，一个网段内可容纳的主机地址上限为254个 。\n■ D类地址\nD类IP地址是前四位为“1110”的地址。从第1位到第32位（去掉分类位剩下28位） 是它的网络标识。用十进制表示的话，224.0.0.0～239.255.255.255是D类的网络地址。D类地址没有主机标识，常被用于多播。\n■ 关于分配IP主机地址的注意事项\n在分配IP地址时关于主机标识有一点需要注意。即要用比特位表示主机地址时，不可以全部为0或全部为1。因为全部为只有0在表示对应的网络地址或IP地址不可获知的情况下才使用。而全部为1的主机地址通常作为广播地址。 因此，在分配过程中，应该去掉这两种情况。这也是为什么C类地址每个网段最多只能有254（28 -2=254）个主机地址的原因。\n广播地址\n广播地址用于在同一个链路中相互连接的主机之间发送数据包。将IP地址中的主机地址部分全部设置为1，就成为了广播地址（以太网中如果将MAC地址的所有位都改为1，则形成FF：FF：FF：FF：FF：FF的广播地址。因此，广播的IP包以数据链路的帧的形式发送时，得通过MAC地址为全1比特的FF：FF：FF：FF：FF：FF转发。）\n广播分为==本地广播==和==直接广播==两种。\n在本网络内的广播叫做本地广播。例如网络地址为192.168.0.0/24的情况下，广播地址是192.168.0.255。因为这个广播地址的IP包会被路由器屏蔽，所以不会到达192.168.0.0/24以外的其他链路上。\n在不同网络之间的广播叫做直接广播。例如网络地址为192.168.0.0/24的主机向192.168.1.255/24的目标地址发送IP包。收到这个包的路由器，将数据转发给192.168.1.0/24，从而使得所有192.168.1.1～ 192.168.1.254的主机都能收到这个包（由于直接广播有一定的安全问题，多数情况下会在路由器上设置为不转发） 。\nIP多播\n■同时发送提高效率\n==多播用于将包发送给特定组内的所有主机==。由于其直接使用IP协议，因此也不存在可靠传输。\n多播这种既可以穿透路由器，又可以实现只给那些必要的组发送数据包的技术就成为必选之路了。\n■ IP多播与地址\n多播使用D类地址。因此，如果从首位开始到第4位是“1110”，就可以认为是多播地址。而剩下的28位可以成为多播的组编号。 从224.0.0.0到239.255.255.255都是多播地址的可用范围。\n子网掩码 自从引入了子网以后，一个IP地址就有了两种识别码。==一是IP地址本身，另一个是表示网络部的子网掩码。==子网掩码用二进制方式表示的话，也是一个32位的数字。它对应IP地址网络标识部分的位全部为“1”，对应IP地址主机标识的部分则全部为“0”。由此，一个IP地址可以不再受限于自己的类别，而是可以用这样的子网掩码自由地定位自己的网络标识长度。当然，子网掩码必须是IP地址的首位开始连续的“1”。\n对于子网掩码，目前有两种表示方式。以172.20.100.52的前26位是网络地址的情况为例，以下是其中一种表示方法，它将IP地址与子网掩码的地址分别用两行来表示。\n另一种表示方式如下所示。它在每个IP地址后面追加网络地址的位数（这种方式也叫“后缀”表示法。） 用“/”隔开。\n不难看出，在第二种方式下记述网络地址时可以省略后面的“0”。例如172.20.0.0/16跟172.20/16其实是一个意思。\nCIDR与VLSM 采用任意长度分割IP地址的网络标识和主机标识。这种方式叫做==CIDR==，意为“无类别域间路由”。 由于BGP（Border Gateway Protocol，边界网关协议）对应了CIDR，所以不受IP地址分类的限制自由分配（Classless Inter-Domain Routing） 。\n在CIDR被应用到互联网的初期，网络内部采用固定长度的子网掩码机制。也就是说，当子网掩码的长度被设置为/25以后，域内所有的子网掩码都得使用同样的长度。然而，有些部门可能有500台主机，另一些部门可能只有50台主机。如果全部采用统一标准，就难以架构一个高效的网络结构。为此人们提出组织内要使用可变长度的、高效的IP地 址分配方式。\n于是产生了一种可以随机修改组织内各个部门的子网掩码长度的机制——==VLSM（可变长子网掩码）（Variable Length Subnet Mask）== 。它可以通过域间路由协议转换为RIP2（7.4.5节）以及OSPF（7.5节） 实现。根据VLSM可以将网络地址划分为主机数为500个时子网掩码长度为/23，主机数为50个时子网掩码长度为/26。从而在理论上可以将IP地址的利用率提高至50％。\n有了CIDR和VLSM技术，确实相对缓解了全局IP地址（为了对应全局IP地址不足的问题，除了CIDR和VLSM之外还有NAT（5.6节）、代理服务器（1.9.7节）等技术） 不够用的问题。==但是IP地址的绝对数本身有限的事实无法改变==。因此才会出现本章4.6节中将要介绍的==IPv6==等IPv4以外的方法。\n全局地址与私有地址 对于那些没有连接互联网的独立网络中的主机，只要保证在这个网络内地址唯一，可以不用考虑互联网即可配置相应的IP地址。不过，即使让每个独立的网络各自随意地设置IP地址，也可能会有问题。于是又出现了私有网络的IP地址。它的地址范围如下所示：\n==包含在这个范围内的IP地址都属于私有IP==，而在此之外（A类～C类范围中除去0/8、127/8） 的IP地址称为全局IP（也叫公网IP）\n私有IP最早没有计划连接互联网，而只用于互联网之外的独立网络。然而，当一种能够互换私有IP与全局IP的NAT（更多细节请参考5.6节） 技术诞生以后，配有私有地址的主机与配有全局地址的互联网主机实现了通信。\n全局IP地址基本上要在整个互联网范围内保持唯一 ，但私有地址不需要。只要在同一个域里保证唯一即可。在不同的域里出现相同的私有IP不会影响使用。\n4.路由控制 发送数据包时所使用的地址是网络层的地址，即IP地址。然而仅仅有IP地址还不足以实现将数据包发送到对端目标地址，在数据发送过程中还需要类似于“指明路由器或主机”的信息，以便真正发往目标地址。保存这种信息的就是==路由控制表（Routing Table）==。实现IP通信的主机和路由器都必须持有一张这样的表。它们也正是在这个表格的基础上才得以进行数据包发送的。\n该路由控制表的形成方式有两种：一种是管理员手动设置，另一种是路由器与其他路由器相互交换信息时自动刷新。前者也叫==静态路由控制==，而后者叫做==动态路由控制==。\n■ 默认路由\n如果一张路由表中包含所有的网络及其子网的信息，将会造成无端的浪费。这时，==默认路由（Default Route）==是不错的选择。默认路由是指路由表中任何一个地址都能与之匹配的记录。 ==默认路由一般标记为0.0.0.0/0或default（表示子网掩码时，IP地址为0.0.0.0，子网掩码也是0.0.0.0）== 。这里的0.0.0.0/0并不是指IP地址是0.0.0.0。由于后面是“/0”，所以并没有标识IP地址（0.0.0.0的IP地址应该记述为0.0.0.0/32） 。它只是为了避免人们误以为0.0.0.0是IP 地址。有时默认路由也被标记为default，但是在计算机内部和路由协议的发送过程中还是以0.0.0.0/0进行处理。\n■ 主机路由\n==“IP地址/32”也被称为主机路由（Host Route）==。例如， ==192.168.153.15/32（表示子网掩码时，若IP地址为192.168.153.15，其对应的子网掩码为255.255.255.255）== 就是一种主机路由。它的意思是整个IP地址的所有位都将参与路由。进行主机路由，意味着要基于主机上网卡上配置的IP地址本身，而不是基于该地址的网络地址部分进行路由。\n■ 环回地址\n环回地址是==在同一台计算机上的程序之间进行网络通信时所使用的一个默认地址==。计算机使用一个特殊的IP地址==127.0.0.1==作为环回地址。与该地址具有相同意义的是一个叫做==localhost==的主机名。使用这个IP或主机名时，数据包不会流向网络。\n路由控制表的聚合\n利用网络地址的比特分布可以有效地进行分层配置。对内即使有多个子网掩码，对外呈现出的也是同一个网络地址。这样可以更好地构建网络，==通过路由信息的聚合可以有效地减少路由表的条目（路由表的聚合也叫路由汇总（Aggregation））== 。\n5.IP分割处理与再构成处理 数据链路不同，MTU则相异\nIP报文的分片与重组\n任何一台主机都有必要对IP分片（IP Fragmentation）进行相应的处理。分片往往在网络上遇到比较大的报文无法一下子发送出去时才会进行处理。\n图4.24展示了网络传输过程中进行分片处理的一个例子。由于以太网的默认MTU是1500字节，因此4342字节的IP数据报无法在一个帧当中发送完成。这时，==路由器将此IP数据报划分成了3个分片进行发送==。\n这样的处理是由诸多方面的因素造成的。例如，现实当中无法保证IP数据报是否经由同一个路径传送。因此，途中即使等待片刻，数据包也有可能无法到达目的地。此外，拆分之后的每个分片也有可能会在途中丢失（在目标主机上进行分片的重组时，可能有一部分包会延迟到达。因此，一般会从第一个数据报的分片到达的那一刻起等待约30秒再进行处理） 。即使在途中某一处被重新组装，但如果下一站再经过其他路由时还会面临被分片的可能。这会给路由器带来多余的负担，也会降低网络传送效率。出于这些原因，在终结点（目标主机）端重组分片了的IP数据报成为现行的规范。\n路径MTU发现\n分片机制也有它的不足。首先，路由器的处理负荷加重。随着时代的变迁，计算机网络的物理传输速度不断上升。这些高速的链路，对路由器和计算机网络提出了更高的要求。另一方面，随着人们对网络安全的要求提高，路由器需要做的其他处理也越来越多，如网络过滤等。因此，只要允许，是==不希望由路由器进行IP数据包的分片处理的==。\n为了应对以上问题，产生了一种新的技术==“路径MTU发现”（Path MTU Discovery（也可以缩写为PMTUD））==\n路径MTU（Path MTU）是指从发送端主机到接收端主机之间不需要分片时最大MTU的大小。\n路径MTU发现从发送主机按照路径MTU的大小将数据报分片后进行发送。进行路径MTU发现，就可以==避免在中途的路由器上进行分片处理，也可以在TCP中发送更大的包==。\n6.IPv6 IPv6（IP version 6）是为了根本解决IPv4地址耗尽的问题而被标准化的网际协议。IPv4的地址长度为4个8位字节，即32比特。而IPv6的地址长度则是原来的4倍，即128比特（因此IPv6的地址空间是IPv4的2^96^=7.923×10^28^ 倍） ，一般写成8个16位字节。\nIPv6的特点 IP地址的扩大与路由控制表的聚合 IP地址依然适应互联网分层构造。分配与其地址结构相适应的IP地址，尽可能避免路由表膨大。\n性能提升 包首部长度采用固定的值（40字节），不再采用首部检验码。简化首部结构，减轻路由器负荷。路由器不再做分片处理（通过路径MTU发现只由发送端主机进行分片处理）。\n支持即插即用功能 即使没有DHCP服务器也可以实现自动分配IP地址。\n采用认证与加密功能 应对伪造IP地址的网络安全功能以及防止线路窃听的功能 （IPsec）。\n多播、Mobile IP成为扩展功能 多播和Mobile IP被定义为IPv6的扩展功能。由此可以预期，曾在 IPv4中难于应用的这两个功能在IPv6中能够顺利使用。\nIPv6中IP地址的标记方法 IPv6的IP地址长度为128位。它所能表示的数字高达38位数（2^128^ = 约3.40×10^38^）\n如果将IPv6的地址像IPv4的地址一样用十进制数据表示的话，是16个数字的序列（IPv4是4个数字的序列）。由于用16个数字序列表示显得有些麻烦，因此，将IPv6和IPv4在标记方法上进行区分。一般人们将128比特IP地址以==每16比特为一组，每组用冒号（“：”）隔开进行标记==。而且如果出现连续的0时还可以将这些0省略，并用两个冒号 （“：：”）隔开。但是，一个IP地址中只允许出现一次两个连续的冒号。\nIPv6地址的结构 7.IPv4首部以及IPv6首部 第5章 IP协议相关技术 1.DNS **主机识别码：**这种识别方式是指为每台计算机赋以唯一的主机名，在进行网络通信时可以直接使用主机名称而无需输入一大长串的IP地址。并且此时，系统必须自动将主机名转换为具体的IP地址。为了实现这样的功能，主机往往会利用一个叫做hosts的数据库文件。\n域名服务器\n域名服务器是指管理域名的主机和相应的软件，它可以管理所在分层的域的相关信息。 每层都设有一个域名服务器。根域名服务器中注册着根以下第1层域名服务器的IP地址。\n域名和域名服务器需要按照分层进行设置。\n所有的域名服务器都必须注册根域名服务器的IP地址。因为DNS根据IP地址进行检索时，需要从根域名服务器开始按顺序进行。\n解析器（Resolver）\n进行DNS查询的主机和软件叫做DNS解析器。用户所使用的工作站或个人电脑都属于解析器。一个解析器至少要注册一个以上域名服务器的IP地址。通常，它至少包括组织内部的域名服务器的IP地址。\nDNS查询\n2.ARP ==ARP（Address Resolution Protocol）==是一种解决地址问题的协议。以目标IP地址为线索，用来定位下一个应该接收数据分包的网络设备对应的MAC地址。如果目标主机不在同一个链路上时，可以通过ARP查找下一跳路由器的MAC地址。不过ARP只适用于IPv4，不能用于IPv6。IPv6中可以用ICMPv6替代ARP发送邻居探索消息。\nARP的工作机制\n主机A为了获得主机B的MAC地址，起初要通过广播发送一个ARP请求包。这个包中包含了想要了解其MAC地址的主机IP地址。也就是说，ARP请求包中已经包含了主机B的IP地址172.20.1.2。由于广播的包可以被同一个链路上所有的主机或路由器接收，因此ARP的请求包也就会被这同一个链路上所有的主机和路由器进行解析。如果ARP请求包中的目标IP地址与自己的IP地址一致，那么这个节点就将自己的MAC地址塞入ARP响应包返回给主机A。\nRARP\nRARP（Reverse Address Resolution Protocol）是将ARP反过来，从MAC地址定位IP地址的一种协议。例如将打印机服务器等小型嵌入式设备接入到网络时就经常会用得到。\n平常我们可以通过个人电脑设置IP地址，也可以通过DHCP（Dynamic Host Configuration Protocol， DHCP可以像RARP一样分配一个固定的IP地址） 自动分配获取IP地址。 然而，对于使用嵌入式设备时，会遇到没有任何输入接口或无法通过 DHCP动态获取IP地址的情况 。\n在类似情况下，就可以使用RARP。为此，需要架设一台RARP服务器，从而在这个服务器上注册设备的MAC地址及其IP地址（使用RARP的前提是认为MAC地址就是设备固有的一个值） 。然后再将这个设备接入到网络，插电启动设备时，该设备会发送一条“我的MAC地址是xxx，请告诉我，我的IP地址应该是什么”的请求信息。RARP服务器接到这个消息后返回类似于“MAC地址为xxx的设备，IP地址为xxx”的信息给这个设备。而设备就根据从RARP服务器所收到的应答信息设置自己的IP地址。\n3.ICMP 架构IP网络时需要特别注意两点：确认网络是否正常工作，以及遇到异常时进行问题诊断。\nICMP的主要功能包括，==确认IP包是否成功送达目标地址，通知在发送过程当中IP包被废弃的具体原因，改善网络设置等==。有了这些功能以后，就可以获得网络是否正常、设置是否有误以及设备有何异常等信息，从而便于进行网络上的问题诊断。\n在IP通信中如果某个IP包因为某种原因未能达到目标地址，那么这个具体的原因将由ICMP负责通知。\nICMP的消息大致可以分为两类：一类是==通知出错原因的错误消息==，另一类是==用于诊断的查询消息==。\n表5.2 ICMP消息类型\n主要的ICMP消息 ■ ICMP目标不可达消息（类型3）\nIP路由器无法将IP数据包发送给目标地址时，会给发送端主机返回一个目标不可达（Destination Unreachable Message）的ICMP消息，并在这个消息中显示不可达的具体原因\n■ ICMP重定向消息（类型5）\n如果路由器发现发送端主机使用了次优的路径发送数据，那么它会返回一个ICMP重定向（ICMP Redirect Message）的消息给这个主机。在这个消息中包含了最合适的路由信息和源数据。这主要发生在路由器持有更好的路由信息的情况下。路由器会通过这样的ICMP消息给发送端主机一个更合适的发送路由。\n■ ICMP超时消息（类型11）\nIP包中有一个字段叫做TTL（Time To Live，生存周期），它的值随着每经过一次路由器就会减1（当IP包在路由器上停留1秒以上时减去所停留的秒数，但是现在绝大多数设备并不做这样的处理。） ，直到减到0时该IP包会被丢弃。此时，IP路由器将会发送一个ICMP超时的消息（ICMP Time Exceeded Message，错误号0（错误号1表示将被拆分包做重构处理时超时） ）给发送端主机，并通知该包已被丢弃。\n■ ICMP回送消息（类型0、8）\n用于进行通信的主机或路由器之间，判断所发送的数据包是否已经成功到达对端的一种消息。可以向对端主机发送回送请求的消息 （ICMP Echo Request Message，类型8），也可以接收对端主机发回来的回送应答消息（ICMP Echo Reply Message，类型0）。网络上最常用的==ping命令==（Packet InterNetwork Groper，判断对端主机是否可达的一种命令） 就是利用这个消息实现的。\n■ ICMP原点抑制消息（类型4）\n在使用低速广域线路的情况下，连接WAN的路由器可能会遇到网络拥堵的问题。ICMP原点抑制消息的目的就是为了缓和这种拥堵情况。当路由器向低速线路发送数据时，其发送队列的残存变为零而无法发送出去时，可以向IP包的源地址发送一个ICMP原点抑制（ICMP Source Quench Message）消息。收到这个消息的主机借此了解在整个线路的某一处发生了拥堵的情况，从而打开IP包的传输间隔。然而，由于这种ICMP可能会引起不公平的网络通信，一般不被使用。\n■ ICMP路由器探索消息（类型9、10）\n主要用于发现与自己相连网络中的路由器。当一台主机发出ICMP路由器请求（Router Solicitaion，类型10）时，路由器则返回ICMP路由器公告消息（Router Advertisement，类型9）给主机。\n■ ICMP地址掩码消息（类型17、18）\n主要用于主机或路由器想要了解子网掩码的情况。可以向那些目标主机或路由器发送ICMP地址掩码请求消息（\nICMP Address Mask Request，类型17），然后通过接收ICMP地址掩码应答消息（ICMP Address Mask Reply，类型18）获取子网掩码的信息。\nICMPv6 IPv4中ICMP仅作为一个辅助作用支持IPv4。也就是说，在IPv4时期，即使没有ICMP，仍然可以实现IP通信。然而，在IPv6中，ICMP的作用被扩大，如果没有ICMPv6，IPv6就无法进行正常通信。\n尤其在IPv6中，从IP地址定位MAC地址的协议从ARP转为ICMP的邻居探索消息（Neighbor Discovery）。这种邻居探索消息融合了IPv4的ARP、ICMP重定向以及ICMP路由器选择消息等功能于一体，甚至还提供自动设置IP地址的功能（ICMPv6中没有DNS服务器的通知功能，因此实际上需要与DHCPv6组合起来才能实现自动设置IP地址） 。\n■ 邻居探索\nICMPv6中从类型133至类型137的消息叫做邻居探索消息。这种邻居探索消息对于IPv6通信起着举足轻重的作用。==邻居请求消息用于查询IPv6的地址与MAC地址的对应关系，并由邻居宣告消息得知MAC地址==（IPv4中查询IP地址与MAC地址对应关系用到的是ARP） 。邻居请求消息利用IPv6的多播地址（IPv4中所使用的ARP采用广播，使得不支持ARP的节点也会收到包，造成一定的浪费） 实现传输。\n4.DHCP 如果逐一为每一台主机设置IP地址会非常繁琐的事情。特别是在移动使用笔记本电脑、智能终端以及平板电脑等设备时，每移动到一个新的地方，都要重新设置IP地址。\n于是，为了实现自动设置IP地址、统一管理IP地址分配，就产生了==DHCP（Dynamic Host Configuration Protocol）==协议。有了DHCP，计算机只要连接到网络，就可以进行TCP/IP通信。也就是说，DHCP让即插即用（指只要物理上一连通，无需专门设置就可以直接使用这个物理设备） 变得可能。而DHCP不仅在IPv4中，在IPv6中也可以使用。\nDHCP的工作机制 使用DHCP之前，首先要架设一台DHCP服务器（很多时候用该网段的路由器充当DHCP服务器） 。然后将DHCP所要分配的IP地址设置到服务器上。此外，还需要将相应的子网掩码、路由控制信息以及DNS服务器的地址等设置到服务器上。\n关于从DHCP中获取IP地址的流程，以图5.17为例简单说明的话， 主要分为两个阶段（在发送DHCP发现包与DHCP请求包时，DHCP即插即用的IP地址尚未确定。因此，DHCP发现包的目标地址为广播地址255.255.255.255，而源地址则为0.0.0.0，表示未知） 。\nDHCP在分配IP地址有两种方法。一种是由DHCP服务器在特定的IP地址中自动选出一个进行分配。另一种方法是针对MAC地址 分配一个固定的IP地址。而且这两种方法可以并用。\n为了检查所要分配的IP地址以及已经分配了的IP地址是否可用， DHCP服务器或DHCP客户端必须具备以下功能：\nDHCP服务器 ==在分配IP地址前发送ICMP回送请求包，确认没有返回应答。==\nDHCP客户端 ==针对从DHCP那里获得的IP地址发送ARP请求包，确认没有返回应答。==\n在获得IP地址之前做这种事先处理可能会耗一点时间，但是可以安全地进行IP地址分配。\nDHCP中继代理 家庭网络大多都只有一个以太网（无线LAN）的网段，与其连接的主机台数也不会太多。因此，只要有一台DHCP服务器就足以应对IP地址分配的需求，而大多数情况下都由宽带路由器充当这个DHCP的角色。\n相比之下，一个企业或学校等较大规模组织机构的网络环境当中，一般会有多个以太网（无线LAN）网段。在这种情况下，若要针对每个网段都设置DHCP服务器将会是个庞大的工程。即使路由器可以分担DHCP的功能，如果网络中有不下100个路由器，就要为100个路由器设置它们各自可分配IP地址的范围，并对这些范围进行后续的变更维护，这将是一个极其耗时和难于管理的工作（DHCP服务器分配的IP地址范围，有时会随着服务器或打印机等固定IP设备的增减而不得不发生变化） 。也就是说将DHCP服务器分设到各个路由器上，于管理和运维都不是件有益的事。\n因此，在这类网络环境中，往往需要将DHCP统一管理。具体方法可以使用==DHCP中继代理来实现==。有了DHCP中继代理以后，==对不同网段的IP地址分配也可以由一个DHCP服务器统一进行管理和运维==。\n这种方法使得在每个网段架设一个DHCP服务器被取代，==只需在每个网段设置一个DHCP中继代理即可==（DHCP中继代理多数为路由器，不过也有在主机中安装某些软件得以实现的情况） 。==它可以设置DHCP服务器的IP地址==，从而可以在DHCP服务器上为每个网段注册IP地址的分配范围。\nDHCP客户端会向DHCP中继代理发送DHCP请求包，而DHCP中继代理在收到这个广播包以后再以单播的形式发给DHCP服务器。服务器端收到该包以后再向DHCP中继代理返回应答，并由DHCP中继代理将此包转发给DHCP客户端（DHCP包中包含发出请求的主机的==MAC地址==。DHCP中继代理正是利用这个MAC地址将包返回给了DHCP客户端） 。由此，==DHCP服务器即使不在同一个链路上也可以实现统一分配和管理IP地址==。\n5.NAT NAT（Network Address Translator， 网络地址转换）是用于==在本地网络中使用私有地址，在连接互联网时转而使用全局IP地址的技术==。除转换IP地址外，还出现了可以转换TCP、UDP端口号的==NAPT（Network Address Ports Translator）==技术，由此可以实现用一个全局IP地址与多个主机的通信（通常人们提到的NAT，多半是指NAPT。NAPT也叫做IP伪装或MultiNAT）\nNAT的工作机制 如图5.19所示，以10.0.0.10的主机与163.221.120.9的主机进行通信为例。利用NAT，途中的NAT路由器将发送源地址从10.0.0.10转换为全局的IP地址（202.244.174.37）再发送数据。反之，当包从地址163.221.120.9发过来时，目标地址（202.244.174.37）先被转换成私有IP地址10.0.0.10以后再被转发（在TCP或UDP中，由于IP首部中的IP地址还要用于校验和的计算，因此当IP地址发生变化时，也需要相应地将TCP、UDP的首部进行转换） 。\n==在NAT（NAPT）路由器的内部，有一张自动生成的用来转换地址的表==。当10.0.0.10向163.221.120.9发送第一个包时生成这张表，并按照表中的映射关系进行处理。\n当私有网络内的多台机器同时都要与外部进行通信时，仅仅转换IP地址，人们不免担心全局IP地址是否不够用。这时采用如图5.20所示的包含端口号一起转换的方式==（NAPT）==可以解决这个问题。\n在使用TCP或UDP的通信当中，只有目标地址、源地址、目标端口、源端口以及协议类型（TCP还是UDP）五项内容都一致时才被认为是同一个通信连接。此时所使用的正是NAPT。\n图5.20中，主机163.221.120.9的端口号是80，LAN中有两个客户端10.0.0.10和10.0.0.11同时进行通信，并且这两个客户端的本地端口都是1025。此时，仅仅转换IP地址为某个全局地址202.244.174.37，会令转换后的所有数字完全一致。为此，只要将10.0.0.11的端口号转换为1026就可以解决问题。如图5.20所示，生成一个NAPT路由器的转换表，就可以正确地转换地址跟端口的组合，令客户端A、B能同时与服务器之间进行通信。\nNAT-PT（NAPT-PT） 现在很多互联网服务都基于IPv4。如果这些服务不能做到在IPv6中也能正常使用的话，搭建IPv6网络环境的优势也就无从谈起了。 为了解决这个问题，就产生了==NAT-PT（NAPT-PT）==（PT是 Protocol Translatio的缩写。严格来讲NAT-PT用来翻译IP地址，而NATP-PT则是用来翻译IP首部与端口号的） 规范。==NAT-PT是将IPv6的首部转换为IPv4的首部的一种技术==。有了这种技术，那些只有IPv6地址的主机也就能够与IPv4地址的其他主机进行通信了。\n6.IP隧道 在一个如图5.22所示的网络环境里，网络A、B使用IPv6，如果处于中间位置的网络C支持使用IPv4的话，网络A与网络B之间将无法直接进行通信。为了让它们之间正常通信，这时必须得采用IP隧道的功能。\nIP隧道中可以将那些从网络A发过来的IPv6的包统和为一个数据， ==再为之追加一个IPv4的首部以后转发给网络C==。\n7.IP相关技术 IP任播 IP任播主要用于报警电话110与消防电话119系统。当人们拨打110或119时，其接收电话并不是只有一个，而是可以拨打到一个区域管辖范围内的所有公安或消防部门。省、市、县、乡等不同级别的区域都各自设置着110与119的急救电话，而且数量极其庞大。这种机制的实现，在互联网上就是IP任播。\n==IP任播是指为那些提供同一种服务的服务器配置同一个IP地址，并与最近的服务器进行通信的一种方法（选择哪个服务器由路由协议的类型和设置方法决定）==。\n在==IP任播==的应用当中最为有名的当属==DNS根域名服务器==。DNS根域名服务器，出于历史原因，对IP地址的分类限制为13种类型。从负载均衡与灾备应对的角度来看，全世界根域名服务器不可能只设置13处。为此，使用IP任播可以让更多的DNS根域名服务器散布到世界的各个角落。因此，当发送一个请求包给DNS根域名服务器时，一个适当区域的IP地址也将被发送出去，从而可以从这个服务器获得应答。\n第6章 TCP与UDP 传输层的TCP和UDP，为了识别自己所传输的数据部分究竟应该发给哪个应用，也设定了这样一个编号。\n传输层必须指出这个具体的程序，为了实现这一功能，使用==端口==（注意此处的端口与路由器、交换机等设备上指网卡的端口有所不同）号这样一种识别码。根据端口号就可以识别在传输层上一层的应用层中所要进行处理的具体程序（一个程序可以使用多个端口） 。\nTCP/IP的众多应用协议大多以客户端/服务端的形式运行。\n作为服务端的程序有必要提前启动，准备接收客户端的请求。否则即使有客户端的请求发过来，也无法做到相应的处理。\n这些服务端程序在UNIX系统当中叫做==守护进程==。例如HTTP的服务端程序是httpd（HTTP守护进程），而ssh的服务端程序是sshd（SSH守护进程）。在UNIX中并不需要将这些守护进程逐个启动，而是启动一个可以代表它们接收客户端请求的inetd（互联网守护进程）服务程序即可。它是一种超级守护进程。该超级守护进程收到客户端请求以后会创建（fork）新的进程并转换（exec）为sshd等各个守护进程。\n■ TCP\nTCP是==面向连接的、可靠的流协议==。流就是指不间断的数据结构， 你可以把它想象成排水管道中的水流。当应用程序采用TCP发送消息时，虽然可以保证发送的顺序，但还是犹如没有任何间隔的数据流发送给接收端（例如，在发送端应用程序发送了10次100字节的消息，那么在接收端，应用程序有可能会收到一个1000字节连续不间断的数据。因此在TCP通信中，发送端应用可以在自己所要发送的消息中设置一个表示长度或间隔的字段信息） 。TCP为提供可靠性传输，实行“顺序控制”或“重发控制”机制。此外还具备“流控制（流量控制）”、“拥塞控制”、提高网络利用率等众多功 能。\n■ UDP\nUDP是==不具有可靠性的数据报协议==。细微的处理它会交给上层的应用去完成。在UDP的情况下，虽然可以确保发送消息的大小（例如，发送端应用程序发送一个100字节的消息，那么接收端应用程序也会以100字节为长度接收数据。UDP中，消息长度的数据也会发送到接收端，因此在发送的消息中不需要设置一个表示消息长度或间隔的字段信息。然而，UDP不具备可靠传输。所以，==发送端发出去的消息在网络传输途中一旦丢失，接收端将收不到这个消息==） ，却不能保证消息一定会到达。因此，应用有时会根据自己的需要进行重发处理。\nTCP用于在传输层有必要实现可靠传输的情况。由于它是面向有连接并具备顺序控制、重发控制等机制的，所以它可以为应用提供可靠传输。\n而在一方面，UDP主要用于那些对高速传输和实时性有较高要求的通信或广播通信。我们举一个通过IP电话进行通话的例子。如果使用TCP，数据在传送途中如果丢失会被重发，但这样无法流畅地传输通话人的声音，会导致无法进行正常交流。而采用UDP，它不会进行重发处理。从而也就不会有声音大幅度延迟到达的问题。即使有部分数据丢失，也只是会影响某一小部分的通话（在实时传送动画或声音时，途中一小部分网络的丢包可能会导致画面或声音的短暂停顿甚至出现混乱。 但在实际使用当中，这一点干扰并无大碍） 。此外，在多播与广播通信中也使用UDP而不是TCP。RIP（7.4节）、DHCP（5.5节）等基于广播的协议也要依赖于UDP。\n1.端口号 数据链路和IP中的地址，分别指的是MAC地址和IP地址。前者用来识别同一链路中不同的计算机，后者用来识别TCP/IP网络中互连的主机和路由器。在传输层中也有这种类似于地址的概念，那就是端口号。端口号用来识别同一台计算机中进行通信的不同应用程序。因此，它也被称为程序地址。\n==仅凭目标端口识别某一个通信是远远不够的。==\n因此，TCP/IP或UDP/IP通信中通常采用5个信息来识别（这个信息可以在Unix或Windows系统中通过netstat -n 命令显示） 一个通信。它们是==“源IP地址”、“目标IP地址”、“协议号”、“源端口号”、“目标端口号”==。只要其中某一项不同，则被认为是其他通信。\n端口号如何确定\n■ 标准既定的端口号\n这种方法也叫静态方法。它是指每个应用程序都有其指定的端口号。但并不是说可以随意使用任何一个端口号。每个端口号都有其对应的使用目的。例如，HTTP、TELNET、FTP等广为使用的应用协议中所使用的端口号就是固定的。这些端口号也被称之为知名端口号（Well-Known Port Number）。\n■ 时序分配法\n第二种方法也叫时序（或动态的）分配法。此时，服务端有必要确定监听端口号，但是接受服务的客户端没必要确定端口号。\n在这种方法下，客户端应用程序可以完全不用自己设置端口号，而全权交给操作系统进行分配。操作系统可以为每个应用程序分配互不冲突的端口号。例如，每需要一个新的端口号时，就在之前分配号码的基础上加1。这样，操作系统就可以动态地管理端口号了。==根据这种动态分配端口号的机制，即使是同一个客户端程序发起的多个TCP连接，识别这些通信连接的5部分数字也不会全部相同==。\n2.UDP UDP是User Datagram Protocol（用户数据报协议）的缩写。\nUDP不提供复杂的控制机制，利用IP提供面向无连接的通信服务。 并且它是将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制。\n即使是出现网络拥堵的情况下，UDP也无法进行流量控制等避免网络拥塞的行为。此外，传输途中即使出现丢包，UDP也不负责重发。甚至当出现包的到达顺序乱掉时也没有纠正的功能。如果需要这些细节控 制，那么不得不交由采用UDP的应用程序去处理（拥塞控制）。\n由于UDP面向无连接，它可以随时发送数据。再加上UDP本身的处理既简单又高效，因此经常用于以下几个方面：\n包总量较少的通信（DNS、SNMP等） 视频、音频等多媒体通信（即时通信） 限定于LAN等特定网络中的应用通信 广播通信（广播、多播） 3.TCP TCP与UDP的区别相当大。它充分地实现了数据传输时各种控制功能，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在UDP中都没有。此外，TCP作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费（由于UDP没有连接控制，所以即使对端从一开始就不存在或中途退出网络，数据包还是能够发送出去。（当ICMP错误返回时，有时也实现了不再发送的机制）） 。\nTCP的特点及其目的\n为了通过IP数据报实现可靠性传输，需要考虑很多事情，例如数据的破坏、丢包、重复以及分片顺序混乱等问题。如不能解决这些问题，也就无从谈起可靠传输。\nTCP通过==检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输。==\n通过序列号与确认应答提高可靠性 在TCP中，当发送端的数据到达接收主机时，接收端主机会返回一个已收到消息的通知。这个消息叫做确认应答（ACK（ACK（Positive Acknowled-gement）意指已经接收） ）。\n此外，也有可能因为一些其他原因导致确认应答延迟到达，在源主机重发数据以后才到达的情况也履见不鲜。此时，源发送主机只要按照机制重发数据即可。但是对于目标主机来说，这简直是一种“灾难”。它会反复收到相同的数据。而为了对上层应用提供可靠的传输，必须得放弃重复的数据包。为此，就必须引入一种机制，它能够识别是否已经接 收数据，又能够判断是否需要接收。\n上述这些==确认应答处理、重发控制以及重复控制等功能都可以通过序列号实现==。序列号是按顺序给发送数据的每一个字节（8位字节）都标上号码的编号（序列号的初始值并非为0。而是在建立连接以后由随机数生成。而后面的计算则是对每一字节加一） 。接收端查询接收数据TCP首部中的序列号和数据的长度，将自己下一步应该接收的序号作为确认应答返送回去。就这样，通过序列号和确认应答号，TCP可以实现可靠传输。\n重发超时如何确定 TCP要求不论处在何种网络环境下都要提供高性能通信，并且无论网络拥堵情况发生何种变化，都必须保持这一特性。为此，它在每次发包时都会计算往返时间（Round Trip Time也叫RTT。是指报文段的往返时间。） 及其偏差（RTT时间波动的值、方差。有时也叫抖动。） 。将这个往返时间和偏差相加重发超时的时间，就是比这个总和要稍大一点的值。\n数据被重发之后若还是收不到确认应答，则进行再次发送。此时，等待确认应答的时间将会以2倍、4倍的指数函数延长。\n连接管理 UDP是一种面向无连接的通信协议，因此不检查对端是否可以通信，直接将UDP包发送出去。TCP与此相反，它会在数据通信之前，通过TCP首部发送一个SYN包作为建立连接的请求等待确认应答（TCP中发送第一个SYN包的一方叫做客户端，接收这个的一方叫做服务端） 。如果对端发来确认应答，则认为可以进行数据通信。如果对端的确认应答未能到达，就不会进行数据通信。此外，在通信结束时会进行断开连接的处理（FIN包）。\n可以使用TCP首部用于控制的字段来管理TCP连接（也叫控制域） 。==一个连接的建立与断开，正常过程至少需要来回发送7个包才能完成（建立一个TCP连接需要发送3个包。这个过 程也称作**“三次握手”**==） 。\nTCP以段为单位发送数据 在建立TCP连接的同时，也可以确定发送数据包的单位，我们也可以称其为==“最大消息长度”（MSS：Maximum Segment Size）==。\nTCP在传送大量数据时，是以MSS的大小将数据进行分割发送。进行重发时也是以MSS为单位。\nMSS是在三次握手的时候，在两端主机之间被计算得出。两端的主机在发出建立连接的请求时，会在TCP首部中写入MSS选项，告诉对方自己的接口能够适应的MSS的大小（为附加MSS选项，TCP首部将不再是20字节，而是4字节的整数倍。如图6.13所示的+4。） 。然后会在两者之间选择一个较小的值投入使用。\n利用窗口控制提高速度 TCP以1个段为单位，每发一个段进行一次确认应答的处理。这样的传输方式有一个缺点。那就是，包的往返时间越长通信性能就越低。\n为解决这个问题，TCP引入了窗口这个概念。即使在往返时间较长的情况下，它也能控制网络性能的下降。图6.15所示，确认应答不再是以每个分段，而是以更大的单位进行确认时，转发时间将会被大幅度的缩短。也就是说，发送端主机，==在发送了一个段以后不必要一直等待确认应答，而是继续发送==。\n==窗口大小就是指无需等待确认应答而可以继续发送数据的最大值==。图6.15中，窗口大小为4个段。\n这个机制实现了使用大量的缓冲区，通过对多个段同时进行确认应答的功能。\n如图6.16所示，发送数据中高亮圈起的部分正是前面所提到的窗口。在这个窗口内的数据即便没有收到确认应答也可以发送出去。此外，从该窗口中能看到的数据因其某种数据已在传输中丢失，所以发送端才能收到确认应答，这种情况也需进行重发。为此，==发送端主机在等到确认应答返回之前，必须在缓冲区中保留这部分数据==。\n收到确认应答的情况下，将窗口滑动到确认应答中的序列号的位置。这样可以顺序地将多个段同时发送提高通信性能。这种机制也被称为==滑动窗口控制==。\n窗口控制与重发控制 在使用窗口控制中，如果出现段丢失该怎么办？\n首先，我们先考虑确认应答未能返回的情况。在这种情况下，==数据已经到达对端，是不需要再进行重发的==。然而，在没有使用窗口控制的时候，没有收到确认应答的数据都会被重发。而使用了窗口控制，就如图6.17所示，某些确认应答即便丢失也无需重发。\n其次，我们来考虑一下某个报文段丢失的情况。如图6.18所示，接收主机如果收到一个自己应该接收的序号以外的数据时，会针对当前为止收到数据返回确认应答（==不过即使接收端主机收到的包序号并不连续，也不会将数据丢弃而是暂时保存至缓冲区中==） 。\n如图6.18所示。==当某一报文段丢失后，发送端会一直收到序号为1001的确认应答==，这个确认应答好像在提醒发送端“我想接收的是从1001开始的数据”。因此，在窗口比较大，又出现报文段丢失的情况下，同一个序号的确认应答将会被重复不断地返回。而发送端主机如果连续3次收到同一个确认应答（之所以连续收到3次而不是两次的理由是因为，即使数据段的序号被替换两次也不会触发重发机制） ，就会将其所对应的数据进行重发。这种机制比之前提到的超时管理更加高 效，因此也被称作==高速重发控制==。\n流控制 TCP提供一种机制可以让发送端根据接收端的实际接收能力控制发送的数据量。这就是所谓的==流控制==。它的具体操作是，接收端主机向发送端主机通知自己可以接收数据的大小，于是发送端会发送不超过这个限度的数据。该大小限度就被称==窗口大小==。在前面6.4.6节中所介绍的窗口大小的值就是由接收端主机决定的。\nTCP首部中，专门有一个字段用来通知窗口大小。接收主机将自己可以接收的缓冲区大小放入这个字段中通知给发送端。这个字段的值越大，说明网络的吞吐量越高。 不过，接收端的这个缓冲区一旦面临数据溢出时，窗口大小的值也 会随之被设置为一个更小的值通知给发送端，从而控制数据发送量。也就是说，发送端主机会根据接收端主机的指示，对发送数据的量进行控制。这也就形成了一个完整的==TCP流控制（流量控制）==。\n如图6.19所示，当接收端收到从3001号开始的数据段后其缓冲区即满，不得不暂时停止接收数据。之后，在收到发送窗口更新通知后通信才得以继续进行。如果这个窗口的更新通知在传送途中丢失，可能会导致无法继续通信。为避免此类问题的发生，发送端主机会时不时的发送一个叫做窗口探测的数据段，此数据段仅含一个字节以获取最新的窗口大小信息。\n拥塞控制 有了TCP的窗口控制，收发主机之间即使不再以一个数据段为单位发送确认应答，也能够连续发送大量数据包。然而，如果在通信刚开始时就发送大量数据，也可能会引发其他问题。\n一般来说，计算机网络都处在一个共享的环境。因此也有可能会因为其他主机之间的通信使得网络拥堵。在网络出现拥堵时，如果突然发送一个较大量的数据，极有可能会导致整个网络的瘫痪。\nTCP为了防止该问题的出现，在通信一开始时就会通过一个叫做==慢启动==的算法得出的数值，对发送数据量进行控制。\n提高网络利用率的规范 ■ Nagle算法\n该算法是指发送端即使还有应该发送的数据，但如果这部分数据很少的话，则进行延迟发送的一种处理机制。具体来说，就是仅在下列任意一种条件下才能发送数据。如果两个条件都不满足，那么暂时等待一段时间以后再进行数据发送。\n已发送的数据都已经收到确认应答时 可以发送最大段长度（MSS）的数据时 ■ 延迟确认应答\n接收数据的主机如果每次都立刻回复确认应答的话，可能会返回一个较小的窗口。那是因为刚接收完数据，缓冲区已满。当某个接收端收到这个小窗口的通知以后，会以它为上限发送数据，从而又降低了网络的利用率（这其实是窗口控制特有的问题，专门术语叫做糊涂窗口综合征（SWS：Silly Window Syndrome）） 。为 此，引入了一个方法，那就是==收到数据以后并不立即返回确认应答，而是延迟一段时间的机制==。\n在没有收到2×最大段长度的数据为止不做确认应答（根据操作系统的不同，有时也有不论数据大小，只要收到两个包就即刻返回确认应答的情况） 其他情况下，最大延迟0.5秒发送确认应答（如果延迟多于0.5秒可能会导致发送端重发数据） （很多操作系统设置为0.2秒左右（这个时间越小、CPU的负荷会越高，性能也下降。反之，这个时间越长，越有可能触发发送主机的重发处理，而窗口为只有1个数据段的时候，性能也会下降） ） 事实上，大可不必为每一个数据段都进行一次确认应答。TCP采用滑动窗口的控制机制，因此通常确认应答少一些也无妨。TCP文件传输中，绝大多数是每两个数据段返回一次确认应答。\n■ 捎带应答\n根据应用层协议，发送出去的消息到达对端，对端进行处理以后， 会返回一个回执。\n在此类通信当中，==TCP的确认应答和回执数据可以通过一个包发送==。这种方式叫做捎带应答。通过这种机制，可以使收发的数据量减少。\n4.其他传输层协议 UDP-Lite\nSCTP\nDCCP\n5.UDP首部的格式 ■ 校验和（Checksum）\n校验和是为了提供可靠的UDP首部和数据而设计。在计算校验和时，如图6.25所示，附加在UDP伪首部与UDP数据报之前。\n==■ 校验和计算中计算UDP伪首部的理由==\n为什么在进行校验和计算时，也要计算UDP伪首部呢？关于这个问题，与6.2节中所介绍的内容有所关联。\nTCP/IP中识别一个进行通信的应用需要5大要素，它们分别为“源IP地址”、“目标IP地址”、“源端口”、“目标端口”、“协议号”。然而，在UDP的首部中只包含它们当中的两项（源端口和目标端口），余下的3项都包含在IP首部里。\n假定其他3项的信息被破坏会产生什么样的后果呢？很显然，这极有可能会导致应该收包的应用收不到包，不该收到包的应用却收到了包。\n为了避免这类问题，有必要验证一个通信中必要的5项识别码是否正确。为此，在校验和的计算中就引入了伪首部的概念。\n此外，IPv6中的IP首部没有校验和字段。TCP或UDP通过伪首部，得以对5项数字进行校验，从而实现即使在IP首部并不可靠的情况下仍然能够提供可靠的通信传输。\n6.TCP首部格式 ■ 序列号（Sequence Number）\n字段长32位。序列号（有时也叫序号）是指发送数据的位置。每发送一次数据，就累加一次该数据字节数的大小。\n■ 控制位（Control Flag）\n字段长为8位，每一位从左至右分别为CWR、ECE、URG、ACK、PSH、RST、SYN、FIN。这些控制标志也叫做控制位。当它们对应位上的值为1时，具体含义如图6.27所示。\nCWR（Congestion Window Reduced） CWR标志（关于CWR标志的设定请参考5.8.4节。） 与后面的ECE标志都用于IP首部的ECN字段。ECE标志为1时，则通知对方已将拥塞窗口缩小。\nECE（ECN-Echo） ECE标志（关于ECE标志的设定请参考5.8.4节。） 表示ECN-Echo。置为1会通知通信对方，从对方到这边的网络有拥塞。在收到数据包的IP首部中ECN为1时将TCP首部中的ECE设置为1。\nURG（Urgent Flag） 该位为1时，表示包中有需要紧急处理的数据。对于需要紧急处理的数据，会在后面的紧急指针中再进行解释。\nACK（Acknowledgement Flag） 该位为1时，确认应答的字段变为有效。TCP规定除了最初建立连接时的SYN包之外该位必须设置为1。\nPSH（Push Flag） 该位为1时，表示需要将受到的数据立刻传给上层应用协议。PSH为0时，则不需要立即传而是先进行缓存。\nRST（Reset Flag） 该位为1时表示TCP连接中出现异常必须强制断开连接。例如，一个没有被使用的端口即使发来连接请求，也无法进行通信。此时就可以返回一个RST设置为1的包。此外，程序宕掉或切断电源等原因导致主机重启的情况下，由于所有的连接信息将全部被初始化，所以原有的TCP通信也将不能继续进行。这种情况下，如果通信对方发送一个设置为1的RST包，就会使通信强制断开连接。\nSYN（Synchronize Flag） 用于建立连接。SYN为1表示希望建立连接，并在其序列号的字段进行序列号初始值的设定（Synchronize本身有同步的意思。也就意味着建立连接的双方，序列号和确认应答号要保持同步） 。\nFIN（Fin Flag） 该位为1时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换FIN位置为1的TCP段。每个主机又对对方的FIN包进行确认应答以后就可以断开连接。不过，主机收到FIN设置为1的TCP段以后不必马上回复一个FIN包，而是可以等到缓冲区中的所有数据都因已成功发送而被自动删除之后再发。\n■ 校验和（Checksum）\nTCP的校验和与UDP相似，区别在于TCP的校验和无法关闭。\n==■ 使用校验和的目的是什么？==\n有噪声干扰的通信途中如果出现位错误，可以由数据链路的FCS检查出来。那么为什么TCP或UDP中也需要校验和呢？\n其实，相比检查噪声影响导致的错误，TCP与UDP的校验和更是一种==进行路由器内存故障或程序漏洞导致的数据是否被破坏的检查==。\n有过C语言编程经验的人都知道，如果指针使用不当，极有可能会破坏内存中的数据结构。路由器的程序中也可能会存在漏洞，或程序异常宕掉的可能。在互联网中发送数据包要经由好多个路由器，一旦在发送途中的某一个路由器发生故障，经过此路由器的包、协议首部或数据就极有可能被破坏。即使在这种情况下，TCP或UDP如果能够提供校验和计算，也可以判断协议首部和数据是否被破坏。\n■ 窗口大小与吞吐量\nTCP通信的最大吞吐量由窗口大小和往返时间决定。假定最大吞吐量为Tmax ，窗口大小为W，往返时间是RTT的话，那么最大吞吐量的公式如下：\n假设窗口为65535字节，RTT为0.1秒，那么最大吞吐量Tmax 如下：\n以上公式表示1个TCP连接所能传输的最大吞吐量为5.2Mbps。如果建立两个以上连接同时进行传输时，这个公式的计算结果则表示==每个连接的最大吞吐量==。也就是说，==在TCP中，与其使用一个连接传输数据，使用多个连接传输数据会达到更高的网络吞吐量==。==在Web浏览器中一般会通过同时建立4个左右连接来提高吞吐量==\n第7章 路由协议 互联网是由路由器连接的网络组合而成的。为了能让数据包正确达地到达目标主机，路由器必须在途中进行正确地转发。这种向“正确的方向”转发数据所进行的处理就叫做==路由控制或路由==。\n路由器根据==路由控制表（Routing Table）==转发数据包。它根据所收到的数据包中目标主机的IP地址与路由控制表的比较得出下一个应该接收的路由器。因此，这个过程中路由控制表的记录一定要正确无误。但凡出现错误，数据包就有可能无法到达目标主机。\n1.静态路由与动态路由 静态路由是指事先设置好路由器和主机中并将路由信息固定的一种方法。而动态路由是指让路由协议在运行过程中自动地设置路由控制信息的一种方法。\n动态路由如图7.2所示，会给相邻路由器发送自己已知的网络连接信息，而这些信息又像接力一样依次传递给其他路由器，直至整个网络都了解时，路由控制表也就制作完成了。而此时也就可以正确转发IP数据包了（图7.2中的传输，只有在没有循环的情况下才能很好地运行。例如路由器C和路由器D之间如果有连接，那么将无法正常工作） 。\n2.路由控制范围 随着IP网络的发展，想要对所有网络统一管理是不可能的事。因此，人们根据路由控制的范围常使用==IGP（Interior Gateway Protocol，外部网关协议）和EGP（Exterior Gateway Protocol，内部网关协议）==（EGP是特定的路由协议名称，请不要与其他同名词汇混淆） 两种类型的路由协议。\n自治系统与路由协议 企业内部网络的管理方针，往往由该企业组织内部自行决定。因此每个企业或组织机构对网络管理和运维的方法都不尽相同。为了提高自己的销售额和生产力，各家企业和组织机构都会相应购入必要的机械设备、构建合适的网络以及采用合理的运维体制。在这种环境下，可以对 公司以外的人士屏蔽企业内部的网络细节，更不必对这些细节上的更新 请求作出回应。这好比我们的日常生活，每个人对家庭内部的私事，都不希望过多暴露给外界，听从外界指挥。\n==制定自己的路由策略，并以此为准在一个或多个网络群体中采用的小型单位叫做自治系统（AS：Autonomous System）或路由选择域（Routing Domain）==。\n==自治系统（路由选择域）内部动态路由采用的协议是域内路由协议，即IGP。而自治系统之间的路由控制采用的是域间路由协议，即 EGP。==\nIGP中还可以使用==RIP（Routing Information Protocol，路由信息协议）、RIP2、OSPF（Open Shortest Path First，开放式最短路径优先）等众多协议。与之相对，EGP使用的BGP（Border Gateway Protocol，边界网关协议）协议==。\n3.路由算法 路由控制有各种各样的算法，其中最具代表性的有两种，是==距离向量（Distance-Vector）算法==和==链路状态（Link-State）算法==。\n距离向量算法 距离向量算法（DV）是指根据距离（代价（Metric是指转发数据 时衡量路由控制中距离和成本的一种指标。在距离向量算法中，代价相当于所要经过的路由器的个数） ）和方向决定目标网络或目标主机位置的一种方法。\n路由器之间可以互换目标网络的方向及其距离的相关信息，并以这些信息为基础制作路由控制表。这种方法在处理上比较简单，不过由于只有距离和方向的信息，所以当网络构造变得分外复杂时，在获得稳定的路由信息之前需要消耗一定时间（也叫做==路由收敛==） ，也极易发生路由循环等问题。\n链路状态算法 链路状态算法是路由器在了解网络整体连接状态的基础上生成路由控制表的一种方法。该方法中，==每个路由器必须保持同样的信息才能进行正确的路由选择==。\n距离向量算法中每个路由器掌握的信息都不相同。通往每个网络所耗的距离（代价）也根据路由器的不同而不同。因此，该算法的一个缺点就是不太容易判断每个路由器上的信息是否正确。\n而链路状态算法中所有路由器持有相同的信息。对于任何一台路由器，网络拓扑都完全一样。因此，只要某一台路由器与其他路由器保持同样的路由控制信息，就意味着该路由器上的路由信息是正确的。\n为了实现上述机制，链路状态算法付出的代价就是如何从网络代理获取路由信息表。这一过程相当复杂，特别是在一个规模巨大而又复杂的网络结构中，管理和处理代理信息需要高速CPU处理能力和大量的内存（为此，==OSPF==正致力于将网络分割为不同的区域，以减少路由控制信息） 。\n主要路由协议 4.RIP ==RIP（Routing Information Protocol）是距离向量型的一种路由协议==，广泛用于LAN。被BSD UNIX作为标准而提供的routed（在UNIX系统上的一个守护进程。该进程实现了RIP协议） 采用了RIP，因此RIP得到了迅速的普及。\n广播路由控制信息\nRIP将路由控制信息定期（30秒一次）向全网广播。如果没有收到路由控制信息，连接就会被断开。不过，这有可能是由于丢包导致的，因此RIP规定等待5次。如果等了6次（180秒）仍未收到路由信息，才会真正关闭连接。\n根据距离向量确定路由 RIP基于距离向量算法决定路径。距离（Metrics）的单位为“跳数”。跳数是指所经过的路由器的个数。RIP希望尽可能少通过路由器将数据包转发到目标IP地址，如图7.7所示。根据距离向量生成距离向量表，再抽出较小的路由生成最终的路由控制表。\n使用子网掩码时的RIP处理（没看明白）\nRIP虽然不交换子网掩码信息，但可以用于使用子网掩码的网络环境。不过在这种情况下需要注意以下几点：\n从接口的IP地址对应分类得出网络地址后，与根据路由控制信息流过此路由器的包中的IP地址对应的分类得出的网络地址进行比较。 如果两者的网络地址相同，那么就以接口的网络地址长度为准。 如果两者的网络地址不同，那么以IP地址的分类所确定的网络地址长度为准。 例如，路由器的接口地址为192.168.1.33/27。很显然，这是一个C类地址，因此按照IP地址分类它的网络地址为192.168.1.33/24。与192.168.1.33/24相符合的IP地址，其网络地址长度都被视为27位。除此之外的地址，则采用每个地址的分类所确定的网络地址长度。\n因此，采用RIP进行路由控制的范围内必须注意两点：一是，因IP地址的分类而产生不同的网络地址时；二是，构造网络地址长度不同的网络环境时。\nRIP中路由变更时的处理 RIP的基本行为可归纳为如下两点：\n将自己所知道的路由信息定期进行广播。 一旦认为网络被断开，数据将无法流过此路由器，其他路由器也就可以得知网络已经断开。 不过，这两点不论哪种方式都存在一些问题。\n如图7.9，路由器A将网络A的连接信息发送给路由器B，路由器B又将自己掌握的路由信息在原来的基础上加1跳后发送给路由器A和路由器C。假定这时与网络A发生了故障。\n路由器A虽然觉察到自己与网络A的连接已经断开，无法将网络A的信息发送给路由器B，但是它会收到路由器B曾经获知的消息。这就使得路由器A误认为自己的信息还可以通过路由器B到达网络A。\n==像这样收到自己发出去的消息，这个问题被称为无限计数（Counting to Infinity）==。\n为了尽可能解决这个问题，人们提出了==“毒性逆转”（Poisoned Reverse）==和==“触发更新”（Triggered Update）==两种方法。\n==毒性逆转==是指当网络中发生链路被断开的时候，不是不再发送这个消息，而是将这个无法通信的消息传播出去。即发送一个距离为16的消息。==触发更新==是指当路由信息发生变化时，不等待30秒而是立刻发送出去的一种方法。有了这两种方法，在链路不通时，可以迅速传送消息以使路由信息尽快收敛。\nRIP2 RIP2的意思是RIP第二版。它是在RIP使用过程中总结了经验的基础上进行改良后的一种协议。第二版与第一版的工作机制基本相同，不过仍有如下几个新的特点。\n■ 使用多播\nRIP中当路由器之间交换路由信息时采用广播的形式，然而在RIP2中改用了多播。这样不仅减少了网络的流量，还缩小了对无关主机的影响。\n■ 支持子网掩码\n与OSPF类似的，RIP2支持在其交换的路由信息中加入子网掩码信息。\n■ 路由选择域\n与OSPF的区域类似，在同一个网络中可以使用逻辑上独立的多个RIP。\n■ 外部路由标志\n通常用于把从BGP等获得的路由控制信息通过RIP传递给AS内。\n■ 身份验证密钥\n与OSPF一样，RIP包中携带密码。只有在自己能够识别这个密码时才接收数据，否则忽略这个RIP包。\n5.OSPF OSPF是链路状态型路由协议 OSPF为链路状态型路由器。路由器之间交换链路状态生成网络拓扑信息，然后再根据这个拓扑信息生成路由控制表。\nRIP的路由选择，要求途中所经过的路由器个数越少越好。与之相比，OSPF可以给每条链路（实际上，可以为连到该数据链路（子网）的网卡设置一个代价。而这个代价只用于发送端，接收端不需要考虑） ==赋予一个权重==（也可以叫做代价），==并始终选择一个权重最小的路径作为最终路由==。也就是说OSPF以每个链路上的代价为度量标准，始终选择一个总的代价最小的一条路径。如图7.14对比所示，==RIP是选择路由器个数最少的路径，而OSPF是选择总的代价较小的路径==。\nOSPF基础知识 在OSPF中，把==连接到同一个链路的路由器称作相邻路由器（Neighboring Router）==。在一个相对简单的网络结构中，例如每个路由器仅跟一个路由器相互连接时（在专线网络中，路由器之间采用PPP相连） ，相邻路由器之间可以交换路由信息。但是在一个比较复杂的网络中，例如在同一个链路中加入了以太网或FDDI等路由器时，就不需要在所有相邻的路由器之间都进行控制信息的交换，而是确定一个==指定路由器（Designated Router）==，并以它为中心交换（邻接路由器中相互交换路由信息的关系叫做邻接（Adjancency）） 路由信息即可。\n在OSPF中，根据作用的不同可以分为5种类型的包。\n通过==发送问候（HELLO）包确认是否连接==。每个路由器为了同步路由控制信息，利用==数据库描述（Database Description）包相互发送路由摘要信息和版本信息==。如果版本比较老，则首先==发出一个链路状态请求（Link State Request）包请求路由控制信息==，然后由==链路状态更新（Link State Update）包接收路由状态信息==，最后再通过==链路状态确认（Link State ACK Packet）包通知大家本地已经接收到路由控制信息==。 有了这样一个机制以后，OSPF不仅可以大大地减少网络流量，还可以达到迅速更新路由信息的目的。\nOSPF工作原理概述 链路状态更新包所要传达的消息大致分为两类：一是网络LSA（Network Link State Advertisement，网络链路状态通告） ， 另一个是路由器LSA（Router Link State Advertisement，路由器链路状态通告） 。\n==网络LSA是以网络为中心生成的信息，表示这个网络都与哪些路由器相连接。而路由器LSA是以路由器为中心生成的信息，表示这个路由器与哪些网络相连接。==\n如果这两种信息 主要采用OSPF发送，每个路由器就都可以生成一个可以表示网络结构的链路状态数据库。可以根据这个数据库、采用Dijkstra算法生成相应的路由控制表。\n将区域分层化进行细分管理 链路状态型路由协议的潜在问题在于，当网络规模越来越大时，表示链路状态的拓扑数据库就变得越来越大，路由控制信息的计算也就越困难。==OSPF为了减少计算负荷，引入了区域的概念==。\n区域是指将连接在一起的网络和主机划分成小组，使一个自治系统（AS）内可以拥有多个区域。不过具有多个区域的==自治系统必须要有一个主干区域==（主干区域的ID为0。逻辑上只允许它有1个，可实际在物理上又可以划分为多个） （Backbone Area），并且所有其他区域必须都与这个主干区域相连接。\n连接区域与主干区域的路由器称作==区域边界路由器==；而区域内部的路由器叫做==内部路由器==；只与主干区域内连接的路由器叫做==主干路由器==；与外部相连接的路由器就是==AS边界路由器==。\n每个区域内的路由器都持有==本区域网络拓扑的数据库==。然而，==关于区域之外的路径信息，只能从区域边界路由器那里获知它们的距离==。区域边界路由器也不会将区域内的链路状态信息全部原样发送给其他区域，==只会发送自己到达这些路由器的距离信息==，内部路由器所持有的网络拓扑数据库就会明显变小。\n6.BGP ==BGP（Border Gateway Protocol），边界网关协议是连接不同组织机构（或者说连接不同自治系统）的一种协议。因此，它属于外部网关协议（EGP）==。具体划分，它主要用于ISP之间相连接的部分。只有BGP、RIP和OSPF共同进行路由控制，才能够进行整个互联网的路由控制。\nBGP与AS号 ISP、区域网络等会将每个网络域编配成一个个自治系统（AS： Autonomous System）进行管理。它们==为每个自治系统分配一个16比特的AS编号==。\nBGP就是根据这个编号进行相应的路由控制。\n有了AS编号的域，就相当于有了自己一个独立的“国家”。==AS的代表可以决定AS内部的网络运营和相关决策==。与其他AS相连的时候，可 以像一位“外交官”一样签署合约再进行连接（也叫对接（Peering）） 。\nBGP是路径向量协议 ==根据BGP交换路由控制信息的路由器叫做BGP扬声器==。BGP扬声器为了在AS之间交换BGP信息，必须与所有AS建立对等的BGP连接。\nBGP中数据包送达目标网络时，会生成一个中途经过所有AS的编号列表。==这个表格也叫做AS路径信息访问列表（AS Path List）==。如果针对同一个目标地址出现多条路径时，BGP会从AS路径信息访问列表中选择一个较短的路由。\n在AS路径信息访问列表中不仅包含转发方向和距离，还涵盖了途径所有AS的编号。因此==它不是一个距离向量型协议==。此外，对网络构造仅用一元化表示，因此也==不属于链路状态型协议==。==像BGP这种根据所要经过的路径信息访问列表进行路由控制的协议属于路径向量（Path Vector）型协议==。作为距离向量型的RIP协议，因为无法检测出环路， 所以可能发生无限计数的问题（路由进入稳定状态需要一定时间、网络跳数不可超过15等限制，导致无法应用于大型的网络等问题） 。==而路径向量型由于能够检测出环路，避免了无线计数的问题，所以令网络更容易进入一个稳定的状态。同时，它还有支持策略路由（策略路由控制是指在发送数据包时，可以选择或指定所要通过的AS的意思。） 的优势==。\n7.MPLS 现如今，在转发IP数据包的过程中除了使用路由技术外，还在使用标记交换技术。路由技术基于IP地址中最长匹配原则进行转发，而==标记交换则对每个IP包都设定一个叫做“标记”的值，然后根据这个“标记”再进行转发。标记交换技术中最具代表性的当属多协议标记交换技术，即MPLS（Multi Protocol Label Switching）==。\n由于==基于标记的转发通常无法在路由器上进行==，所以MPLS也就无法被整个互联网采用。如图7.22所示，它的转发处理方式甚至与IP网也有所不同。\nMPLS的网络基本动作 MPLS网络中实现MPLS功能的路由器叫做==标记交换路由器（LSR，Label Switching Router）==。特别是与外部网路连接的那部分LSR叫做==标记边缘路由器（LER，Label Edge Router）==。MPLS正是在LER上对数据包进行追加标记和删除标记的操作。\n如图7.23展示了数据从以太网的IP网开始经过MPLS网再发送给其他IP网的整个转发过程。数据包在进入MPLS时，在其IP首部的前面被追加了32比特的垫片头（其中包含20比特的标记值）（有时也可能会被追加多个垫片头） 。MPLS网络内，根据垫片头中的标记进一步进行转发。当数据离开MPLS时，垫片头就被去除。在此我们称==附加标记转发的动作为Push，替换标记转发的动作为Swap，去掉标记转发的动作为Pop==。\nMPLS中目标地址和数据包（它们被称作FEC（Forward-ing Equivalence Class），是指具有相同特性的报文） 都要通过由标记决定的同一个路径，这个路径叫做==标记交换路径（LSP，Label Switch Path）==。LSP又可以划分为一对一连接的点对点LSP，和一对多绑定的合并LSP两类。\nMPLS的优点 MPLS的优势可归纳为两点。==第一个是转发速度快==。通常，路由器转发IP数据包时，首先要对目标地址和路由控制表中可变长的网络地址进行比较，然后从中选出最长匹配的路径才能进行转发。MPLS则不然。==它使用固定长度的标记信息，使得处理更加简单，可以通过高速的硬件实现转发==（现在的路由器也更趋向于硬件化） 。此外，相比互联网中的主干路由器需要保存大量路由表才能进行处理的现状，==MPLS只需要设置必要的几处信息即可，所要处理的数据量也大幅度减少。==而且除了IPv4、IPv6之外，针对其他协议，MPLS仍然可以实现高速转发。\n第二个优势在于==利用标记生成虚拟的路径，并在它的上面实现IP等数据包的通信==。基于这些特点，被称之为“尽力而为”的IP网也可以提供基于MPLS的通信质量控制、带宽保证和VPN等功能。\n第8章 应用协议 1.远程登录 实现从自己的本地计算机登录到网络另一端计算功能的应用就叫做远程登录。\n远程登录主要使用TELNET和SSH（Secure SHell） 两种协议。\nTELNET\nTELNET利用TCP的一条连接，通过这一条连接向主机发送文字命令并在主机上执行。\nTELNET客户端通常与目标主机的23号端口建立连接，并与监听这个端口的服务端程序telnetd进行交互。当然，也可以与其他的TCP端口号连接，只要在该端口上有监听程序能够处理telnet请求即可。\n在一般的telnet命令：\ntelnet主机名 TCP端口号TCP端口号为21时可以连接到FTP（8.3节）应用，为25时可以连接到SMTP（8.4.4节），为80时可连接到HTTP（8.5节），为110时可连接到POP3（8.4.5节）。如此看来，每个服务器都有相应的端口号在等待连接。\n因此，以下两个命令可以视为相同：\nftp 主机名 telnet 主机名 21 SSH\nSSH是加密的远程登录系统。\n2.文件传输 FTP的工作机制概要\nFTP是通过怎样的机制才得以实现文件传输的呢？\n==它使用两条TCP连接：一条用来控制，另一条用于数据（文件）的传输。==\n==用于控制的TCP连接主要在FTP的控制部分使用。==例如登录用户名和密码的验证、发送文件的名称、发送方式的设置。利用这个连接，可以通过ASCII码字符串发送请求和接收应答。==在这个连接上无法发送数据，数据需要一个专门的TCP进行连接==。\n==FTP控制用的连接使用的是TCP21号端口。==在TCP21号端口上进行文件GET（RETR）、PUT（STOR）、以及文件一览（LIST）等操作时，==每次都会建立一个用于数据传输的TCP连接==。数据的传输和文件一览表的传输正是在这个新建的连接上进行。当数据传送完毕之后，传输数据的这条连接也会被断开，然后会在控制用的连接上继续进行命令或应答的处理。\n==数据传输用的TCP连接通常使用端口20。==不过可以用PORT命令修改为其他的值。最近，出于安全的考虑，普遍在数据传输用的端口号中使用随机数进行分配。\n3.电子邮件 电子邮件的工作机制\n提供电子邮件服务的协议叫做==SMTP（Simple Mail Transfer Protocol）==。SMTP为了实现高效发送邮件内容，在其传输层使用了TCP协议。\n在技术上改变了以往直接在发送端与接收端主机之间建立TCP连接的机制，而引进了一种==一直会连接电源的邮件服务器。==\n发送和接收端通过邮件服务器进行收发邮件。接收端从邮件服务器接收邮件时使用POP3（Post Office Protocol）协议。\n==电子邮件的机制由3部分组成，它们分别是邮件地址，数据格式以及发送协议。==\n邮件地址 使用电子邮件时需要拥有的地址叫做邮件地址。它就相当于通信地址和姓名。互联网中电子邮件地址的格式如下：\n名称@通信地址 例如，master@tcpip.kusa.ac.jp中的master为名称，tcpip.kusa.ac.jp为地址。电子邮件的地址和域名的构造相同。此处，kusa.ac.jp表示域名，tcpip则表示master接收邮件的主机名称或为发送邮件所用的子网名称。\n现在，电子邮件的发送地址由DNS进行管理。DNS中注册有邮件地址及其作为发送地址时对应的邮件服务器的域名。这些映射信息被称作==MX记录==。例如，kusa.ac.jp的MX（Mail Exchange）记录中指定了mailserver.kusa.ac.jp。于是任何==发给以kusa.ac.jp结尾的地址的邮件都将被发送到mailserver.kusa.ac.jp服务器==。就这样，根据MX记录中指定的邮件服务器，可以管理不同邮件地址与特定邮件服务器之间的映射关系。\nMIME 很长一段时间里，互联网中的电子邮件只能处理文本格式的（由文字组成的信息。过去的电子邮件，就日本来说人们只能发送7比特 JIS编码的信息。） 邮件。不过现在，电子邮件所能发送的数据类型已被扩展到==MIME（Multipurpose Internet Mail Extensions，通用互联网邮件扩充==，广泛用于互联网并极大地扩展了数据格式，还可以用于WWW和NetNews中） ，可以发送静态图像、动画、声音、程序等各种形式的数据。鉴于MIME规定了应用消息的格式，因此==在OSI参考模型中它相当于第6层表示层==。\nSMTP SMTP是发送电子邮件的协议。它使用的是TCP的25号端口。SMTP建立一个TCP连接以后，在这个连接上进行控制和应答以及数据的发送。客户端以文本的形式发出请求，服务端返回一个3位数字的应答。\nPOP 前一节提到的SMTP是发送邮件的协议，即，==SMTP是想要发送邮件的计算机向接收邮件的计算机发送电子邮件的一种协议==。在以UNIX工作站为主的互联网初期，这种机制没有什么问题，但是后来用个人电脑连接互联网的环境中就出现很多不便之处。\n个人电脑不可能长时间处于开机状态。只有用户在使用时才会开机。在这种情况下，人们希望一开机就能接收到邮件。然而SMTP没有这种处理机制。==SMTP的一个不利之处就在于它支持的是发送端主机的行为，而不是根据接收端的请求发送邮件==。\n为了解决这个问题，就引入了POP协议。如图8.14所示，该协议是==一种用于接收电子邮件的协议==。==发送端的邮件根据SMTP协议将被转发给一直处于插电状态的POP服务器。客户端再根据POP协议从POP服务器接收对方发来的邮件。==在这个过程中，为了防止他人盗窃邮件内容，还要进行用户验证。\nIMAP IMAP（Internet Message Access Protocol） 与POP类似，也是接收电子邮件的协议。==在POP中邮件由客户端进行管理，而在IMAP中邮件则由服务器进行管理==。使用IMAP时，可以不必从服务器上下载所有的邮件也可以阅读。由于IMAP是在服务器端处理MIME信息，所以它可以实现当某一封邮件含有10个附件时“只下载其中的第7个附件”的功能（在POP中无法下载某个特定的附件。因此想要确认附件时就不得不下载邮件中所有的附件） 。\n有了IMAP人们就可以通过个人电脑、公司的电脑、笔记本电脑以及智能手机等连接到IMAP服务器以后进行收发邮件。由此，在公司下载的电子邮件就不必在笔记本电脑和智能手机上转来转去（不过笔记本电脑和智能手机必须能够连上IMAP服务器才行） 。IMAP确实为使用多种异构终端的人们提供了非常便利的环境。\n4.WWW ==万维网（WWW，World Wide Web）==是将互联网中的信息以超文本（超文本用以显示文本及与文本相关的内容） 形式展现的系统。也叫做Web。可以显示WWW信息的客户端软件叫做Web浏览器（Web浏览器（Web Browser），有时也简称为浏览器） 。\nWWW定义了3个重要的概念，它们分别是访问信息的手段与位置==（URI，Uniform Resource Identifier）==、信息的表现形式==（HTML， HyperText Markup Language）==以及信息转发==（HTTP，HyperText Transfer Protocol）==等操作。\nURI URI是==Uniform Resource Identifier==的缩写，用于标识资源。URI是一种可以用于WWW之外的高效的识别码，它被用于主页地址（也被叫做URL（Uniform Resource Locator））、电子邮件、电话号码等各种组合中。\n==URI所表示的组合叫方案（Scheme）==\n在众多URI的Scheme中WWW主要用其中的==http和https表示Web页的位置和访问Web页的方法==。\nURI的http方案的具体格式如下：\nhttp://主机名/路径\nhttp://主机名：端口号/路径\nhttp://主机名：端口号/路径？访问内容#部分信息\nHTML HTMP是记述Web页的一种语言（数据格式）。它可以指定浏览器中显示的文字、文字的大小和颜色。此外，不仅可以对图像或动画进行相关设置，还可以设置音频内容。\n如果把它对应到OSI参考模型，那么可以认为HTML属于WWW的==表示层==（HTML不仅用于WWW，有时还用于电子邮件）\nHTTP 当用户在浏览器的地址栏里输入所要访问Web页的URI以后，HTTP的处理即会开始。HTTP中默认使用80端口。它的工作机制，首先是客户端向服务器的80端口建立一个TCP连接，然后在这个TCP连接上进行请求和应答以及数据报文的发送。\nJavaScript、CGI、Cookie 5.网络管理 SNMP SNMP中管理端叫做管理器（Manager，网络监控终端），被管理端叫做代理（路由器、交换机等）（SNMPv3中管理器和代理都叫做实体 （Entity）） 。决定管理器与代理之间的通信中所要交互信息的正是SNMP。SNMP中如果将MIB（==SNMP中交互的信息是MIB（Management Information Base）==。MIB是在树形结构的数据库中为每个项目附加编号的一种信息结构） 看做代理所管理的信息在数据库中的值，那么它可以新增一个值。\n第9章 网络安全 1.网络安全构成要素 防火墙 IDS（入侵检测系统） 反病毒/个人防火墙 2.加密技术基础 为了防止信息的泄露、实现机密数据的传输，出现了各种各样的加密技术。加密技术分布与OSI参考模型的各个阶层一样，相互协同保证通信。\n对称密码体制与公钥密码体制 加密是指利用某个值（密钥）对明文的数据通过一定的算法变换成加密（密文）数据的过程。它的逆反过程叫做解密。\n==加密和解密使用相同的密钥叫做对称加密方式。反之，如果在加密和解密过程中分别使用不同的密钥（公钥和私钥）则叫做公钥加密方式。==\n对称加密方式包括AES（Advanced Encryption Standard）、 DES（Data Encryption Standard）等加密标准，而公钥加密方法中包括RSA、DH（Diffie-Hellman）、椭圆曲线等加密算法。\n身份认证技术 3.安全协议 IPsec与VPN 以前，为了防止信息泄露，对机密数据的传输一般不使用互联网等公共网络（Public Network），而是使用由专线连接的私有网络（Private Network）。从而在物理上杜绝了窃听和篡改数据的可能。然而，专线的造价太高是一个不可回避的问题。\n为了解决此类问题，人们想出了在互联网上构造一个==虚拟的私有网络==。即VPN（Virtual Private Network，虚拟专用网） 。互联网中采用加密和认证技术可以达到“即使读取到数据也无法读懂”、“检查是否被篡改”等功效。VPN正是一种利用这两种技术打造的网络。\n在构建VPN时，最常被使用的是==IPsec==。它是指在IP首部的后面追加==“封装安全有效载荷”（ESP，Encapsulating Security Payload。）和“认证首部”（AH，Authentication Header。）== ，从而对此后的数据进行加密，不被盗取者轻易解读。\n==在发包的时候附加上述两个首部==，可以在收包时根据首部对数据进行解密，恢复成原始数据。由此，加密后的数据不再被轻易破解，即使在途中被篡改，也能够被及时检测。\n基于这些功能，VPN的使用者就可以不必设防地使用一个安全的网络环境。\nTLS/SSL与HTTPS Web中可以通过TLS/SSL（Transport Layer Security/Secure Sockets Layer。由网景公司最早提出的名称叫SSL，标准化以后被称作TLS。有时两者统称为SSL） 对HTTP通信进行加密。==使用TLS/SSL的HTTP通信叫做HTTPS通信==。==HTTPS中采用对称加密方式。而在发送其公共密钥时采用的则是公钥加密方式==（对称加密虽然速度快，但是密钥管理是巨大的挑战。公钥加密密钥管理相对简单，但是处理速度非常慢。TLS/SSL将两者进行取长补短令加密过程达到了极好的效果。由于谁都可以发送公钥，使得密钥管理更为简单） 。\n确认公钥是否正确主要使用认证中心（CA（Certificate Authority） ）签发的证书，而主要的认证中心的信息已经嵌入到浏览器的出厂设置中。如果Web浏览器中尚未加入某个认证中心，那么会在页面上提示一个警告信息。此时，判断认证中心合法与否就要由用户自己决定了。\nIEEE802.1X IEEE802.1X是==为了能够接入LAN交换机和无线LAN接入点而对用户进行认证的技术==。并且它只允许被认可的设备才能访问网络。虽然它是一个提供数据链路层控制的规范，但是与TCP/IP关系紧密。一般，由客户端终端、AP（无线基站）或2层交换机以及认证服务器组成。\n",
  "wordCount" : "51163",
  "inLanguage": "zh",
  "datePublished": "2022-05-16T00:00:00Z",
  "dateModified": "2022-05-16T00:00:00Z",
  "author":[{
    "@type": "Person",
    "name": "chance7bin"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://chance7bin.github.io/posts/basic/network/%E5%9B%BE%E8%A7%A3tcpip/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Binb's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://chance7bin.github.io/img/%E7%BE%8E%E9%98%9F.jpg"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://chance7bin.github.io/" accesskey="h" title="Binb&#39;s Blog (Alt + H)">
                <img src="https://chance7bin.github.io/img/%E7%BE%8E%E9%98%9F.jpg" alt="" aria-label="logo"
                    height="35">Binb&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://chance7bin.github.io/search" title="🔍搜索 (Alt &#43; /)" accesskey=/>
                    <span>🔍搜索</span>
                </a>
            </li>
            <li>
                <a href="https://chance7bin.github.io/" title="🏠 主页">
                    <span>🏠 主页</span>
                </a>
            </li>
            <li>
                <a href="https://chance7bin.github.io/archives/" title="⏱️ 时间轴">
                    <span>⏱️ 时间轴</span>
                </a>
            </li>
            <li>
                <a href="https://chance7bin.github.io/posts" title="📚 文章">
                    <span>📚 文章</span>
                </a>
            </li>
            <li>
                <a href="https://chance7bin.github.io/tags" title="🔖 标签">
                    <span>🔖 标签</span>
                </a>
            </li>
            <li>
                <a href="https://github.com/chance7bin" title="GitHub">
                    <span>GitHub</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://chance7bin.github.io/">🏠 主页</a>&nbsp;»&nbsp;<a href="https://chance7bin.github.io/posts/">📚 文章</a>&nbsp;»&nbsp;<a href="https://chance7bin.github.io/posts/basic/">📕 计算机基础</a>&nbsp;»&nbsp;<a href="https://chance7bin.github.io/posts/basic/network/">计算机网络</a></div>
    <h1 class="post-title">
      图解TCPIP
    </h1>
    <div class="post-meta">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css">


<style>
    i[id*="post_meta_style"] {
        display: flex;
        align-items: center;
        margin: 0 0 10px 0;
    }

    .parent-post-meta {
        display: flex;
        flex-wrap: wrap;
        opacity: 0.8;
    }
</style>

<span class="parent-post-meta">
    <span id="post_meta_style_1">
        <span class="fa fa-calendar-check-o"></span>
        <span>2022-05-16
            &nbsp;&nbsp;
        </span>
    </span>
    
    
    
    
    
    
    
    <span id="post_meta_style_3">
        <span class="fa fa-file-word-o"></span>
        <span>51163字
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_4">
        <span class="fa fa-clock-o"></span>
        <span>103分钟
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_5">
        <span class="fa fa-user-o"></span>
        <span>chance7bin
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_6">
        <span class="fa fa-tags" style="opacity: 0.8"></span>
        <span>
            <span class="post-tags-meta">
                <a href="https://chance7bin.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="color: var(--secondary)!important;">计算机网络</a>
                &nbsp;<a href="https://chance7bin.github.io/tags/tcpip/" style="color: var(--secondary)!important;">TCPIP</a>
            </span>
        </span>
    </span>

    
</span>


      
      
      
      
      
      
      
          
          
          
              
              
              
              
          
      
    </div>
  </header>
   <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">目录</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#%e5%86%99%e5%9c%a8%e5%89%8d%e9%9d%a2" aria-label="写在前面">写在前面</a></li>
                    <li>
                        <a href="#%e7%ac%ac1%e7%ab%a0-%e7%bd%91%e7%bb%9c%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86" aria-label="第1章 网络基础知识">第1章 网络基础知识</a><ul>
                            
                    <li>
                        <a href="#1%e5%8d%8f%e8%ae%ae" aria-label="1.协议">1.协议</a></li>
                    <li>
                        <a href="#2%e5%8d%8f%e8%ae%ae%e7%9a%84%e5%88%86%e5%b1%82" aria-label="2.协议的分层">2.协议的分层</a><ul>
                            
                    <li>
                        <a href="#osi%e5%8d%8f%e8%ae%ae%e4%b8%8eosi%e5%8f%82%e8%80%83%e6%a8%a1%e5%9e%8b" aria-label="OSI协议与OSI参考模型">OSI协议与OSI参考模型</a></li>
                    <li>
                        <a href="#osi%e5%8f%82%e8%80%83%e6%a8%a1%e5%9e%8b%e4%b8%ad%e5%90%84%e4%b8%aa%e5%88%86%e5%b1%82%e7%9a%84%e4%bd%9c%e7%94%a8" aria-label="OSI参考模型中各个分层的作用">OSI参考模型中各个分层的作用</a></li></ul>
                    </li>
                    <li>
                        <a href="#3%e4%bc%a0%e8%be%93%e6%96%b9%e5%bc%8f%e7%9a%84%e5%88%86%e7%b1%bb" aria-label="3.传输方式的分类">3.传输方式的分类</a><ul>
                            
                    <li>
                        <a href="#%e9%9d%a2%e5%90%91%e6%9c%89%e8%bf%9e%e6%8e%a5%e5%9e%8b%e4%b8%8e%e9%9d%a2%e5%90%91%e6%97%a0%e8%bf%9e%e6%8e%a5%e5%9e%8b" aria-label="面向有连接型与面向无连接型">面向有连接型与面向无连接型</a></li>
                    <li>
                        <a href="#%e7%94%b5%e8%b7%af%e4%ba%a4%e6%8d%a2%e4%b8%8e%e5%88%86%e7%bb%84%e4%ba%a4%e6%8d%a2" aria-label="电路交换与分组交换">电路交换与分组交换</a></li>
                    <li>
                        <a href="#%e6%a0%b9%e6%8d%ae%e6%8e%a5%e6%94%b6%e7%ab%af%e6%95%b0%e9%87%8f%e5%88%86%e7%b1%bb" aria-label="根据接收端数量分类">根据接收端数量分类</a></li></ul>
                    </li>
                    <li>
                        <a href="#4%e5%9c%b0%e5%9d%80" aria-label="4.地址">4.地址</a></li>
                    <li>
                        <a href="#5%e7%bd%91%e7%bb%9c%e7%9a%84%e6%9e%84%e6%88%90%e8%a6%81%e7%b4%a0" aria-label="5.网络的构成要素">5.网络的构成要素</a></li>
                    <li>
                        <a href="#6%e7%8e%b0%e4%bb%a3%e7%bd%91%e7%bb%9c%e5%ae%9e%e6%80%81" aria-label="6.现代网络实态">6.现代网络实态</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e7%ac%ac2%e7%ab%a0-tcpip%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86" aria-label="第2章 TCP/IP基础知识">第2章 TCP/IP基础知识</a><ul>
                            
                    <li>
                        <a href="#1tcpip%e7%9a%84%e6%a0%87%e5%87%86%e5%8c%96" aria-label="1.TCP/IP的标准化">1.<strong>TCP/IP</strong>的标准化</a><ul>
                            
                    <li>
                        <a href="#tcpip%e7%9a%84%e5%85%b7%e4%bd%93%e5%90%ab%e4%b9%89" aria-label="TCP/IP的具体含义"><strong>TCP/IP</strong>的具体含义</a></li>
                    <li>
                        <a href="#tcpip%e8%a7%84%e8%8c%83rfc" aria-label="TCP/IP规范**——RFC**"><strong>TCP/IP</strong>规范**——RFC**</a></li></ul>
                    </li>
                    <li>
                        <a href="#2%e4%ba%92%e8%81%94%e7%bd%91%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86" aria-label="2.互联网基础知识">2.互联网基础知识</a><ul>
                            
                    <li>
                        <a href="#%e4%ba%92%e8%81%94%e7%bd%91%e5%ae%9a%e4%b9%89" aria-label="互联网定义">互联网定义</a></li>
                    <li>
                        <a href="#%e4%ba%92%e8%81%94%e7%bd%91%e4%b8%8etcpip%e7%9a%84%e5%85%b3%e7%b3%bb" aria-label="互联网与TCP/IP的关系"><strong>互联网与TCP/IP的关系</strong></a></li>
                    <li>
                        <a href="#%e4%ba%92%e8%81%94%e7%bd%91%e7%9a%84%e7%bb%93%e6%9e%84" aria-label="互联网的结构">互联网的结构</a></li></ul>
                    </li>
                    <li>
                        <a href="#3tcpip%e5%8d%8f%e8%ae%ae%e5%88%86%e5%b1%82%e6%a8%a1%e5%9e%8b" aria-label="3.TCP/IP协议分层模型">3.<strong>TCP/IP</strong>协议分层模型</a><ul>
                            
                    <li>
                        <a href="#tcpip%e4%b8%8eosi%e5%8f%82%e8%80%83%e6%a8%a1%e5%9e%8b" aria-label="TCP/IP与OSI参考模型"><strong>TCP/IP</strong>与<strong>OSI</strong>参考模型</a></li>
                    <li>
                        <a href="#%e7%a1%ac%e4%bb%b6%e7%89%a9%e7%90%86%e5%b1%82" aria-label="硬件（物理层）">硬件（物理层）</a></li>
                    <li>
                        <a href="#%e7%bd%91%e7%bb%9c%e6%8e%a5%e5%8f%a3%e5%b1%82%e6%95%b0%e6%8d%ae%e9%93%be%e8%b7%af%e5%b1%82" aria-label="网络接口层（数据链路层）">网络接口层（数据链路层）</a></li>
                    <li>
                        <a href="#%e4%ba%92%e8%81%94%e7%bd%91%e5%b1%82%e7%bd%91%e7%bb%9c%e5%b1%82" aria-label="互联网层（网络层）">互联网层（网络层）</a></li>
                    <li>
                        <a href="#%e4%bc%a0%e8%be%93%e5%b1%82" aria-label="传输层">传输层</a></li>
                    <li>
                        <a href="#%e5%ba%94%e7%94%a8%e5%b1%82%e4%bc%9a%e8%af%9d%e5%b1%82%e4%bb%a5%e4%b8%8a%e7%9a%84%e5%88%86%e5%b1%82" aria-label="应用层（会话层以上的分层）">应用层（会话层以上的分层）</a></li></ul>
                    </li>
                    <li>
                        <a href="#4tcpip%e5%88%86%e5%b1%82%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%80%9a%e4%bf%a1%e7%a4%ba%e4%be%8b" aria-label="4.TCP/IP分层模型与通信示例">4.<strong>TCP/IP</strong>分层模型与通信示例</a><ul>
                            
                    <li>
                        <a href="#%e6%95%b0%e6%8d%ae%e5%8c%85%e9%a6%96%e9%83%a8" aria-label="数据包首部">数据包首部</a></li>
                    <li>
                        <a href="#%e5%8f%91%e9%80%81%e6%95%b0%e6%8d%ae%e5%8c%85" aria-label="发送数据包">发送数据包</a></li>
                    <li>
                        <a href="#%e7%bb%8f%e8%bf%87%e6%95%b0%e6%8d%ae%e9%93%be%e8%b7%af%e7%9a%84%e5%8c%85" aria-label="经过数据链路的包">经过数据链路的包</a></li>
                    <li>
                        <a href="#%e6%95%b0%e6%8d%ae%e5%8c%85%e6%8e%a5%e6%94%b6%e5%a4%84%e7%90%86" aria-label="数据包接收处理">数据包接收处理</a></li></ul>
                    </li></ul>
                    </li>
                    <li>
                        <a href="#%e7%ac%ac3%e7%ab%a0-%e6%95%b0%e6%8d%ae%e9%93%be%e8%b7%af" aria-label="第3章 数据链路">第3章 数据链路</a><ul>
                            
                    <li>
                        <a href="#1%e6%95%b0%e6%8d%ae%e9%93%be%e8%b7%af%e7%9a%84%e4%bd%9c%e7%94%a8" aria-label="1.数据链路的作用">1.数据链路的作用</a></li>
                    <li>
                        <a href="#2%e6%95%b0%e6%8d%ae%e9%93%be%e8%b7%af%e7%9b%b8%e5%85%b3%e6%8a%80%e6%9c%af" aria-label="2.数据链路相关技术">2.数据链路相关技术</a><ul>
                            
                    <li>
                        <a href="#mac%e5%9c%b0%e5%9d%80" aria-label="MAC地址"><strong>MAC</strong>地址</a></li>
                    <li>
                        <a href="#%e5%85%b1%e4%ba%ab%e4%bb%8b%e8%b4%a8%e5%9e%8b%e7%bd%91%e7%bb%9c" aria-label="共享介质型网络">共享介质型网络</a></li>
                    <li>
                        <a href="#%e9%9d%9e%e5%85%b1%e4%ba%ab%e4%bb%8b%e8%b4%a8%e7%bd%91%e7%bb%9c" aria-label="非共享介质网络">非共享介质网络</a></li>
                    <li>
                        <a href="#%e6%a0%b9%e6%8d%aemac%e5%9c%b0%e5%9d%80%e8%bd%ac%e5%8f%91" aria-label="根据MAC地址转发">根据<strong>MAC</strong>地址转发</a></li>
                    <li>
                        <a href="#vlan" aria-label="VLAN"><strong>VLAN</strong></a></li></ul>
                    </li>
                    <li>
                        <a href="#3%e4%bb%a5%e5%a4%aa%e7%bd%91" aria-label="3.以太网">3.以太网</a><ul>
                            
                    <li>
                        <a href="#%e4%bb%a5%e5%a4%aa%e7%bd%91%e8%bf%9e%e6%8e%a5%e5%bd%a2%e5%bc%8f" aria-label="以太网连接形式"><strong>以太网连接形式</strong></a></li>
                    <li>
                        <a href="#%e4%bb%a5%e5%a4%aa%e7%bd%91%e5%b8%a7%e6%a0%bc%e5%bc%8f" aria-label="以太网帧格式">以太网帧格式</a></li></ul>
                    </li>
                    <li>
                        <a href="#4%e6%97%a0%e7%ba%bf%e9%80%9a%e4%bf%a1" aria-label="4.无线通信">4.无线通信</a></li>
                    <li>
                        <a href="#5ppp" aria-label="5.PPP">5.<strong>PPP</strong></a></li>
                    <li>
                        <a href="#6%e5%85%b6%e4%bb%96%e6%95%b0%e6%8d%ae%e9%93%be%e8%b7%af" aria-label="6.其他数据链路">6.其他数据链路</a></li>
                    <li>
                        <a href="#7%e5%85%ac%e5%85%b1%e7%bd%91%e7%bb%9c" aria-label="7.公共网络">7.公共网络</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e7%ac%ac4%e7%ab%a0-ip%e5%8d%8f%e8%ae%ae" aria-label="第4章 IP协议">第4章 IP协议</a><ul>
                            
                    <li>
                        <a href="#1ip%e5%8d%b3%e7%bd%91%e9%99%85%e5%8d%8f%e8%ae%ae" aria-label="1.IP即网际协议">1.<strong>IP</strong>即网际协议</a><ul>
                            
                    <li>
                        <a href="#%e7%bd%91%e7%bb%9c%e5%b1%82%e4%b8%8e%e6%95%b0%e6%8d%ae%e9%93%be%e8%b7%af%e5%b1%82%e7%9a%84%e5%85%b3%e7%b3%bb" aria-label="网络层与数据链路层的关系">网络层与数据链路层的关系</a></li></ul>
                    </li>
                    <li>
                        <a href="#2ip%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86" aria-label="2.IP基础知识">2.<strong>IP</strong>基础知识</a></li>
                    <li>
                        <a href="#3ip%e5%9c%b0%e5%9d%80%e7%9a%84%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86" aria-label="3.IP地址的基础知识">3.<strong>IP</strong>地址的基础知识</a><ul>
                            
                    <li>
                        <a href="#ip%e5%9c%b0%e5%9d%80%e7%9a%84%e5%88%86%e7%b1%bb" aria-label="IP地址的分类"><strong>IP地址的分类</strong></a></li>
                    <li>
                        <a href="#%e5%ad%90%e7%bd%91%e6%8e%a9%e7%a0%81" aria-label="子网掩码">子网掩码</a></li>
                    <li>
                        <a href="#cidr%e4%b8%8evlsm" aria-label="CIDR与VLSM"><strong>CIDR</strong>与<strong>VLSM</strong></a></li>
                    <li>
                        <a href="#%e5%85%a8%e5%b1%80%e5%9c%b0%e5%9d%80%e4%b8%8e%e7%a7%81%e6%9c%89%e5%9c%b0%e5%9d%80" aria-label="全局地址与私有地址">全局地址与私有地址</a></li></ul>
                    </li>
                    <li>
                        <a href="#4%e8%b7%af%e7%94%b1%e6%8e%a7%e5%88%b6" aria-label="4.路由控制">4.路由控制</a></li>
                    <li>
                        <a href="#5ip%e5%88%86%e5%89%b2%e5%a4%84%e7%90%86%e4%b8%8e%e5%86%8d%e6%9e%84%e6%88%90%e5%a4%84%e7%90%86" aria-label="5.IP分割处理与再构成处理">5.<strong>IP</strong>分割处理与再构成处理</a></li>
                    <li>
                        <a href="#6ipv6" aria-label="6.IPv6">6.<strong>IPv6</strong></a><ul>
                            
                    <li>
                        <a href="#ipv6%e7%9a%84%e7%89%b9%e7%82%b9" aria-label="IPv6的特点"><strong>IPv6</strong>的特点</a></li>
                    <li>
                        <a href="#ipv6%e4%b8%adip%e5%9c%b0%e5%9d%80%e7%9a%84%e6%a0%87%e8%ae%b0%e6%96%b9%e6%b3%95" aria-label="IPv6中IP地址的标记方法"><strong>IPv6</strong>中<strong>IP</strong>地址的标记方法</a></li>
                    <li>
                        <a href="#ipv6%e5%9c%b0%e5%9d%80%e7%9a%84%e7%bb%93%e6%9e%84" aria-label="IPv6地址的结构"><strong>IPv6</strong>地址的结构</a></li></ul>
                    </li>
                    <li>
                        <a href="#7ipv4%e9%a6%96%e9%83%a8%e4%bb%a5%e5%8f%8aipv6%e9%a6%96%e9%83%a8" aria-label="7.IPv4首部以及IPv6首部">7.IPv4首部以及IPv6首部</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e7%ac%ac5%e7%ab%a0-ip%e5%8d%8f%e8%ae%ae%e7%9b%b8%e5%85%b3%e6%8a%80%e6%9c%af" aria-label="第5章 IP协议相关技术">第5章 IP协议相关技术</a><ul>
                            
                    <li>
                        <a href="#1dns" aria-label="1.DNS">1.DNS</a></li>
                    <li>
                        <a href="#2arp" aria-label="2.ARP">2.<strong>ARP</strong></a></li>
                    <li>
                        <a href="#3icmp" aria-label="3.ICMP">3.<strong>ICMP</strong></a><ul>
                            
                    <li>
                        <a href="#%e4%b8%bb%e8%a6%81%e7%9a%84icmp%e6%b6%88%e6%81%af" aria-label="主要的ICMP消息">主要的<strong>ICMP</strong>消息</a></li>
                    <li>
                        <a href="#icmpv6" aria-label="ICMPv6"><strong>ICMPv6</strong></a></li></ul>
                    </li>
                    <li>
                        <a href="#4dhcp" aria-label="4.DHCP">4.<strong>DHCP</strong></a><ul>
                            
                    <li>
                        <a href="#dhcp%e7%9a%84%e5%b7%a5%e4%bd%9c%e6%9c%ba%e5%88%b6" aria-label="DHCP的工作机制"><strong>DHCP</strong>的工作机制</a></li>
                    <li>
                        <a href="#dhcp%e4%b8%ad%e7%bb%a7%e4%bb%a3%e7%90%86" aria-label="DHCP中继代理"><strong>DHCP</strong>中继代理</a></li></ul>
                    </li>
                    <li>
                        <a href="#5nat" aria-label="5.NAT">5.<strong>NAT</strong></a><ul>
                            
                    <li>
                        <a href="#nat%e7%9a%84%e5%b7%a5%e4%bd%9c%e6%9c%ba%e5%88%b6" aria-label="NAT的工作机制"><strong>NAT</strong>的工作机制</a></li>
                    <li>
                        <a href="#nat-ptnapt-pt" aria-label="NAT-PT（NAPT-PT）"><strong>NAT-PT</strong>（<strong>NAPT-PT</strong>）</a></li></ul>
                    </li>
                    <li>
                        <a href="#6ip%e9%9a%a7%e9%81%93" aria-label="6.IP隧道">6.<strong>IP</strong>隧道</a></li>
                    <li>
                        <a href="#7ip%e7%9b%b8%e5%85%b3%e6%8a%80%e6%9c%af" aria-label="7.IP相关技术">7.IP相关技术</a><ul>
                            
                    <li>
                        <a href="#ip%e4%bb%bb%e6%92%ad" aria-label="IP任播"><strong>IP</strong>任播</a></li></ul>
                    </li></ul>
                    </li>
                    <li>
                        <a href="#%e7%ac%ac6%e7%ab%a0-tcp%e4%b8%8eudp" aria-label="第6章 TCP与UDP">第6章 TCP与UDP</a><ul>
                            
                    <li>
                        <a href="#1%e7%ab%af%e5%8f%a3%e5%8f%b7" aria-label="1.端口号">1.端口号</a></li>
                    <li>
                        <a href="#2udp" aria-label="2.UDP">2.<strong>UDP</strong></a></li>
                    <li>
                        <a href="#3tcp" aria-label="3.TCP">3.TCP</a><ul>
                            
                    <li>
                        <a href="#%e9%80%9a%e8%bf%87%e5%ba%8f%e5%88%97%e5%8f%b7%e4%b8%8e%e7%a1%ae%e8%ae%a4%e5%ba%94%e7%ad%94%e6%8f%90%e9%ab%98%e5%8f%af%e9%9d%a0%e6%80%a7" aria-label="通过序列号与确认应答提高可靠性"><strong>通过序列号与确认应答提高可靠性</strong></a></li>
                    <li>
                        <a href="#%e9%87%8d%e5%8f%91%e8%b6%85%e6%97%b6%e5%a6%82%e4%bd%95%e7%a1%ae%e5%ae%9a" aria-label="重发超时如何确定"><strong>重发超时如何确定</strong></a></li>
                    <li>
                        <a href="#%e8%bf%9e%e6%8e%a5%e7%ae%a1%e7%90%86" aria-label="连接管理">连接管理</a></li>
                    <li>
                        <a href="#tcp%e4%bb%a5%e6%ae%b5%e4%b8%ba%e5%8d%95%e4%bd%8d%e5%8f%91%e9%80%81%e6%95%b0%e6%8d%ae" aria-label="TCP以段为单位发送数据"><strong>TCP以段为单位发送数据</strong></a></li>
                    <li>
                        <a href="#%e5%88%a9%e7%94%a8%e7%aa%97%e5%8f%a3%e6%8e%a7%e5%88%b6%e6%8f%90%e9%ab%98%e9%80%9f%e5%ba%a6" aria-label="利用窗口控制提高速度">利用窗口控制提高速度</a></li>
                    <li>
                        <a href="#%e7%aa%97%e5%8f%a3%e6%8e%a7%e5%88%b6%e4%b8%8e%e9%87%8d%e5%8f%91%e6%8e%a7%e5%88%b6" aria-label="窗口控制与重发控制">窗口控制与重发控制</a></li>
                    <li>
                        <a href="#%e6%b5%81%e6%8e%a7%e5%88%b6" aria-label="流控制">流控制</a></li>
                    <li>
                        <a href="#%e6%8b%a5%e5%a1%9e%e6%8e%a7%e5%88%b6" aria-label="拥塞控制">拥塞控制</a></li>
                    <li>
                        <a href="#%e6%8f%90%e9%ab%98%e7%bd%91%e7%bb%9c%e5%88%a9%e7%94%a8%e7%8e%87%e7%9a%84%e8%a7%84%e8%8c%83" aria-label="提高网络利用率的规范">提高网络利用率的规范</a></li></ul>
                    </li>
                    <li>
                        <a href="#4%e5%85%b6%e4%bb%96%e4%bc%a0%e8%be%93%e5%b1%82%e5%8d%8f%e8%ae%ae" aria-label="4.其他传输层协议">4.其他传输层协议</a></li>
                    <li>
                        <a href="#5udp%e9%a6%96%e9%83%a8%e7%9a%84%e6%a0%bc%e5%bc%8f" aria-label="5.UDP首部的格式">5.<strong>UDP</strong>首部的格式</a></li>
                    <li>
                        <a href="#6tcp%e9%a6%96%e9%83%a8%e6%a0%bc%e5%bc%8f" aria-label="6.TCP首部格式">6.<strong>TCP</strong>首部格式</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e7%ac%ac7%e7%ab%a0-%e8%b7%af%e7%94%b1%e5%8d%8f%e8%ae%ae" aria-label="第7章 路由协议">第7章 路由协议</a><ul>
                            
                    <li>
                        <a href="#1%e9%9d%99%e6%80%81%e8%b7%af%e7%94%b1%e4%b8%8e%e5%8a%a8%e6%80%81%e8%b7%af%e7%94%b1" aria-label="1.静态路由与动态路由">1.<strong>静态路由与动态路由</strong></a></li>
                    <li>
                        <a href="#2%e8%b7%af%e7%94%b1%e6%8e%a7%e5%88%b6%e8%8c%83%e5%9b%b4" aria-label="2.路由控制范围">2.路由控制范围</a><ul>
                            
                    <li>
                        <a href="#%e8%87%aa%e6%b2%bb%e7%b3%bb%e7%bb%9f%e4%b8%8e%e8%b7%af%e7%94%b1%e5%8d%8f%e8%ae%ae" aria-label="自治系统与路由协议"><strong>自治系统与路由协议</strong></a></li></ul>
                    </li>
                    <li>
                        <a href="#3%e8%b7%af%e7%94%b1%e7%ae%97%e6%b3%95" aria-label="3.路由算法">3.路由算法</a><ul>
                            
                    <li>
                        <a href="#%e8%b7%9d%e7%a6%bb%e5%90%91%e9%87%8f%e7%ae%97%e6%b3%95" aria-label="距离向量算法">距离向量算法</a></li>
                    <li>
                        <a href="#%e9%93%be%e8%b7%af%e7%8a%b6%e6%80%81%e7%ae%97%e6%b3%95" aria-label="链路状态算法">链路状态算法</a></li>
                    <li>
                        <a href="#%e4%b8%bb%e8%a6%81%e8%b7%af%e7%94%b1%e5%8d%8f%e8%ae%ae" aria-label="主要路由协议">主要路由协议</a></li></ul>
                    </li>
                    <li>
                        <a href="#4rip" aria-label="4.RIP">4.<strong>RIP</strong></a><ul>
                            
                    <li>
                        <a href="#%e6%a0%b9%e6%8d%ae%e8%b7%9d%e7%a6%bb%e5%90%91%e9%87%8f%e7%a1%ae%e5%ae%9a%e8%b7%af%e7%94%b1" aria-label="根据距离向量确定路由"><strong>根据距离向量确定路由</strong></a></li>
                    <li>
                        <a href="#rip%e4%b8%ad%e8%b7%af%e7%94%b1%e5%8f%98%e6%9b%b4%e6%97%b6%e7%9a%84%e5%a4%84%e7%90%86" aria-label="RIP中路由变更时的处理"><strong>RIP</strong>中路由变更时的处理</a></li>
                    <li>
                        <a href="#rip2" aria-label="RIP2"><strong>RIP2</strong></a></li></ul>
                    </li>
                    <li>
                        <a href="#5ospf" aria-label="5.OSPF"><strong>5.OSPF</strong></a><ul>
                            
                    <li>
                        <a href="#ospf%e6%98%af%e9%93%be%e8%b7%af%e7%8a%b6%e6%80%81%e5%9e%8b%e8%b7%af%e7%94%b1%e5%8d%8f%e8%ae%ae" aria-label="OSPF是链路状态型路由协议"><strong>OSPF</strong>是链路状态型路由协议</a></li>
                    <li>
                        <a href="#ospf%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86" aria-label="OSPF基础知识"><strong>OSPF</strong>基础知识</a></li>
                    <li>
                        <a href="#ospf%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86%e6%a6%82%e8%bf%b0" aria-label="OSPF工作原理概述"><strong>OSPF</strong>工作原理概述</a></li>
                    <li>
                        <a href="#%e5%b0%86%e5%8c%ba%e5%9f%9f%e5%88%86%e5%b1%82%e5%8c%96%e8%bf%9b%e8%a1%8c%e7%bb%86%e5%88%86%e7%ae%a1%e7%90%86" aria-label="将区域分层化进行细分管理">将区域分层化进行细分管理</a></li></ul>
                    </li>
                    <li>
                        <a href="#6bgp" aria-label="6.BGP">6.<strong>BGP</strong></a><ul>
                            
                    <li>
                        <a href="#bgp%e4%b8%8eas%e5%8f%b7" aria-label="BGP与AS号"><strong>BGP</strong>与<strong>AS</strong>号</a></li>
                    <li>
                        <a href="#bgp%e6%98%af%e8%b7%af%e5%be%84%e5%90%91%e9%87%8f%e5%8d%8f%e8%ae%ae" aria-label="BGP是路径向量协议"><strong>BGP</strong>是路径向量协议</a></li></ul>
                    </li>
                    <li>
                        <a href="#7mpls" aria-label="7.MPLS">7.<strong>MPLS</strong></a><ul>
                            
                    <li>
                        <a href="#mpls%e7%9a%84%e7%bd%91%e7%bb%9c%e5%9f%ba%e6%9c%ac%e5%8a%a8%e4%bd%9c" aria-label="MPLS的网络基本动作"><strong>MPLS</strong>的网络基本动作</a></li>
                    <li>
                        <a href="#mpls%e7%9a%84%e4%bc%98%e7%82%b9" aria-label="MPLS的优点"><strong>MPLS</strong>的优点</a></li></ul>
                    </li></ul>
                    </li>
                    <li>
                        <a href="#%e7%ac%ac8%e7%ab%a0-%e5%ba%94%e7%94%a8%e5%8d%8f%e8%ae%ae" aria-label="第8章 应用协议">第8章 应用协议</a><ul>
                            
                    <li>
                        <a href="#1%e8%bf%9c%e7%a8%8b%e7%99%bb%e5%bd%95" aria-label="1.远程登录">1.远程登录</a></li>
                    <li>
                        <a href="#2%e6%96%87%e4%bb%b6%e4%bc%a0%e8%be%93" aria-label="2.文件传输">2.文件传输</a></li>
                    <li>
                        <a href="#3%e7%94%b5%e5%ad%90%e9%82%ae%e4%bb%b6" aria-label="3.电子邮件">3.电子邮件</a><ul>
                            
                    <li>
                        <a href="#%e9%82%ae%e4%bb%b6%e5%9c%b0%e5%9d%80" aria-label="邮件地址">邮件地址</a></li>
                    <li>
                        <a href="#mime" aria-label="MIME"><strong>MIME</strong></a></li>
                    <li>
                        <a href="#smtp" aria-label="SMTP"><strong>SMTP</strong></a></li>
                    <li>
                        <a href="#pop" aria-label="POP"><strong>POP</strong></a></li>
                    <li>
                        <a href="#imap" aria-label="IMAP"><strong>IMAP</strong></a></li></ul>
                    </li>
                    <li>
                        <a href="#4www" aria-label="4.WWW"><strong>4.WWW</strong></a><ul>
                            
                    <li>
                        <a href="#uri" aria-label="URI"><strong>URI</strong></a></li>
                    <li>
                        <a href="#html" aria-label="HTML"><strong>HTML</strong></a></li>
                    <li>
                        <a href="#http" aria-label="HTTP"><strong>HTTP</strong></a></li>
                    <li>
                        <a href="#javascriptcgicookie" aria-label="JavaScript、CGI、Cookie"><strong>JavaScript</strong>、<strong>CGI</strong>、<strong>Cookie</strong></a></li></ul>
                    </li>
                    <li>
                        <a href="#5%e7%bd%91%e7%bb%9c%e7%ae%a1%e7%90%86" aria-label="5.网络管理">5.网络管理</a><ul>
                            
                    <li>
                        <a href="#snmp" aria-label="SNMP"><strong>SNMP</strong></a></li></ul>
                    </li></ul>
                    </li>
                    <li>
                        <a href="#%e7%ac%ac9%e7%ab%a0-%e7%bd%91%e7%bb%9c%e5%ae%89%e5%85%a8" aria-label="第9章 网络安全">第9章 网络安全</a><ul>
                            
                    <li>
                        <a href="#1%e7%bd%91%e7%bb%9c%e5%ae%89%e5%85%a8%e6%9e%84%e6%88%90%e8%a6%81%e7%b4%a0" aria-label="1.网络安全构成要素">1.网络安全构成要素</a><ul>
                            
                    <li>
                        <a href="#%e9%98%b2%e7%81%ab%e5%a2%99" aria-label="防火墙"><strong>防火墙</strong></a></li>
                    <li>
                        <a href="#ids%e5%85%a5%e4%be%b5%e6%a3%80%e6%b5%8b%e7%b3%bb%e7%bb%9f" aria-label="IDS（入侵检测系统）"><strong>IDS（入侵检测系统）</strong></a></li>
                    <li>
                        <a href="#%e5%8f%8d%e7%97%85%e6%af%92%e4%b8%aa%e4%ba%ba%e9%98%b2%e7%81%ab%e5%a2%99" aria-label="反病毒/个人防火墙"><strong>反病毒/个人防火墙</strong></a></li></ul>
                    </li>
                    <li>
                        <a href="#2%e5%8a%a0%e5%af%86%e6%8a%80%e6%9c%af%e5%9f%ba%e7%a1%80" aria-label="2.加密技术基础">2.加密技术基础</a><ul>
                            
                    <li>
                        <a href="#%e5%af%b9%e7%a7%b0%e5%af%86%e7%a0%81%e4%bd%93%e5%88%b6%e4%b8%8e%e5%85%ac%e9%92%a5%e5%af%86%e7%a0%81%e4%bd%93%e5%88%b6" aria-label="对称密码体制与公钥密码体制">对称密码体制与公钥密码体制</a></li>
                    <li>
                        <a href="#%e8%ba%ab%e4%bb%bd%e8%ae%a4%e8%af%81%e6%8a%80%e6%9c%af" aria-label="身份认证技术">身份认证技术</a></li></ul>
                    </li>
                    <li>
                        <a href="#3%e5%ae%89%e5%85%a8%e5%8d%8f%e8%ae%ae" aria-label="3.安全协议">3.安全协议</a><ul>
                            
                    <li>
                        <a href="#ipsec%e4%b8%8evpn" aria-label="IPsec与VPN"><strong>IPsec</strong>与<strong>VPN</strong></a></li>
                    <li>
                        <a href="#tlsssl%e4%b8%8ehttps" aria-label="TLS/SSL与HTTPS"><strong>TLS/SSL</strong>与<strong>HTTPS</strong></a></li>
                    <li>
                        <a href="#ieee8021x" aria-label="IEEE802.1X"><strong>IEEE802.1X</strong></a>
                    </li>
                </ul>
                </li>
                </ul>
                </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>
  <div class="post-content"><h2 id="写在前面">写在前面<a hidden class="anchor" aria-hidden="true" href="#写在前面">#</a></h2>
<p>该篇博客是我在看<a href="https://item.jd.com/11253710.html">《图解TCPIP》</a>这本书时记录的学习笔记✍~~</p>
<h2 id="第1章-网络基础知识">第1章 网络基础知识<a hidden class="anchor" aria-hidden="true" href="#第1章-网络基础知识">#</a></h2>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303445.png" alt="image-20220420100854531"  />
</p>
<p>计算机网络，根据其规模可分为==WAN（Wide Area Network，广域 网）==（指覆盖多个远距离区域的远程网络。比广域网再小一级的、连接整个城市的网络叫==城域网（MAN，Metropolitan Area Network）==。） 和==LAN（Local Area Network，局域网）==（指一个楼层、一栋楼或一个 校园等相对较小的区域内的网络。） 。</p>
<p>互联网是由许多独立发展的网络通信技术融合而成。能够使它们之间不断融合并实现统一的正是==TCP/IP技术==。==TCP/IP是通信协议的统称==。</p>
<h3 id="1协议">1.协议<a hidden class="anchor" aria-hidden="true" href="#1协议">#</a></h3>
<p>表1.2 各种网络体系结构及其协议</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303456.png" alt="image-20220420102938784"  />
</p>
<p>==协议==就是计算机与计算机之间通过网络实现通信时事先达成的一种“约定”。这种“约定”使那些由不同厂商的设备、不同的CPU以及不同的操作系统组成的计算机之间，只要遵循相同的协议就能够实现通信。</p>
<p><strong>协议的标准化</strong></p>
<p>ISO（International Organization for Standards，国际标准化组织。）制定了一个国际标准OSI（Open Systems Interconnection，开放式通信系统互联参考模型。） ，对通信系统进行了标准化。现在，OSI所定义的协议虽然并没有得到普及，但是在OSI协议设计之初作为其指导方针的OSI参考模型却常被用于网络协议的制定当中。</p>
<p>本书将要说明的TCP/IP并非ISO（International Organization for Standards，国际标准化组织）所制定的某种国际标准。而是由 IETF（Internet Engineering Task Force） 所建议的、致力于推进其标准化作业的一种协议。</p>
<h3 id="2协议的分层">2.协议的分层<a hidden class="anchor" aria-hidden="true" href="#2协议的分层">#</a></h3>
<p>ISO在制定标准化OSI之前，对网络体系结构相关的问题进行了充分的讨论，最终提出了作为通信协议设计指标的OSI参考模型。这一模型将通信协议中必要的功能分成了7层。通过这些分层，使得那些比较复杂的网络协议更加简单化。</p>
<p>在这一模型中，每个分层都接收由它下一层所提供的特定服务，并且负责为自己的上一层提供特定的服务。==上下层之间==进行交互时所遵循的约定叫做==“接口”==。==同一层之间==的交互所遵循的约定叫做==“协议”==。</p>
<img src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303459.png" alt="image-20220420105644375" style="zoom:80%;" /> 
<img src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303471.png" alt="image-20220420110244645" style="zoom:80%;" /> 
<h4 id="osi协议与osi参考模型">OSI协议与OSI参考模型<a hidden class="anchor" aria-hidden="true" href="#osi协议与osi参考模型">#</a></h4>
<p>OSI（参考模型）将通信功能划分为7个分层，称作==OSI参考模型==。==OSI协议==（是为了让异构的计算机之间能够相互通信的、由ISO和ITU-T推进其标准化的一种网络体系结构）以OSI参考模型为基础界定了每个阶层的协议和每个阶层之间接口相关的标准。遵循OSI协议的产品叫OSI产品，而它们所遵循的通信则被称为OSI通信。</p>
<h4 id="osi参考模型中各个分层的作用">OSI参考模型中各个分层的作用<a hidden class="anchor" aria-hidden="true" href="#osi参考模型中各个分层的作用">#</a></h4>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303463.png" alt="image-20220420110749336"  />
</p>
<p><strong>■</strong> 应用层</p>
<p>为应用程序提供服务并规定应用程序中通信相关的细节。包括文件传输、电子邮件、远程登录（虚拟终端）等协议。</p>
<p><strong>■</strong> 表示层</p>
<p>将应用处理的信息转换为适合网络传输的格式，或将来自下一层的数据转换为上层能够处理的格式。因此它主要负责数据格式的转换。具体来说，就是将设备固有的数据格式转换为网络标准传输格式。不同设备对同一比特流解释的结果可能会不同。因此，使它们保持一致是这一层的主要作用。</p>
<p><strong>■</strong> 会话层</p>
<p>负责建立和断开通信连接（数据流动的逻辑通路），以及数据的分割等数据传输相关的管理。</p>
<p><strong>■</strong> 传输层</p>
<p>==起着可靠传输的作用==。只在通信双方节点上进行处理，而无需在路由器上处理。 ==（会话层负责决定建立连接和断开连接的时机，而传输层进行实际的建立和断开处理）==</p>
<p><strong>■</strong> 网络层</p>
<p>将数据传输到目标地址。目标地址可以是多个网络通过路由器连接而成的某一个地址。因此这一层主要负责寻址和路由选择。 （网络层的作用是在网络与网络相互连接的环境中，将数据从发送端主机发送到接收端主机。两端主机之间虽然有众多数据链路，但能够将数据从主机A送到主机B也都是网络层的功劳。）</p>
<p><strong>■</strong> 数据链路层</p>
<p>负责物理层面上互连的、节点之间的通信传输。例如与1个以太网相连的2个节点之间的通信。将0、1序列划分为具有意义的数据帧传送给对端（数据帧的生成与接收）。</p>
<p><strong>■</strong> 物理层</p>
<p>负责0、1比特流（0、1序列）与电压的高低、光的闪灭之间的互换。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303480.png" alt="image-20220420141217002"  />
</p>
<h3 id="3传输方式的分类">3.传输方式的分类<a hidden class="anchor" aria-hidden="true" href="#3传输方式的分类">#</a></h3>
<h4 id="面向有连接型与面向无连接型">面向有连接型与面向无连接型<a hidden class="anchor" aria-hidden="true" href="#面向有连接型与面向无连接型">#</a></h4>
<p>通过网络发送数据，大致可以分为面向有连接与面向无连接两种类型（面向无连接型包括以太网、IP、UDP等协议。面向有连接型包括ATM、帧中继、TCP等协议） 。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303774.png" alt="image-20220420143001339"  />
</p>
<h4 id="电路交换与分组交换">电路交换与分组交换<a hidden class="anchor" aria-hidden="true" href="#电路交换与分组交换">#</a></h4>
<p>目前，网络通信方式大致分为两种——==电路交换==和==分组交换==。电路交换技术的历史相对久远，主要用于过去的电话网。而分组交换技术则是一种较新的通信方式，从20世纪60年代后半叶才开始逐渐被人们认可。本书着力介绍的==TCP/IP==，正是采用了==分组交换技术==。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303792.png" alt="image-20220420143914312"  />
</p>
<p>图1.31 电路交换与分组交换的特点</p>
<h4 id="根据接收端数量分类">根据接收端数量分类<a hidden class="anchor" aria-hidden="true" href="#根据接收端数量分类">#</a></h4>
<img src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303811.png" alt="image-20220420144303022"  /> 
<p>单播（<strong>Unicast</strong>）</p>
<p>字面上，“Uni”表示“1”，“Cast”意为“投掷”。组合起来就是指1对1通信。早先的固定电话就是单播通信的一个典型例子。</p>
<p>广播（<strong>Broadcast</strong>）</p>
<p>它指是将消息从1台主机发送给与之相连的所有其他主机。广播通信的一个典型例子就是电视播放，它将电视信号一齐发送给非特定的多个接收对象。</p>
<p>多播（<strong>Multicast</strong>）</p>
<p>多播与广播类似，也是将消息发给多个接收主机。不同之处在于多播要限定某一组主机作为接收端。多播通信最典型的例子就是电视会议。</p>
<p>任播（<strong>Anycast</strong>）</p>
<p>任播是指在特定的多台主机中选出一台作为接收端的一种通信方式。虽然，这种方式与多播有相似之处，都是面向特定的一群主机，但是它的行为却与多播不同。任播通信从目标主机群中选择一台最符合网络条件的主机作为目标主机发送消息。通常，所被选中的那台特定主机将返回一个单播信号，随后发送端主机会只跟这台主机进行通信。</p>
<p>==任播在实际网络中的应用有DNS根域名解析服务器。==</p>
<h3 id="4地址">4.地址<a hidden class="anchor" aria-hidden="true" href="#4地址">#</a></h3>
<p>MAC地址和IP地址在标识一个通信主体时虽然都具有唯一性，但是它们当中只有IP地址具有层次性。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303830.png" alt="image-20220420145343410"  />
</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303028.png" alt="image-20220420145351282"  />
</p>
<h3 id="5网络的构成要素">5.网络的构成要素<a hidden class="anchor" aria-hidden="true" href="#5网络的构成要素">#</a></h3>
<p>搭建一套网络环境要涉及各种各样的电缆和网络设备。在此仅介绍连接计算机与计算机的硬件设备。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303050.png" alt="image-20220420145955209"  />
</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303071.png" alt="image-20220420150123100"  />
</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303088.png" alt="image-20220420150130844"  />
</p>
<p><strong>传输速率与吞吐量</strong></p>
<p>在数据传输的过程中，==两个设备之间数据流动的物理速度称为传输速率。==单位为bps（Bits Per Second，每秒比特数）。从严格意义上讲，各种传输媒介中信号的流动速度是恒定的。因此，即使数据链路的传输速率不相同，也不会出现传输的速度忽快忽慢的情况（因为光和电流的传输速度是恒定的。） 。==传输速率高也不是指单位数据流动的速度有多快，而是指单位时间内传输的数据量有多少。==</p>
<p>以我们生活中的道路交通为例，低速数据链路就如同车道较少无法让很多车同时通过的情况。与之相反，高速数据链路就相当于有多个车道，一次允许更多车辆行驶的道路。==传输速率又称作带宽（Bandwidth）。带宽越大网络传输能力就越强。==</p>
<p>此外，==主机之间实际的传输速率被称作吞吐量。==其单位与带宽相同，都是bps（Bits Per Second）。吞吐量这个词不仅衡量带宽，同时也衡量主机的CPU处理能力、网络的拥堵程度、报文中数据字段的占有份额（不含报文首部，只计算数据字段本身）等信息。</p>
<p><strong>网卡</strong></p>
<p>任何一台计算机连接网络时，必须要使用==网卡（全称为网络接口卡，<strong>Network Interface Card，简称NIC</strong>）==。网络接口卡（NIC（集成了连接局域网功能的设备。有时会被集成到计算机的主板中，有时也可以单独插入扩展槽使用。Network Information Center的缩写也是NIC，所以要注意区分。） ）==有时也被叫做网络适配器、网卡、LAN卡==。</p>
<p><strong>中继器</strong></p>
<p>中继器（Repeater）是在OSI模型的第1层——物理层面上延长网络的设备。由电缆传过来的电信号或光信号经由中继器的波形调整和放大再传给另一个电缆。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303105.png" alt="image-20220420150837403"  />
</p>
<p>有些中继器可以提供多个端口服务。这种中继器被称作==中继集线器或集线器==。因此，集线器（中继集线器也可以简称为集线器或Hub） 也可以看作是多口中继器，每个端口都可以成为一个中继器。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303118.png" alt="image-20220420151440684"  />
</p>
<p><strong>网桥/2层交换机</strong></p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303342.png" alt="image-20220420151548293"  />
</p>
<p>网桥是在OSI模型的第2层——数据链路层面上连接两个网络的设备。它能够识别数据链路层中的==数据帧==（与分组数据意思大致相同，但是在数据链路层中通常习惯称为帧） ，并将这些数据帧临时存储于内存，再重新生成信号作为一个全新的帧转发给相连的另一个网段。</p>
<p>这类功能是==OSI参考模型的第2层（数据链路层）所具有的功能==。为此，有时也把==网桥称作2层交换机==（L2交换机）。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303359.png" alt="image-20220420151809119"  />
</p>
<p>以太网等网络中经常使用的==交换集线器==（Hub（==具有网桥功能的Hub叫做交换集线器==。只有中继器功能的Hub叫做集线器。）），==现在基本也属于网桥的一种==。交换集线器中连接电缆的每个端口都能提供类似网桥的功能。</p>
<p><strong>路由器/3层交换机</strong></p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303380.png" alt="image-20220420151949542"  />
</p>
<p>==路由器是在OSI模型的第3层——网络层面上连接两个网络、并对分组报文进行转发的设备==。网桥是根据物理地址（MAC地址）进行处理，而路由器/3层交换机则是根据IP地址进行处理的。由此，TCP/IP中网络层的地址就成为了IP地址。</p>
<p><strong>4～7层交换机</strong></p>
<p>4～7层交换机负责处理==OSI模型中从传输层至应用层的数据==。如果用TCP/IP分层模型来表述，==4～7层交换机就是以TCP等协议的传输层及其上面的应用层为基础，分析收发数据，并对其进行特定的处理。==</p>
<p>==应用场景==：</p>
<ul>
<li>==负载均衡器==（对于并发访问量非常大的一个企业级Web站点使用一台服务器不足以满足前端的访问需求）</li>
<li>==带宽控制==（实际通信当中，在网络比较拥堵的时候，优先处理像语音这类对及时性要求较高的通信请求，放缓处理像邮件或数据转发等稍有延迟也并无大碍的通信请求）</li>
<li>==广域网加速器、特殊应用访问加速以及防火墙==</li>
</ul>
<p><strong>网关</strong></p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303397.png" alt="image-20220420153128338"  />
</p>
<p>==网关是OSI参考模型中负责将从传输层到应用层的数据进行转换和转发的设备。==它与4～7层交换机一样都是处理传输层及以上的数据，但是网关不仅转发数据还负责对数据进行转换，它通常会使用一个表示层或应用层网关，在两个不能进行直接通信的协议之间进行翻译，最终实现两者之间的通信。</p>
<p>一个非常典型的例子就是互联网邮件与手机邮件之间的转换服务。</p>
<p>手机邮件有时可能会与互联网邮件互不兼容，这是由于它们在表示层和应用层中的“电子邮件协议”互不相同所导致的。那么，为什么连到互联网的电脑与手机之间能够互发电子邮件呢？如图1.47所示，互联网与手机之间设置了一道网关。网关负责读取完各种不同的协议后，==对它们逐一进行合理的转换，再将相应的数据转发出去。==这样一来即使应用的是不同电子邮件的协议，计算机与手机之间也能互相发送邮件。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303414.png" alt="image-20220420153410049"  />
</p>
<p>此外，在使用WWW（World Wide Web，万维网）时，为了控制网络流量以及出于安全的考虑，有时会使用代理服务器（Proxy Server）。这种代理服务器也是网关的一种，称为==应用网关==。有了代理服务器，客户端与服务器之间无需在网络层上直接通信，而是从传输层到应用层对数据和访问进行各种控制和处理。防火墙就是一款通过网关通信，针对不同应用提高安全性的产品。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303599.png" alt="image-20220420153502561"  />
</p>
<p><strong>各种设备及其对应网络分层概览</strong></p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303620.png" alt="image-20220420153523208"  />
</p>
<h3 id="6现代网络实态">6.现代网络实态<a hidden class="anchor" aria-hidden="true" href="#6现代网络实态">#</a></h3>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303637.png" alt="image-20220420154523701"  />
</p>
<p>每座大型城市的道路交通网中，或多或少都分布着高速公路。在计算机网络中有类似高速公路的部分，人们称为==“骨干”或“核心”==。正如其名，它们是计算机网络的中心。人们通常会选用高速路由器相互连接使之==快速传输大量数据==。</p>
<p>网络中相应于高速公路==出入口==的部分被称作==“边缘网络”== 。常用的设备有多功能路由器（在路由器最基本的功能之上增加了按顺序/种类发送数据的功能，可以根据TCP/IP层的协议变换处理方法。） 和3层交换机。</p>
<p>高速公路的出入口通常连接国道、省道，从而可以通往市区街道。==计算机网络中连接“边缘网络”的部分叫做“接入层”或“汇聚层”==。这样，==骨干网可以专注于如何提高业务传输性能和网络的生存性，而将具有业务智能化的高速路由器和交换机移到网络的边缘==。边缘网络的常用设备多为2层交换机或3层交换机。</p>
<p><strong>虚拟化和云</strong></p>
<p>抽奖、网游等网站，这些网站有一个共同的特点，那就是==具有明显的访问高峰点==。以提供抽奖的站点为例，在抽奖活动期间，白天或周末访问量都非常高，而在抽奖活动结束后基本无人问津。而且，在访问高峰期，网站又必须保证每一个用户都能正常访问，否则极可能会被起诉发生索赔事件。</p>
<p>基于这样一个背景，出现了==虚拟化技术==。它是指当一个网站（也可以是其他系统）需要调整运营所使用的资源时，==并不增减服务器、存储设备、网络等实际的物理设备，而是利用软件将这些物理设备虚拟化==，在有必要增减资源的时候，通过软件按量增减的一种机制。通过此机制实现按需分配、按比例分配，对外提供可靠的服务。</p>
<p>==利用虚拟化技术，根据使用者的情况动态调整必要资源的机制被人们称作“云”==。而且，将虚拟化的系统根据需要自动地进行动态管理的部分被称作==“智能协调层”==。它能够将服务器、存储、网络看作一个整体进行管理。有了“云”，网络的使用者就可以实现不论何时何地都可以只获取或只提供需要信息的机制。</p>
<h2 id="第2章-tcpip基础知识">第2章 TCP/IP基础知识<a hidden class="anchor" aria-hidden="true" href="#第2章-tcpip基础知识">#</a></h2>
<p>TCP（Transmission Control Protocol）和IP（Internet Protocol）是互联网的众多通信协议中最为著名的。</p>
<h3 id="1tcpip的标准化">1.<strong>TCP/IP</strong>的标准化<a hidden class="anchor" aria-hidden="true" href="#1tcpip的标准化">#</a></h3>
<p>20世纪90年代，ISO开展了OSI这一国际标准协议的标准化进程。 然而，OSI协议并没有得到普及，真正被广泛使用的是TCP/IP协议。</p>
<p>究其原因，是由TCP/IP的标准化所致。==TCP/IP的标准化中有其他协议的标准化没有的要求==。这一点就是让TCP/IP更迅速地实现和普及的原动力。</p>
<h4 id="tcpip的具体含义"><strong>TCP/IP</strong>的具体含义<a hidden class="anchor" aria-hidden="true" href="#tcpip的具体含义">#</a></h4>
<p>从字面意义上讲，有人可能会认为TCP/IP是指TCP与IP两种协议。实际生活当中有时也确实就是指这两种协议。然而在很多情况下，它只是==利用IP进行通信时所必须用到的协议群的<strong>统称</strong>==。具体来说，IP或ICMP、TCP或UDP、TELNET或FTP、以及HTTP等都属于TCP/IP的协议。它们与TCP或IP的关系紧密，是互联网必不可少的组成部分。==TCP/IP一词泛指这些协议==，因此，有时也称TCP/IP为网际协议族（网际协议族（Internet Protocol Suite）：组成网际协议的一组协议。）</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303655.png" alt="image-20220420161350773"  />
</p>
<h4 id="tcpip规范rfc"><strong>TCP/IP</strong>规范**——RFC**<a hidden class="anchor" aria-hidden="true" href="#tcpip规范rfc">#</a></h4>
<p>前面提到TCP/IP的协议由IETF讨论制定。那些需要标准化的协议，被人们列入==RFC（Request For Comment）==（RFC从字面意义上看就是指征求意见表，属于一种征求协议相关意见的文档） 文档并在互联网上公布。RFC不仅记录了协议规范内容，还包含了协议的实现和运用的相关信息（==协议实现或运用相关的信息叫做FYI（For Your Information）==） ，以及实验方面的信息（==实验阶段的协议称作Experimental==） 。</p>
<p>RFC文档通过编号组织每个协议的标准化请求。例如IP协议的规范由RFC279制定，TCP协议的规范由RFC793号文档决定。RFC的编码是既定的，一旦成为某一RFC的内容，就不能再对其进行随意修改。若要扩展已有某个协议规范的内容，一定要有一个全新编号的RFC文档对其进行记录。若要修改已有某个协议规范内容，则需要重新发行一个新的 RFC文档，同时，老的那份RFC作废。新的RFC文档会明确规定是扩展了哪个已有的RFC以及要作废哪个已有RFC。</p>
<p>此时，有人提出每当对RFC进行修改时都要产生新的RFC编号太麻烦。为此，人们采用==STD（Standard）==（例如STD5表示包含ICMP的IP协议标准。因此，STD5由RFC791、RFC919、RFC922、RFC792、RFC950以及RFC1112 6个RFC组成） 方式管理编号。STD用来记载哪个编号制定哪个协议。因此，==同一个协议的规范内容即便发生了变化也不会导致STD编号发生变化==。</p>
<p>今后，即使协议规范的内容改变也不会改变STD编号，但是有可能导致某个STD下的RFC编号视情况有所增减。</p>
<p>此外，为了向互联网用户和管理者提供更有益的信息，与STD类似，FYI（For Your Information）也开始标注编号组织。FYI为了人们方便检索，也在其每个编号里涵盖了所涉及的RFC编号。即使更新内容，编号也不会发生变化。</p>
<p>STD1记录着所有要求协议标准化的RFC状态。到2012年1月为止，STD1相当于RFC5000（很多情况下会采用比较容易记忆的编号）。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303802.png" alt="image-20220420164130568"  />
</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303819.png" alt="image-20220420164144120"  />
</p>
<p>每个RFC的最新信息请参考<code>http://www.rfc-editor.org/rfc/rfc××××.txt</code>（其中××××为RFC编号）。</p>
<p>STD获取网址：<code>http://www.rfc-editor.org/in-notes/std/</code></p>
<p>FYI获取网址：<code>http://www.rfc-editor.org/in-notes/fyi/ </code></p>
<p>ID（I-D：Internet Draft）获取网址：<code>http://www.rfc-editor.org/internet-drafts/</code></p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303837.png" alt="image-20220420164251874"  />
</p>
<h3 id="2互联网基础知识">2.互联网基础知识<a hidden class="anchor" aria-hidden="true" href="#2互联网基础知识">#</a></h3>
<h4 id="互联网定义">互联网定义<a hidden class="anchor" aria-hidden="true" href="#互联网定义">#</a></h4>
<p>“互联网”，英文单词为“Internet”。从字面上理解，internet指的是将多个网络连接使其构成一个更大的网络，所以internet一词本意为==网际网==。将两个以太网网段用路由器相连是互联网，将企业内部各部门的网络或公司的内网与其他企业相连接，并实现相互通信的网络也是互联网，甚至一个区域的网络与另一个区域的网络相互连接形成全世界规模 的网络也可以称作互联网。然而，现在“互联网”这个词的意思却有所变化。==当专门指代网络之间的连接时，可以使用“网际网”这个词==。</p>
<p>==“互联网”是指由ARPANET（Advanced Research Projects Agency Network，阿帕网 ，也是全球互联网的鼻祖==发展而来、互连全世界的计算机网络。==现在，“互联网”已经是一个专有名词了，其对应的英文单词==“The Internet”==也早已成为固有名词（Internet指网际网，The Internet指互联网，首字母大写）（与Internet对应的另一种网络叫做Intranet。该网络是指使用Internet技术将企业内部的组织机构连接起来形成一个企业范围内的封闭网络，提供面向企业内部的通信服务） 。</p>
<h4 id="互联网与tcpip的关系"><strong>互联网与TCP/IP的关系</strong><a hidden class="anchor" aria-hidden="true" href="#互联网与tcpip的关系">#</a></h4>
<p>互联网进行通信时，需要相应的网络协议，TCP/IP原本就是为使用互联网而开发制定的协议族。因此，==互联网的协议就是TCP/IP，TCP/IP就是互联网的协议==。</p>
<h4 id="互联网的结构">互联网的结构<a hidden class="anchor" aria-hidden="true" href="#互联网的结构">#</a></h4>
<p>互联网中的每个网络都是由==骨干网==（BackBone）和末端网（Stub）组成的。每个网络之间通过==NOC（Network Operation Center，网络操作中心）== 相连。如果网络的运营商不同，它的网络连接方式和使用方法也会不同。连接这种异构网络需要有==IX（Internet Exchange，网络交换中心）== 的支持。总之，互联网就是众多异构的网络通过IX互连的一个巨型网络。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303853.png" alt="image-20220420165403633"  />
</p>
<h3 id="3tcpip协议分层模型">3.<strong>TCP/IP</strong>协议分层模型<a hidden class="anchor" aria-hidden="true" href="#3tcpip协议分层模型">#</a></h3>
<h4 id="tcpip与osi参考模型"><strong>TCP/IP</strong>与<strong>OSI</strong>参考模型<a hidden class="anchor" aria-hidden="true" href="#tcpip与osi参考模型">#</a></h4>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303870.png" alt="image-20220420165932511"  />
</p>
<p>图2.8列出了TCP/IP与OSI分层之间的大致关系。不难看出，TCP/IP与OSI在分层模块上稍有区别。==OSI参考模型注重“通信协议必要的功能是什么”，而TCP/IP则更强调“在计算机上实现协议应该开发哪种程序”==。</p>
<h4 id="硬件物理层">硬件（物理层）<a hidden class="anchor" aria-hidden="true" href="#硬件物理层">#</a></h4>
<p>TCP/IP的最底层是负责数据传输的硬件。这种硬件就相当于以太网或电话线路等物理层的设备。</p>
<h4 id="网络接口层数据链路层">网络接口层（数据链路层）<a hidden class="anchor" aria-hidden="true" href="#网络接口层数据链路层">#</a></h4>
<p>网络接口层（有时人们也将网络接口层与硬件层合并起来称作网络通信层。） 利用以太网中的数据链路层进行通信，因此属于接口层。 也就是说，把它当做让NIC起作用的“驱动程序”也无妨。驱动程序是在操作系统与硬件之间起桥梁作用的软件。</p>
<h4 id="互联网层网络层">互联网层（网络层）<a hidden class="anchor" aria-hidden="true" href="#互联网层网络层">#</a></h4>
<p>互联网层使用IP协议，它相当于OSI模型中的第3层网络层。IP协议基于IP地址转发分包数据。</p>
<p>==TCP/IP分层中的互联网层与传输层的功能通常由操作系统提供。尤其是路由器，它必须得实现通过互联网层转发分组数据包的功能==。</p>
<p>此外，连接互联网的所有主机跟路由器必须都实现IP的功能。其他连接互联网的网络设备（如网桥、中继器或集线器）就没必要一定实现IP或TCP的功能（有时为了监控和管理网桥、中继器、集线器等设备，也需要让它们具备IP、TCP的功能。） 。</p>
<p><strong>IP</strong></p>
<p>IP是跨越网络传送数据包，使整个互联网都能收到数据的协议。IP协议使数据能够发送到地球的另一端，这期间它使用IP地址作为主机的标识。</p>
<p>IP还隐含着数据链路层的功能。通过IP，相互通信的主机之间不论经过怎样的底层数据链路都能够实现通信。</p>
<p>虽然IP也是分组交换的一种协议，但是它==不具有重发机制。即使分组数据包未能到达对端主机也不会重发。因此，属于非可靠性传输协议。==</p>
<p><strong>ICMP（Internet Control Message Protocol）</strong></p>
<p>IP数据包在发送途中一旦发生异常导致无法到达对端目标地址时，需要给发送端发送一个发生异常的通知。ICMP就是为这一功能而制定的。它有时也被用来==诊断网络的健康状况==。</p>
<p><strong>ARP</strong></p>
<p>从分组数据包的==IP地址中解析出物理地址（MAC地址）==的一种协议。</p>
<h4 id="传输层">传输层<a hidden class="anchor" aria-hidden="true" href="#传输层">#</a></h4>
<p>TCP/IP的传输层有两个具有代表性的协议。该层的功能本身与OSI参考模型中的传输层类似。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303080.png" alt="image-20220420185307675"  />
</p>
<p>传输层最主要的功能就是能够让应用程序之间实现通信。计算机内部，通常同一时间运行着多个程序。为此，必须分清是哪些程序与哪些程序在进行通信。识别这些应用程序的是端口号。</p>
<p><strong>TCP</strong></p>
<p>TCP是一种面向有连接的传输层协议。它可以==保证两端通信主机之间的通信可达。TCP能够正确处理在传输过程中丢包、传输顺序乱掉等异常情况==。此外，TCP还能够有效利用带宽，缓解网络拥堵。</p>
<p>然而，为了建立与断开连接，有时它需要至少7次的发包收包，导致网络流量的浪费。此外，为了提高网络的利用率，TCP协议中定义了各种各样复杂的规范，因此==不利于视频会议（音频、视频的数据量既定）等场合使用==。</p>
<p><strong>UDP</strong></p>
<p>UDP有别于TCP，它是一种面向==无连接的==传输层协议。==UDP不会关注对端是否真的收到了传送过去的数据==，如果需要检查对端是否收到分组数据包，或者对端是否连接到网络，则需要在应用程序中实现。</p>
<p>UDP常用于==分组数据较少或多播、广播通信以及视频通信等多媒体领域==。</p>
<h4 id="应用层会话层以上的分层">应用层（会话层以上的分层）<a hidden class="anchor" aria-hidden="true" href="#应用层会话层以上的分层">#</a></h4>
<p>TCP/IP的分层中，将OSI参考模型中的==会话层、表示层和应用层的功能都集中到了应用程序中实现==。这些功能有时由一个单一的程序实现，有时也可能会由多个程序实现。因此，细看TCP/IP的应用程序功能会发现，它不仅实现OSI模型中应用层的内容，还要实现会话层与表示层的功能。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303099.png" alt="image-20220420185612645"  />
</p>
<p><strong>WWW</strong></p>
<p>WWW（中文叫万维网，是一种互联网上数据读取的规范。有时也叫做Web、WWW或W3。） 可以说是互联网能够如此普及的一个重要原动力。</p>
<p>浏览器与服务端之间通信所用的协议是HTTP（HyperText Transfer Protocol）。所传输数据的主要格式是HTML（HyperText Markup Language）。==WWW中的HTTP属于OSI应用层的协议，而HTML属于表示层的协议==。</p>
<p><strong>电子邮件（E-Mail）</strong></p>
<p>发送电子邮件时用到的协议叫做==SMTP（Simple Mail Tranfer Protocol）==。</p>
<p>电子邮件的格式由==MIME==（在互联网上广泛使用的、用来定义邮件数据格式一种规范） ==协议==扩展以后，就可以发送声音、图像等各式各样的信息。甚至还可以修改邮件文字的大小、颜色（有时某些机能可能会因为邮件接收端软件的限制不能充分展现） 。这里提到的==MIME属于OSI参考模型的第6层——表示层==。</p>
<p><strong>文件传输（FTP）</strong></p>
<p>文件传输是指将保存在其他计算机硬盘上的文件转移到本地的硬盘上，或将本地硬盘的文件传送到其他机器硬盘上的意思。</p>
<p>该过程使用的协议叫做==FTP（File Transfer Prototol）==。FTP很早就已经投入使用（最近在文件传输中使用WWW的HTTP的情况也在增加。） ， 传输过程中可以选择用二进制方式还是文本方式（用文本方式在Windows、MacOS或Unix等系统之间进行文件传输时，会自动修改换行符。这也属于表示层的功能） 。</p>
<p>在FTP中进行文件传输时会建立两个TCP连接，分别是发出==传输请求时所要用到的控制连接与实际传输数据时所要用到的数据连接====（这两种连接的控制管理属于会话层的功能）== 。</p>
<p><strong>远程登录（TELNET与SSH）</strong></p>
<p>远程登录是指登录到远程的计算机上，使那台计算机上的程序得以运行的一种功能。TCP/IP网络中远程登录常用 TELNET（TELetypewriter NETwork的缩写。有时也称作默认协议） 和SSH（SSH是Secure SHell的缩写） 两种协议。其实还有很多其他可以实现远程登录的协议，如BSD UNIX系中rlogin的r命令协议以及X Window System中的X协议。</p>
<p><strong>网络管理（SNMP）</strong></p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303113.png" alt="image-20220420190158610"  />
</p>
<p>在TCP/IP中进行网络管理时，采用==SNMP（Simple Network Management Protocol）协议==。使用SNMP管理的主机、网桥、路由器等称作==SNMP代理（Agent）==，而进行管理的那一段叫做==管理器（Manager）==。SNMP正是这个Manager与Agent所要用到的协议。</p>
<p>在SNMP的代理端，保存着网络接口的信息、通信数据量、异常数据量以及设备温度等信息。这些信息可以通过MIB（Management Information Base）（MIB也被称为是一种可透过网络的结构变量） 访问。因此，在TCP/IP的网络管理中，==SNMP属于应用协议，MIB属于表示层协议==。</p>
<p>一个网络范围越大，结构越复杂，就越需要对其进行有效的管理。而SNMP可以让管理员及时检查网络拥堵情况，及早发现故障，也可以为以后扩大网络收集必要的信息。</p>
<h3 id="4tcpip分层模型与通信示例">4.<strong>TCP/IP</strong>分层模型与通信示例<a hidden class="anchor" aria-hidden="true" href="#4tcpip分层模型与通信示例">#</a></h3>
<p>TCP/IP是如何在媒介上进行传输的呢？本节将介绍使用TCP/IP时， 从应用层到物理媒介为止数据处理的流程。</p>
<h4 id="数据包首部">数据包首部<a hidden class="anchor" aria-hidden="true" href="#数据包首部">#</a></h4>
<img src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303132.png" alt="image-20220420191024726" style="zoom:80%;" /> 
<p>在下一 层的角度看，从上一分层收到的包全部都被认为是本层的数据。</p>
<p><strong>包、帧、数据包、段、消息</strong></p>
<p>以上五个述语都用来表述数据的单位，大致区分如下：</p>
<p>包可以说是全能性述语。帧用于表示数据链路层中包的单位。而数据包是IP和UDP等网络层以上的分层中包的单位。段则表示TCP数据流中的信息。最后，消息是指应用协议中数据的单位。</p>
<h4 id="发送数据包">发送数据包<a hidden class="anchor" aria-hidden="true" href="#发送数据包">#</a></h4>
<p>假设甲给乙发送电子邮件，内容为：“早上好”。而从TCP/IP通信上看，是从一台计算机A向另一台计算机B发送电子邮件。我们就通过这个例子来讲解一下TCP/IP通信的过程。</p>
<p>① 应用程序处理</p>
<p>② <strong>TCP</strong>模块的处理</p>
<p>③ <strong>IP</strong>模块的处理</p>
<p>④ 网络接口（以太网驱动）的处理</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303226.png" alt="image-20220420191848238"  />
</p>
<h4 id="经过数据链路的包">经过数据链路的包<a hidden class="anchor" aria-hidden="true" href="#经过数据链路的包">#</a></h4>
<p>分组数据包（以下简称包）经过以太网的数据链路时的大致流程如图2.19所示。不过请注意，该图对各个包首部做了简化。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303286.png" alt="image-20220420192535638"  />
</p>
<p>每个包首部中至少都会包含两个信息：==一个是发送端和接收端地址，另一个是上一层的协议类型==。</p>
<h4 id="数据包接收处理">数据包接收处理<a hidden class="anchor" aria-hidden="true" href="#数据包接收处理">#</a></h4>
<p>包的接收流程是发送流程的逆序过程。</p>
<p>⑤ 网络接口（以太网驱动）的处理</p>
<p>⑥ <strong>IP</strong>模块的处理</p>
<p>⑦ <strong>TCP</strong>模块的处理</p>
<p>⑧ 应用程序的处理</p>
<h2 id="第3章-数据链路">第3章 数据链路<a hidden class="anchor" aria-hidden="true" href="#第3章-数据链路">#</a></h2>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303302.png" alt="image-20220421100144562"  />
</p>
<h3 id="1数据链路的作用">1.数据链路的作用<a hidden class="anchor" aria-hidden="true" href="#1数据链路的作用">#</a></h3>
<p>数据链路，指OSI参考模型中的数据链路层，有时也指以太网、无线局域网等通信手段。</p>
<p>OSI参考模型中数据链路层的相关技术，包括MAC寻址（物理寻址）、介质共享、非公有网络、分组交换、环路检测、VLAN（Virtual Local Area Network，虚拟局域网）等。</p>
<p>作为传输方式的数据链路：如以太网、WLAN（Wireless Local Area Network，无限局域网）、PPP（Point to Point Protocol，点对点协议）。</p>
<p>数据链路也可以被视为网络传输中的最小单位。</p>
<h3 id="2数据链路相关技术">2.数据链路相关技术<a hidden class="anchor" aria-hidden="true" href="#2数据链路相关技术">#</a></h3>
<h4 id="mac地址"><strong>MAC</strong>地址<a hidden class="anchor" aria-hidden="true" href="#mac地址">#</a></h4>
<p>MAC地址用于识别数据链路中互连的节点（如图3.4）。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303319.png" alt="image-20220421101507076"  />
</p>
<p>MAC地址长48比特，结构如图3.5所示。在使用网卡（NIC）的情况下，MAC地址一般会被烧入到ROM中。因此，任何一个网卡的MAC地址都是唯一的，在全世界都不会有重复（也有例外）</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303336.png" alt="image-20220421101536712"  />
</p>
<h4 id="共享介质型网络">共享介质型网络<a hidden class="anchor" aria-hidden="true" href="#共享介质型网络">#</a></h4>
<p>从通信介质（通信，介质）的使用方法上看，网络可分为==共享介质型==和==非共享介质型==。</p>
<p>==共享介质型网络指由多个设备共享一个通信介质的一种网络==。最早的以太网和FDDI就是介质共享型网络。在这种方式下，设备之间使用同一个载波信道进行发送和接收。为此，基本上==采用半双工通信方式==，并有必要对介质进行访问控制。</p>
<p>共享介质型网络中有两种介质访问控制方式：一种是==争用方式==，另 一种是==令牌传递==方式。</p>
<p>争用方式（Contention）是指==争夺获取数据传输的权力==，也叫 CSMA（载波监听多路访问）。这种方法通常令网络中的各个站（数据链路中很多情况下称节点为“站”。） 采用先到先得的方式占用信道 发送数据，如果多个站同时发送帧，则会产生冲突现象。也因此会导致网络拥堵与性能下降。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303551.png" alt="image-20220421102123947"  />
</p>
<p>在一部分以太网当中，采用了改良CSMA的另一种方式—— ==CSMA/CD==（Carrier Sense Multiple Access with Collision Detection） 方式。CSMA/CD要求每个站提前检查冲突，==一旦发生冲突，则尽早释放信道==。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303568.png" alt="image-20220421102152263"  />
</p>
<p>令牌传递方式是沿着令牌环发送一种叫做“令牌”的特殊报文，是控制传输的一种方式。==只有获得令牌的站才能发送数据==。这种方式有两个特点：一是不会有冲突，二是每个站都有通过平等循环获得令牌的机会。因此，即使网络拥堵也不会导致性能下降。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303586.png" alt="image-20220421102202460"  />
</p>
<h4 id="非共享介质网络">非共享介质网络<a hidden class="anchor" aria-hidden="true" href="#非共享介质网络">#</a></h4>
<p>非共享介质网络是指==不共享介质==，是对介质采取专用的一种传输控制方式。在这种方式下，网络中的每个站直连交换机，由交换机负责转发数据帧。此方式下，发送端与接收端并不共享通信介质，因此很多情况下采用==全双工通信方式==。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303606.png" alt="image-20220421102537869"  />
</p>
<p><strong>半双工与全双工通信</strong></p>
<p>==半双工是指，只发送或只接收的通信方式==。它类似于无线电收发 器，若两端同时说话，是听不见对方说的话的。而==全双工==不同，它==允许在同一时间既可以发送数据也可以接收数据==。类似于电话，接打双方可以同时说话。</p>
<p>采用CSMA/CD方式的以太网，如图3.7所示，首先要判断是否可以通信，如果可以就独占通信介质发送数据。因此，它像无线电收发器一样，不能同时接收和发送数据。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303807.png" alt="image-20220421102745152"  />
</p>
<p>同样是以太网，在使用交换机与双绞线电缆（亦或光纤电缆）的情况下，既可以通过交换机的端口与计算机之间进行一对一的连接，也可以通过相连电缆内部的收发线路分别进行接收和发送数据。因此，交换机的端口与计算机之间可以实现同时收发的全双工通信。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303826.png" alt="image-20220421102753304"  />
</p>
<h4 id="根据mac地址转发">根据<strong>MAC</strong>地址转发<a hidden class="anchor" aria-hidden="true" href="#根据mac地址转发">#</a></h4>
<p>以太网交换机就是持有多个端口（计算机设备的外部接口都称做端口。）的网桥。它们根据数据链路层中每个帧的目标MAC地址，决定从哪个网络接口发送数据。这时所参考的、用以记录发送接口的表就叫做转发表（Forwarding Table）。</p>
<p>这种转发表的内容不需要使用者在每个终端或交换机上手工设置，而是可以自动生成。数据链路层的每个通过点在接到包时，会从中将源MAC地址以及曾经接收该地址发送的数据包的接口作为对应关系记录到转发表中。以某个MAC地址作为源地址的包由某一接口接收，实质上可以理解为该MAC地址就是该接口的目标。因此也可以说，以该MAC地址作为目标地址的包，经由该接口送出即可。这一过程也叫==自学过程==。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303843.png" alt="image-20220421104335374"  />
</p>
<h4 id="vlan"><strong>VLAN</strong><a hidden class="anchor" aria-hidden="true" href="#vlan">#</a></h4>
<p>进行网络管理的时候，时常会遇到分散网络负载、变换部署网络设备的位置等情况。而有时管理员在做这些操作时，不得不修改网络的拓扑结构，这也就意味着必须进行硬件线路的改造。然而，如果采用带有VLAN技术的网桥（交换机），就不用实际修改网络布线，只需修改网络的结构即可。VLAN技术附加到网桥/2层交换机上，就可以切断所有VLAN之间的所有通信。因此，相比一般的网桥/2层交换机，VLAN可以过滤多余的包，提高网络的承载效率。</p>
<p>那么VLAN究竟是什么？如图3.15所示，==该交换机按照其端口区分了多个网段，从而区分了广播数据传播的范围、减少了网络负载并提高了网络的安全性。==然而异构的两个网段之间，就需要利用具有路由功能的交换机（如3层交换机），或在各段中间通过路由器的连接才能实现通信。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303860.png" alt="image-20220421105258532"  />
</p>
<h3 id="3以太网">3.以太网<a hidden class="anchor" aria-hidden="true" href="#3以太网">#</a></h3>
<p>它的规范简单，易于NIC（网卡）及驱动程序实现。</p>
<h4 id="以太网连接形式"><strong>以太网连接形式</strong><a hidden class="anchor" aria-hidden="true" href="#以太网连接形式">#</a></h4>
<p>在以太网普及之初，一般采用多台终端使用同一根同轴电缆的==共享介质型连接方式==。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303907.png" alt="image-20220421105604028"  />
</p>
<p>而现在，随着互连设备的处理能力以及传输速度的提高，一般都采用==终端与交换机之间独占电缆==的方式实现以太网通信，如图3.18。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303023.png" alt="image-20220421105631032"  />
</p>
<h4 id="以太网帧格式">以太网帧格式<a hidden class="anchor" aria-hidden="true" href="#以太网帧格式">#</a></h4>
<p>以太网帧前端有一个叫做前导码（Preamble）的部分，它由0、1数字交替组合而成，表示一个以太网帧的开始，也是对端网卡能够确保与其同步的标志。如图3.19所示。前导码末尾是一个叫做SFD（Start Frame Delimiter）的域，它的值是“11”。在这个域之后就是以太网帧的本体（图3.20）。前导码与SFD合起来占8个字节。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303041.png" alt="image-20220421110905000"  />
</p>
<p>以太网帧本体的前端是以太网的首部，它总共占14个字节。分别是6个字节的目标MAC地址、6个字节的源MAC地址以及2个字节的上层协议类型。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303088.png" alt="image-20220421110921437"  />
</p>
<p><strong>数据链路层分为两层</strong></p>
<p>可以将数据链路层分为==介质访问控制层（简称MAC（Media Access Control））== 和==逻辑链路控制层（简称LLC（Logical Link Control））== 。 介质访问控制层根据以太网或FDDI等不同数据链路所==特有的首部信息==进行控制。与之相比，逻辑链路层则根据以太网或FDDI等不同数据链路所==共有的帧头信息==进行控制。</p>
<h3 id="4无线通信">4.无线通信<a hidden class="anchor" aria-hidden="true" href="#4无线通信">#</a></h3>
<p>无线通信通常使用电磁波、红外线、激光等方式进行传播数据。一般在办公室的局域网范围内组成的较高速的连接称为无线局域网。</p>
<p>无线通信，依据通信距离可分为如表3.3所列出的类型。IEEE802委员会制定了无线PAN（Personal Area Network） （802.15）、无线 LAN（Local Area Network）（802.11）、无线MAN（Metropolitan Area Network） （802.16）以及无线RAN（Regional Area Network）（802.22）等无线标准。无线WAN（Wide Area Network） 的最典型代表就是手机通信。手机通过基站能够实现长距离通信。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303131.png" alt="image-20220421112417784"  />
</p>
<p><strong>Wi-Fi</strong></p>
<p>与音响中Hi-Fi（High Fidelity：高保真、高重现）这个词类似， ==Wi-Fi（Wireless Fidelity）==指高质量的无线LAN。</p>
<h3 id="5ppp">5.<strong>PPP</strong><a hidden class="anchor" aria-hidden="true" href="#5ppp">#</a></h3>
<p>PPP（Point-to-Point Protocol）是指点对点，即1对1连接计算机的协议。PPP相当于位于OSI参考模型第2层的数据链路层。</p>
<p>PPP不像以太网和FDDI。后两者不仅与OSI参考模型的数据链路层有关，还与第1层的物理层有关。具体来讲，以太网使用同轴电缆或双 绞线电缆，它可以决定其中的0、1该被解释为何种电子信号。与之相比，==PPP属于纯粹的数据链路层，与物理层没有任何关系。==换句话说，仅有PPP无法实现通信，还需要有物理层的支持。</p>
<p>PPP可以使用电话线或ISDN、专线、ATM线路。此外，近些年人们更多是在用ADSL或有线电视==通过PPPoE（PPP over Ethernet）实现互联网接入==。PPPoE是在以太网的数据中加入PPP帧进行传输的一种方式。</p>
<p>有些互联网接入服务商在以太网上利用==PPPoE（PPP over Ethernet）== 提供PPP功能。</p>
<p>单纯的以太网没有验证功能，也没有建立和断开连接的处理，因此无法按时计费。而如果采用PPPoE管理以太网连接，就可以利用PPP的验证等功能使各家ISP可以有效地管理终端用户的使用。</p>
<h3 id="6其他数据链路">6.其他数据链路<a hidden class="anchor" aria-hidden="true" href="#6其他数据链路">#</a></h3>
<p><strong>ATM</strong></p>
<p>ATM（Asynchronous Transfer Mode）是以一个叫做信元（5字节首部加48字节数据）的单位进行传输的数据链路，由于其线路占用时间短和能够高效传输大容量数据等特点主要用于广域网络的连接。</p>
<p><strong>POS</strong></p>
<p>POS（Packet over SDH/SONET）是一种在SDH（Synchronous Digital Hierarchy，同步数字体系） （SONET（Synchronous Optical NETwork，同步光纤网络） ）上进行包通信的一种协议。 SDH（SONET）是在光纤上传输数字信号的物理层规范。</p>
<p><strong>FDDI</strong></p>
<p>FDDI（Fiber Distributed Data Interface）叫做光纤分布式数据接口。 曾几何时，人们为了用光纤和双绞线实现100Mbps的传输速率，在主干网或计算机之间的高速连接上广泛使用了FDDI。但是由于后来高速LAN提供了Gbps级的传输速率，FDDI也就逐渐淡出了应用领域。</p>
<p><strong>Token Ring</strong></p>
<p>令牌环网（Token Ring）源自IBM开发的令牌环LAN技术，可以实现4Mbps或16Mbps传输速率。前面提到的FDDI实际上是扩展了Token Ring的一个产物。</p>
<p><strong>100VG-AnyLAN</strong></p>
<p>100VG-AnyLAN是IEEE802.12规范定义的一种网络协议。它以语音级的3类UTP电缆实现100Mbps的传输速率。它的数据帧格式既能应对以太网又能应对令牌环网。鉴于100Mbps以太网（100BASE-TX）的普及，100VG-AnyLAN也几乎不再被使用。</p>
<p><strong>光纤通道</strong></p>
<p>光纤通道（Fiber Channel）是实现高速数据通信的一种数据链路。 与其说它是一种网络，不如说它更像是SCSI那样类似于连接计算机周边设备的总线一样的规范。数据传输速率为133Mbpx～4Gbps。近些年被广泛用于搭建SAN（Storage Area Network，存储域网络。服务器与多台存储设备（硬盘、磁带备份）之间高速传输数据的网络系统。一般在企业当中用于保存超大容量数据） ，成为其主要数据链路。</p>
<p><strong>HIPPI</strong></p>
<p>HIPPI用于连接超大型计算机传输速率为800Mbps或1.6Gbps。铜缆的实际传输距离在25米以内，但是如果使用光纤作为传输介质时，可以延长到数公里。</p>
<p><strong>IEEE1394</strong></p>
<p>也叫FireWire或i.Link，是面向家庭的局域网，主要用于连接AV等计算机外围设备。数据传输速率为100～800Mbps以上。</p>
<p><strong>HDMI</strong></p>
<p>HDMI是High-Definition Multimedia Interface的缩写，意为高清晰度多媒体接口。它可以通过一根缆线实现图像和声音等数字信号的高品质传输。曾主要用于DVD/蓝光播放器、录像机、AV功放等设备与电视机、投影仪的连接，现在也逐渐开始用于计算机或平板电脑、数码相机与显示器的连接。</p>
<p><strong>iSCSI</strong></p>
<p>它是将个人电脑连接硬盘的SCSI标准应用于TCP/IP网络上的一种标准（RFC3720、RFC3783） 。它把SCSI的命令和数据包含进IP包内，进行数据传输。由此，人们就可以像使用个人电脑内嵌的SCSI硬盘一样使用网络上直连的大规模硬盘了。</p>
<p><strong>InfiniBand</strong></p>
<p>InfiniBand是针对高端服务器的一种超高速传输接口技术。它最大的特点是高速、高可靠性以及低延迟。它支持多并发链接，将多个线缆（如4链接或12链接。）合并为一个线缆。可以实现从2Gbps至数百Gbps的传输速率。以后甚至还计划提供数千Gbps的高速传输速率。</p>
<p><strong>DOCSIS</strong></p>
<p>DOCSIS是有线电视（CATV）传输数据的行业标准，由MCNS（Multidedia Cable Network System Patners Limited） 制定。该标准定义了有线电视的同轴电缆与Cable Modem（电缆调制解调器）的连接及其与以太网进行转换的具体规范。此外，有一个叫做CableLabs（有线电视业界的研究开发机构）的组织对Cable Modem进行认证。</p>
<p><strong>高速PLC</strong></p>
<p>高速PLC（Power line Communication，高速电力线通信。） 是指在家里或办公室内利用电力线上数MHz～数十MHz频带范围，实现数十Mbps～200Mbps传输速率的一种通信方式。使用电力线不用重新布线，也能进行日常生活以及家电设备或办公设备的控制。然而，本不是为通信目的而设计的电力线在传输高频信号时，极容易收到电波干扰，一般仅限于室内（家里、办公室内）使用。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303172.png" alt="image-20220421144256191"  />
</p>
<h3 id="7公共网络">7.公共网络<a hidden class="anchor" aria-hidden="true" href="#7公共网络">#</a></h3>
<p>所谓的公共通信服务类似于电信运营商（如NTT、KDDI或软银等）提供的电话网络。人们通过与这些运营商签约、付费不仅可以实现联网还可以与距离遥远的机构组织进行通信。</p>
<p>主要包括==模拟电话线路、移动通信、ADSL、FTTH、有线电视、专线、VPN以及公共无线LAN==等。</p>
<h2 id="第4章-ip协议">第4章 IP协议<a hidden class="anchor" aria-hidden="true" href="#第4章-ip协议">#</a></h2>
<p>IP（Internet Protocol，网际协议）作为整个TCP/IP中至关重要的协议，主要负责==将数据包发送给最终的目标计算机==。因此，IP能够让世界上任何两台计算机之间进行通信。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303189.png" alt="image-20220421150114428"  />
</p>
<h3 id="1ip即网际协议">1.<strong>IP</strong>即网际协议<a hidden class="anchor" aria-hidden="true" href="#1ip即网际协议">#</a></h3>
<p>TCP/IP的心脏是互联网层。这一层主要由==IP（Internet Protocol）==和 ==ICMP（Internet Control Message Protocol）==两个协议组成。</p>
<p>==IP（IPv4、IPv6）相当于OSI参考模型中的第3层——网络层==。 网络层的主要作用是“实现终端节点之间的通信”。这种终端节点之间的通信也叫“点对点（end-to-end）通信”。 从前面的章节可知，网络层的下一层——数据链路层的主要作用是在互连同一种数据链路的节点之间进行包传递。而一旦跨越多种数据链路，就需要借助网络层。==网络层可以跨越不同的数据链路==，即使是在不同的数据链路上也能实现两端节点之间的数据包传输。</p>
<h4 id="网络层与数据链路层的关系">网络层与数据链路层的关系<a hidden class="anchor" aria-hidden="true" href="#网络层与数据链路层的关系">#</a></h4>
<p>数据链路层提供==直连两个设备之间==的通信功能。与之相比，作为网络层的IP则负责在==没有直连的两个网络之间==进行通信传输。那么为什么一定需要这样的两个层次呢？它们之间的区别又是什么呢？</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303333.png" alt="image-20220421151740804"  />
</p>
<p>计算机网络中也需要数据链路层和网络层这个分层才能实现向最终目标地址的通信。</p>
<h3 id="2ip基础知识">2.<strong>IP</strong>基础知识<a hidden class="anchor" aria-hidden="true" href="#2ip基础知识">#</a></h3>
<p>IP大致分为三大作用模块，它们是==IP寻址、路由（最终节点为止的转发）以及IP分包与组包==。</p>
<p><strong>主机与节点</strong></p>
<p>在互联网世界中，将那些配有IP地址的设备叫做“主机”。可以是超大型计算机，也可以是小型计算机。这是因为互联网在当初刚发明的时候，只能连接这类大型的设备，因此习惯上就将配有IP地址的设备称为“主机”。然而，准确地说，==主机的定义应该是指“配置有IP地址，但是不进行路由控制==（路由控制英文叫做Routing，是指中转分组数据包） 的设备”。==既配有IP地址又具有路由控制能力的设备叫做“路由器”==，跟主机有所区别。而==节点则是主机和路由器的统称==（这些都是IPv6的规范RFC2460中所使用的名词术语。在IPv4的规范RFC791中，将具有路由控制功能的设备叫做“网关”，然而现在都普遍叫做路由器（或3层交换机）） 。</p>
<p>==路由控制（Routing）==是指将分组数据发送到最终目标地址的功能。即使网络非常复杂，也可以通过路由控制确定到达目标地址的通路。</p>
<p><strong>路由控制表</strong></p>
<p>为了将数据包发给目标主机，所有主机都维护着一张路由控制表（Routing Table）。该表记录IP数据在下一步应该发给哪个路由器。IP包将根据这个路由表在各个数据链路上传输。</p>
<p><strong>数据链路的抽象化</strong></p>
<p>IP是实现多个数据链路之间通信的协议。数据链路根据种类的不同各有特点。对这些不同数据链路的相异特性进行抽象化也是IP的重要作用之一。</p>
<p>==IP分片处理（IP Fragmentation）==。顾名思义，所谓分片处理是指，将较大的IP包分成多个较小的IP包 。分片的包到了对端目标地址以后会再被组合起来传给上一层。即从IP的上次层看，它完全可以忽略数据包在途中的各个数据链路上的MTU，而只需要按照源地址发送的长度接收数据包。IP就是以这种方式抽象化了数据链路层，使得从上层更不容易看到底层网络构造的细节。</p>
<p><strong>IP属于面向无连接型</strong></p>
<p>==IP面向无连接。即在发包之前，不需要建立与对端目标地址之间的连接。==上层如果遇到需要发送给IP的数据，该数据会立即被压缩成IP包发送出去。</p>
<p>为什么IP要采用面向无连接呢？</p>
<p>主要有两点原因：一是为了简化，二是为了提速。面向连接比起面向无连接处理相对复杂。甚至管理每个连接本身就是一个相当繁琐的事情。此外，每次通信之前都要事先建立连接，又会降低处理速度。需要有连接时，可以委托上一层提供此项服务。因此，IP为了实现简单化与高速化采用面向无连接的方式。</p>
<p>为了提高可靠性，==上一层的<strong>TCP</strong>采用面向有连接型==。</p>
<h3 id="3ip地址的基础知识">3.<strong>IP</strong>地址的基础知识<a hidden class="anchor" aria-hidden="true" href="#3ip地址的基础知识">#</a></h3>
<p><strong>IP地址的定义</strong></p>
<p>IP地址（IPv4地址）由==32位正整数==来表示。TCP/IP通信要求将这样的IP地址分配给每一个参与通信的主机。IP地址在计算机内部以二进制（二进制是指用0、1表示数字的方法。） 方式被处理。然而，由于人类社会并不习惯于采用二进制方式，需要采用一种特殊的标记方式。==那就是将32位的IP地址以每8位为一组，分成4组，每组以“.”隔开，再将每组数转换为十进制数==（这种方法也叫做“十进制点符号”（Dot- decimal notation）） 。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303348.png" alt="image-20220421154658544"  />
</p>
<p><strong>IP地址由网络和主机两部分标识组成</strong></p>
<p>IP地址由==“网络标识（网络地址）”和“主机标识（主机地址）”==两部分组成（192.168.128.10/24中的“/24”表示从第1位开始到多少位属于网络标识。在这个例子中，192.168.128之前的都是该IP的网络地址）。</p>
<p>网络标识在数据链路的每个段配置不同的值。网络标识必须保证==相互连接的每个段的地址不相重复==。而==相同段内相连的主机必须有相同的网络地址==。IP地址的==“主机标识”则不允许在同一个网段内重复出现==。</p>
<p>究竟从第几位开始到第几位算是网络标识，又从第几位开始到第几位算是主机标识呢？关于这点，有约定俗成的两种类型。最初二者以==分类进行区别==。而现在基本以==子网掩码（网络前缀）==区分。不过，请读者注意，在有些情况下依据部分功能、系统和协议的需求，前一种的方法依然存在。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303366.png" alt="image-20220421155818176"  />
</p>
<h4 id="ip地址的分类"><strong>IP地址的分类</strong><a hidden class="anchor" aria-hidden="true" href="#ip地址的分类">#</a></h4>
<p>IP地址分为四个级别，分别为A类、B类、C类、D类（还有一个一直未使用的E类。） 。它根据IP地址中从第1位到第4位的比特列对其网络标识和主机标识进行区分。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303386.png" alt="image-20220421160356386"  />
</p>
<p><strong>■ A</strong>类地址</p>
<p>A类IP地址是首位以“0”开头的地址。从第1位到第8位（去掉分类位剩下7位） 是它的网络标识。用十进制表示的话，0.0.0.0～127.0.0.0是A类的网络地址。A类地址的后24位相当于主机标识。因此，一个网段内可容纳的主机地址上限为16，777，214个 。</p>
<p><strong>■ B</strong>类地址</p>
<p>B类IP地址是前两位为“10”的地址。从第1位到第16位（去掉分类位剩下14位）是它的网络标识。用十进制表示的话，128.0.0.1～ 191.255.0.0是B类的网络地址。B类地址的后16位相当于主机标识。因此，一个网段内可容纳的主机地址上限为65，534个。</p>
<p><strong>■ C</strong>类地址</p>
<p>C类IP地址是前三位为“110”的地址。从第1位到第24位（去掉分类位剩下21位）是它的网络标识。用十进制表示的话，192.168.0.0～ 239.255.255.0是C类的网络地址。C类地址的后8位相当于主机标识。因此，一个网段内可容纳的主机地址上限为254个 。</p>
<p><strong>■ D</strong>类地址</p>
<p>D类IP地址是前四位为“1110”的地址。从第1位到第32位（去掉分类位剩下28位） 是它的网络标识。用十进制表示的话，224.0.0.0～239.255.255.255是D类的网络地址。D类地址没有主机标识，常被用于多播。</p>
<p><strong>■</strong> 关于分配<strong>IP</strong>主机地址的注意事项</p>
<p>在分配IP地址时关于主机标识有一点需要注意。即要用比特位表示主机地址时，不可以全部为0或全部为1。因为全部为只有0在表示对应的网络地址或IP地址不可获知的情况下才使用。而全部为1的主机地址通常作为广播地址。 因此，在分配过程中，应该去掉这两种情况。这也是为什么C类地址每个网段最多只能有254（28 -2=254）个主机地址的原因。</p>
<p><strong>广播地址</strong></p>
<p>广播地址用于在同一个链路中相互连接的主机之间发送数据包。将IP地址中的主机地址部分全部设置为1，就成为了广播地址（以太网中如果将MAC地址的所有位都改为1，则形成FF：FF：FF：FF：FF：FF的广播地址。因此，广播的IP包以数据链路的帧的形式发送时，得通过MAC地址为全1比特的FF：FF：FF：FF：FF：FF转发。）</p>
<p>广播分为==本地广播==和==直接广播==两种。</p>
<p>在本网络内的广播叫做本地广播。例如网络地址为192.168.0.0/24的情况下，广播地址是192.168.0.255。因为这个广播地址的IP包会被路由器屏蔽，所以不会到达192.168.0.0/24以外的其他链路上。</p>
<p>在不同网络之间的广播叫做直接广播。例如网络地址为192.168.0.0/24的主机向192.168.1.255/24的目标地址发送IP包。收到这个包的路由器，将数据转发给192.168.1.0/24，从而使得所有192.168.1.1～ 192.168.1.254的主机都能收到这个包（由于直接广播有一定的安全问题，多数情况下会在路由器上设置为不转发） 。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303554.png" alt="image-20220421161444639"  />
</p>
<p><strong>IP多播</strong></p>
<p><strong>■</strong>同时发送提高效率</p>
<p>==多播用于将包发送给特定组内的所有主机==。由于其直接使用IP协议，因此也不存在可靠传输。</p>
<p>多播这种既可以穿透路由器，又可以实现只给那些必要的组发送数据包的技术就成为必选之路了。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303575.png" alt="image-20220421161604378"  />
</p>
<p><strong>■ IP</strong>多播与地址</p>
<p>多播使用D类地址。因此，如果从首位开始到第4位是“1110”，就可以认为是多播地址。而剩下的28位可以成为多播的组编号。 从224.0.0.0到239.255.255.255都是多播地址的可用范围。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303593.png" alt="image-20220421161628474"  />
</p>
<h4 id="子网掩码">子网掩码<a hidden class="anchor" aria-hidden="true" href="#子网掩码">#</a></h4>
<p>自从引入了子网以后，一个IP地址就有了两种识别码。==一是IP地址本身，另一个是表示网络部的子网掩码。==子网掩码用二进制方式表示的话，也是一个32位的数字。它对应IP地址网络标识部分的位全部为“1”，对应IP地址主机标识的部分则全部为“0”。由此，一个IP地址可以不再受限于自己的类别，而是可以用这样的子网掩码自由地定位自己的网络标识长度。当然，子网掩码必须是IP地址的首位开始连续的“1”。</p>
<p>对于子网掩码，目前有两种表示方式。以172.20.100.52的前26位是网络地址的情况为例，以下是其中一种表示方法，它将IP地址与子网掩码的地址分别用两行来表示。</p>
<img src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303609.png" alt="image-20220421162805890"  /> 
<p>另一种表示方式如下所示。它在每个IP地址后面追加网络地址的位数（这种方式也叫“后缀”表示法。） 用“/”隔开。</p>
<p>不难看出，在第二种方式下记述网络地址时可以省略后面的“0”。例如172.20.0.0/16跟172.20/16其实是一个意思。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303627.png" alt="image-20220421162830838"  />
</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303812.png" alt="image-20220421162842834"  />
</p>
<h4 id="cidr与vlsm"><strong>CIDR</strong>与<strong>VLSM</strong><a hidden class="anchor" aria-hidden="true" href="#cidr与vlsm">#</a></h4>
<p>采用任意长度分割IP地址的网络标识和主机标识。这种方式叫做==CIDR==，意为“无类别域间路由”。 由于BGP（Border Gateway Protocol，边界网关协议）对应了CIDR，所以不受IP地址分类的限制自由分配（Classless Inter-Domain Routing） 。</p>
<p>在CIDR被应用到互联网的初期，网络内部采用固定长度的子网掩码机制。也就是说，当子网掩码的长度被设置为/25以后，域内所有的子网掩码都得使用同样的长度。然而，有些部门可能有500台主机，另一些部门可能只有50台主机。如果全部采用统一标准，就难以架构一个高效的网络结构。为此人们提出组织内要使用可变长度的、高效的IP地 址分配方式。</p>
<p>于是产生了一种可以随机修改组织内各个部门的子网掩码长度的机制——==VLSM（可变长子网掩码）（Variable Length Subnet Mask）== 。它可以通过域间路由协议转换为RIP2（7.4.5节）以及OSPF（7.5节） 实现。根据VLSM可以将网络地址划分为主机数为500个时子网掩码长度为/23，主机数为50个时子网掩码长度为/26。从而在理论上可以将IP地址的利用率提高至50％。</p>
<p>有了CIDR和VLSM技术，确实相对缓解了全局IP地址（为了对应全局IP地址不足的问题，除了CIDR和VLSM之外还有NAT（5.6节）、代理服务器（1.9.7节）等技术） 不够用的问题。==但是IP地址的绝对数本身有限的事实无法改变==。因此才会出现本章4.6节中将要介绍的==IPv6==等IPv4以外的方法。</p>
<h4 id="全局地址与私有地址">全局地址与私有地址<a hidden class="anchor" aria-hidden="true" href="#全局地址与私有地址">#</a></h4>
<p>对于那些没有连接互联网的独立网络中的主机，只要保证在这个网络内地址唯一，可以不用考虑互联网即可配置相应的IP地址。不过，即使让每个独立的网络各自随意地设置IP地址，也可能会有问题。于是又出现了私有网络的IP地址。它的地址范围如下所示：</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303832.png" alt="image-20220421164414495"  />
</p>
<p>==包含在这个范围内的IP地址都属于私有IP==，而在此之外（A类～C类范围中除去0/8、127/8） 的IP地址称为全局IP（也叫公网IP）</p>
<p>私有IP最早没有计划连接互联网，而只用于互联网之外的独立网络。然而，当一种能够互换私有IP与全局IP的NAT（更多细节请参考5.6节） 技术诞生以后，配有私有地址的主机与配有全局地址的互联网主机实现了通信。</p>
<p>全局IP地址基本上要在整个互联网范围内保持唯一 ，但私有地址不需要。只要在同一个域里保证唯一即可。在不同的域里出现相同的私有IP不会影响使用。</p>
<h3 id="4路由控制">4.路由控制<a hidden class="anchor" aria-hidden="true" href="#4路由控制">#</a></h3>
<p>发送数据包时所使用的地址是网络层的地址，即IP地址。然而仅仅有IP地址还不足以实现将数据包发送到对端目标地址，在数据发送过程中还需要类似于“指明路由器或主机”的信息，以便真正发往目标地址。保存这种信息的就是==路由控制表（Routing Table）==。实现IP通信的主机和路由器都必须持有一张这样的表。它们也正是在这个表格的基础上才得以进行数据包发送的。</p>
<p>该路由控制表的形成方式有两种：一种是管理员手动设置，另一种是路由器与其他路由器相互交换信息时自动刷新。前者也叫==静态路由控制==，而后者叫做==动态路由控制==。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303848.png" alt="image-20220421170059171"  />
</p>
<p><strong>■</strong> 默认路由</p>
<p>如果一张路由表中包含所有的网络及其子网的信息，将会造成无端的浪费。这时，==默认路由（Default Route）==是不错的选择。默认路由是指路由表中任何一个地址都能与之匹配的记录。 ==默认路由一般标记为0.0.0.0/0或default（表示子网掩码时，IP地址为0.0.0.0，子网掩码也是0.0.0.0）== 。这里的0.0.0.0/0并不是指IP地址是0.0.0.0。由于后面是“/0”，所以并没有标识IP地址（0.0.0.0的IP地址应该记述为0.0.0.0/32） 。它只是为了避免人们误以为0.0.0.0是IP 地址。有时默认路由也被标记为default，但是在计算机内部和路由协议的发送过程中还是以0.0.0.0/0进行处理。</p>
<p><strong>■</strong> 主机路由</p>
<p>==“IP地址/32”也被称为主机路由（Host Route）==。例如， ==192.168.153.15/32（表示子网掩码时，若IP地址为192.168.153.15，其对应的子网掩码为255.255.255.255）== 就是一种主机路由。它的意思是整个IP地址的所有位都将参与路由。进行主机路由，意味着要基于主机上网卡上配置的IP地址本身，而不是基于该地址的网络地址部分进行路由。</p>
<p><strong>■</strong> 环回地址</p>
<p>环回地址是==在同一台计算机上的程序之间进行网络通信时所使用的一个默认地址==。计算机使用一个特殊的IP地址==127.0.0.1==作为环回地址。与该地址具有相同意义的是一个叫做==localhost==的主机名。使用这个IP或主机名时，数据包不会流向网络。</p>
<p><strong>路由控制表的聚合</strong></p>
<p>利用网络地址的比特分布可以有效地进行分层配置。对内即使有多个子网掩码，对外呈现出的也是同一个网络地址。这样可以更好地构建网络，==通过路由信息的聚合可以有效地减少路由表的条目（路由表的聚合也叫路由汇总（Aggregation））== 。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303868.png" alt="image-20220421170442566"  />
</p>
<h3 id="5ip分割处理与再构成处理">5.<strong>IP</strong>分割处理与再构成处理<a hidden class="anchor" aria-hidden="true" href="#5ip分割处理与再构成处理">#</a></h3>
<p><strong>数据链路不同，MTU则相异</strong></p>
<p><strong>IP报文的分片与重组</strong></p>
<p>任何一台主机都有必要对IP分片（IP Fragmentation）进行相应的处理。分片往往在网络上遇到比较大的报文无法一下子发送出去时才会进行处理。</p>
<p>图4.24展示了网络传输过程中进行分片处理的一个例子。由于以太网的默认MTU是1500字节，因此4342字节的IP数据报无法在一个帧当中发送完成。这时，==路由器将此IP数据报划分成了3个分片进行发送==。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303969.png" alt="image-20220421214305039"  />
</p>
<p>这样的处理是由诸多方面的因素造成的。例如，现实当中无法保证IP数据报是否经由同一个路径传送。因此，途中即使等待片刻，数据包也有可能无法到达目的地。此外，拆分之后的每个分片也有可能会在途中丢失（在目标主机上进行分片的重组时，可能有一部分包会延迟到达。因此，一般会从第一个数据报的分片到达的那一刻起等待约30秒再进行处理） 。即使在途中某一处被重新组装，但如果下一站再经过其他路由时还会面临被分片的可能。这会给路由器带来多余的负担，也会降低网络传送效率。出于这些原因，在终结点（目标主机）端重组分片了的IP数据报成为现行的规范。</p>
<p><strong>路径MTU发现</strong></p>
<p>分片机制也有它的不足。首先，路由器的处理负荷加重。随着时代的变迁，计算机网络的物理传输速度不断上升。这些高速的链路，对路由器和计算机网络提出了更高的要求。另一方面，随着人们对网络安全的要求提高，路由器需要做的其他处理也越来越多，如网络过滤等。因此，只要允许，是==不希望由路由器进行IP数据包的分片处理的==。</p>
<p>为了应对以上问题，产生了一种新的技术==“路径MTU发现”（Path MTU Discovery（也可以缩写为PMTUD））==</p>
<p>路径MTU（Path MTU）是指从发送端主机到接收端主机之间不需要分片时最大MTU的大小。</p>
<p>路径MTU发现从发送主机按照路径MTU的大小将数据报分片后进行发送。进行路径MTU发现，就可以==避免在中途的路由器上进行分片处理，也可以在TCP中发送更大的包==。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303086.png" alt="image-20220421214819164"  />
</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303107.png" alt="image-20220421214825873"  />
</p>
<h3 id="6ipv6">6.<strong>IPv6</strong><a hidden class="anchor" aria-hidden="true" href="#6ipv6">#</a></h3>
<p>IPv6（IP version 6）是为了根本解决IPv4地址耗尽的问题而被标准化的网际协议。IPv4的地址长度为4个8位字节，即32比特。而IPv6的地址长度则是原来的4倍，即128比特（因此IPv6的地址空间是IPv4的2^96^=7.923×10^28^ 倍） ，一般写成8个16位字节。</p>
<h4 id="ipv6的特点"><strong>IPv6</strong>的特点<a hidden class="anchor" aria-hidden="true" href="#ipv6的特点">#</a></h4>
<ul>
<li>IP地址的扩大与路由控制表的聚合</li>
</ul>
<p>IP地址依然适应互联网分层构造。分配与其地址结构相适应的IP地址，尽可能避免路由表膨大。</p>
<ul>
<li>性能提升</li>
</ul>
<p>包首部长度采用固定的值（40字节），不再采用首部检验码。简化首部结构，减轻路由器负荷。路由器不再做分片处理（通过路径MTU发现只由发送端主机进行分片处理）。</p>
<ul>
<li>支持即插即用功能</li>
</ul>
<p>即使没有DHCP服务器也可以实现自动分配IP地址。</p>
<ul>
<li>采用认证与加密功能</li>
</ul>
<p>应对伪造IP地址的网络安全功能以及防止线路窃听的功能 （IPsec）。</p>
<ul>
<li>多播、Mobile IP成为扩展功能</li>
</ul>
<p>多播和Mobile IP被定义为IPv6的扩展功能。由此可以预期，曾在 IPv4中难于应用的这两个功能在IPv6中能够顺利使用。</p>
<h4 id="ipv6中ip地址的标记方法"><strong>IPv6</strong>中<strong>IP</strong>地址的标记方法<a hidden class="anchor" aria-hidden="true" href="#ipv6中ip地址的标记方法">#</a></h4>
<p>IPv6的IP地址长度为128位。它所能表示的数字高达38位数（2^128^ = 约3.40×10^38^）</p>
<p>如果将IPv6的地址像IPv4的地址一样用十进制数据表示的话，是16个数字的序列（IPv4是4个数字的序列）。由于用16个数字序列表示显得有些麻烦，因此，将IPv6和IPv4在标记方法上进行区分。一般人们将128比特IP地址以==每16比特为一组，每组用冒号（“：”）隔开进行标记==。而且如果出现连续的0时还可以将这些0省略，并用两个冒号 （“：：”）隔开。但是，一个IP地址中只允许出现一次两个连续的冒号。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303129.png" alt="image-20220421220523670"  />
</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303147.png" alt="image-20220421220529306"  />
</p>
<h4 id="ipv6地址的结构"><strong>IPv6</strong>地址的结构<a hidden class="anchor" aria-hidden="true" href="#ipv6地址的结构">#</a></h4>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303344.png" alt="image-20220421220604163"  />
</p>
<h3 id="7ipv4首部以及ipv6首部">7.IPv4首部以及IPv6首部<a hidden class="anchor" aria-hidden="true" href="#7ipv4首部以及ipv6首部">#</a></h3>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303360.png" alt="image-20220421222534153"  />
</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303377.png" alt="image-20220421222548829"  />
</p>
<h2 id="第5章-ip协议相关技术">第5章 IP协议相关技术<a hidden class="anchor" aria-hidden="true" href="#第5章-ip协议相关技术">#</a></h2>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303394.png" alt="image-20220424121849556"  />
</p>
<h3 id="1dns">1.DNS<a hidden class="anchor" aria-hidden="true" href="#1dns">#</a></h3>
<p>**主机识别码：**这种识别方式是指为每台计算机赋以唯一的主机名，在进行网络通信时可以直接使用主机名称而无需输入一大长串的IP地址。并且此时，系统必须自动将主机名转换为具体的IP地址。为了实现这样的功能，主机往往会利用一个叫做hosts的数据库文件。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303412.png" alt="image-20220424122838242"  />
</p>
<p><strong>域名服务器</strong></p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303623.png" alt="image-20220424123713543"  />
</p>
<p>域名服务器是指管理域名的主机和相应的软件，它可以管理所在分层的域的相关信息。 每层都设有一个域名服务器。根域名服务器中注册着根以下第1层域名服务器的IP地址。</p>
<p>域名和域名服务器需要按照分层进行设置。</p>
<p>所有的域名服务器都必须注册根域名服务器的IP地址。因为DNS根据IP地址进行检索时，需要从根域名服务器开始按顺序进行。</p>
<p><strong>解析器（Resolver）</strong></p>
<p>进行DNS查询的主机和软件叫做DNS解析器。用户所使用的工作站或个人电脑都属于解析器。一个解析器至少要注册一个以上域名服务器的IP地址。通常，它至少包括组织内部的域名服务器的IP地址。</p>
<p><strong>DNS查询</strong></p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303641.png" alt="image-20220424130212369"  />
</p>
<h3 id="2arp">2.<strong>ARP</strong><a hidden class="anchor" aria-hidden="true" href="#2arp">#</a></h3>
<p>==ARP（Address Resolution Protocol）==是一种解决地址问题的协议。以目标IP地址为线索，用来定位下一个应该接收数据分包的网络设备对应的MAC地址。如果目标主机不在同一个链路上时，可以通过ARP查找下一跳路由器的MAC地址。不过ARP只适用于IPv4，不能用于IPv6。IPv6中可以用ICMPv6替代ARP发送邻居探索消息。</p>
<p><strong>ARP的工作机制</strong></p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303661.png" alt="image-20220424131424074"  />
</p>
<p>主机A为了获得主机B的MAC地址，起初要通过广播发送一个ARP请求包。这个包中包含了想要了解其MAC地址的主机IP地址。也就是说，ARP请求包中已经包含了主机B的IP地址172.20.1.2。由于广播的包可以被同一个链路上所有的主机或路由器接收，因此ARP的请求包也就会被这同一个链路上所有的主机和路由器进行解析。如果ARP请求包中的目标IP地址与自己的IP地址一致，那么这个节点就将自己的MAC地址塞入ARP响应包返回给主机A。</p>
<p><strong>RARP</strong></p>
<p>RARP（Reverse Address Resolution Protocol）是将ARP反过来，从MAC地址定位IP地址的一种协议。例如将打印机服务器等小型嵌入式设备接入到网络时就经常会用得到。</p>
<p>平常我们可以通过个人电脑设置IP地址，也可以通过DHCP（Dynamic Host Configuration Protocol， DHCP可以像RARP一样分配一个固定的IP地址） 自动分配获取IP地址。 然而，对于使用嵌入式设备时，会遇到没有任何输入接口或无法通过 DHCP动态获取IP地址的情况 。</p>
<p>在类似情况下，就可以使用RARP。为此，需要架设一台RARP服务器，从而在这个服务器上注册设备的MAC地址及其IP地址（使用RARP的前提是认为MAC地址就是设备固有的一个值） 。然后再将这个设备接入到网络，插电启动设备时，该设备会发送一条“我的MAC地址是xxx，请告诉我，我的IP地址应该是什么”的请求信息。RARP服务器接到这个消息后返回类似于“MAC地址为xxx的设备，IP地址为xxx”的信息给这个设备。而设备就根据从RARP服务器所收到的应答信息设置自己的IP地址。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303680.png" alt="image-20220424131947846"  />
</p>
<h3 id="3icmp">3.<strong>ICMP</strong><a hidden class="anchor" aria-hidden="true" href="#3icmp">#</a></h3>
<p>架构IP网络时需要特别注意两点：确认网络是否正常工作，以及遇到异常时进行问题诊断。</p>
<p>ICMP的主要功能包括，==确认IP包是否成功送达目标地址，通知在发送过程当中IP包被废弃的具体原因，改善网络设置等==。有了这些功能以后，就可以获得网络是否正常、设置是否有误以及设备有何异常等信息，从而便于进行网络上的问题诊断。</p>
<p>在IP通信中如果某个IP包因为某种原因未能达到目标地址，那么这个具体的原因将由ICMP负责通知。</p>
<p>ICMP的消息大致可以分为两类：一类是==通知出错原因的错误消息==，另一类是==用于诊断的查询消息==。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303837.png" alt="image-20220424133541335"  />
</p>
<p>表5.2 ICMP消息类型</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303851.png" alt="image-20220424133557237"  />
</p>
<h4 id="主要的icmp消息">主要的<strong>ICMP</strong>消息<a hidden class="anchor" aria-hidden="true" href="#主要的icmp消息">#</a></h4>
<p><strong>■ ICMP</strong>目标不可达消息（类型<strong>3</strong>）</p>
<p>IP路由器无法将IP数据包发送给目标地址时，会给发送端主机返回一个目标不可达（Destination Unreachable Message）的ICMP消息，并在这个消息中显示不可达的具体原因</p>
<p><strong>■ ICMP</strong>重定向消息（类型<strong>5</strong>）</p>
<p>如果路由器发现发送端主机使用了次优的路径发送数据，那么它会返回一个ICMP重定向（ICMP Redirect Message）的消息给这个主机。在这个消息中包含了最合适的路由信息和源数据。这主要发生在路由器持有更好的路由信息的情况下。路由器会通过这样的ICMP消息给发送端主机一个更合适的发送路由。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303872.png" alt="image-20220424142623208"  />
</p>
<p><strong>■ ICMP</strong>超时消息（类型<strong>11</strong>）</p>
<p>IP包中有一个字段叫做TTL（Time To Live，生存周期），它的值随着每经过一次路由器就会减1（当IP包在路由器上停留1秒以上时减去所停留的秒数，但是现在绝大多数设备并不做这样的处理。） ，直到减到0时该IP包会被丢弃。此时，IP路由器将会发送一个ICMP超时的消息（ICMP Time Exceeded Message，错误号0（错误号1表示将被拆分包做重构处理时超时） ）给发送端主机，并通知该包已被丢弃。</p>
<p><strong>■ ICMP</strong>回送消息（类型<strong>0</strong>、<strong>8</strong>）</p>
<p>用于进行通信的主机或路由器之间，判断所发送的数据包是否已经成功到达对端的一种消息。可以向对端主机发送回送请求的消息 （ICMP Echo Request Message，类型8），也可以接收对端主机发回来的回送应答消息（ICMP Echo Reply Message，类型0）。网络上最常用的==ping命令==（Packet InterNetwork Groper，判断对端主机是否可达的一种命令） 就是利用这个消息实现的。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303892.png" alt="image-20220424142748557"  />
</p>
<p><strong>■ ICMP</strong>原点抑制消息（类型<strong>4</strong>）</p>
<p>在使用低速广域线路的情况下，连接WAN的路由器可能会遇到网络拥堵的问题。ICMP原点抑制消息的目的就是为了缓和这种拥堵情况。当路由器向低速线路发送数据时，其发送队列的残存变为零而无法发送出去时，可以向IP包的源地址发送一个ICMP原点抑制（ICMP Source Quench Message）消息。收到这个消息的主机借此了解在整个线路的某一处发生了拥堵的情况，从而打开IP包的传输间隔。然而，由于这种ICMP可能会引起不公平的网络通信，一般不被使用。</p>
<p><strong>■ ICMP</strong>路由器探索消息（类型<strong>9</strong>、<strong>10</strong>）</p>
<p>主要用于发现与自己相连网络中的路由器。当一台主机发出ICMP路由器请求（Router Solicitaion，类型10）时，路由器则返回ICMP路由器公告消息（Router Advertisement，类型9）给主机。</p>
<p><strong>■ ICMP</strong>地址掩码消息（类型<strong>17</strong>、<strong>18</strong>）</p>
<p>主要用于主机或路由器想要了解子网掩码的情况。可以向那些目标主机或路由器发送ICMP地址掩码请求消息（</p>
<p>ICMP Address Mask Request，类型17），然后通过接收ICMP地址掩码应答消息（ICMP Address Mask Reply，类型18）获取子网掩码的信息。</p>
<h4 id="icmpv6"><strong>ICMPv6</strong><a hidden class="anchor" aria-hidden="true" href="#icmpv6">#</a></h4>
<p>IPv4中ICMP仅作为一个辅助作用支持IPv4。也就是说，在IPv4时期，即使没有ICMP，仍然可以实现IP通信。然而，在IPv6中，ICMP的作用被扩大，如果没有ICMPv6，IPv6就无法进行正常通信。</p>
<p>尤其在IPv6中，从IP地址定位MAC地址的协议从ARP转为ICMP的邻居探索消息（Neighbor Discovery）。这种邻居探索消息融合了IPv4的ARP、ICMP重定向以及ICMP路由器选择消息等功能于一体，甚至还提供自动设置IP地址的功能（ICMPv6中没有DNS服务器的通知功能，因此实际上需要与DHCPv6组合起来才能实现自动设置IP地址） 。</p>
<p><strong>■</strong> 邻居探索</p>
<p>ICMPv6中从类型133至类型137的消息叫做邻居探索消息。这种邻居探索消息对于IPv6通信起着举足轻重的作用。==邻居请求消息用于查询IPv6的地址与MAC地址的对应关系，并由邻居宣告消息得知MAC地址==（IPv4中查询IP地址与MAC地址对应关系用到的是ARP） 。邻居请求消息利用IPv6的多播地址（IPv4中所使用的ARP采用广播，使得不支持ARP的节点也会收到包，造成一定的浪费） 实现传输。</p>
<h3 id="4dhcp">4.<strong>DHCP</strong><a hidden class="anchor" aria-hidden="true" href="#4dhcp">#</a></h3>
<p>如果逐一为每一台主机设置IP地址会非常繁琐的事情。特别是在移动使用笔记本电脑、智能终端以及平板电脑等设备时，每移动到一个新的地方，都要重新设置IP地址。</p>
<p>于是，为了实现自动设置IP地址、统一管理IP地址分配，就产生了==DHCP（Dynamic Host Configuration Protocol）==协议。有了DHCP，计算机只要连接到网络，就可以进行TCP/IP通信。也就是说，DHCP让即插即用（指只要物理上一连通，无需专门设置就可以直接使用这个物理设备） 变得可能。而DHCP不仅在IPv4中，在IPv6中也可以使用。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303908.png" alt="image-20220424145708265"  />
</p>
<h4 id="dhcp的工作机制"><strong>DHCP</strong>的工作机制<a hidden class="anchor" aria-hidden="true" href="#dhcp的工作机制">#</a></h4>
<p>使用DHCP之前，首先要架设一台DHCP服务器（很多时候用该网段的路由器充当DHCP服务器） 。然后将DHCP所要分配的IP地址设置到服务器上。此外，还需要将相应的子网掩码、路由控制信息以及DNS服务器的地址等设置到服务器上。</p>
<p>关于从DHCP中获取IP地址的流程，以图5.17为例简单说明的话， 主要分为两个阶段（在发送DHCP发现包与DHCP请求包时，DHCP即插即用的IP地址尚未确定。因此，DHCP发现包的目标地址为广播地址255.255.255.255，而源地址则为0.0.0.0，表示未知） 。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303927.png" alt="image-20220424145825376"  />
</p>
<p>DHCP在分配IP地址有两种方法。一种是由DHCP服务器在特定的IP地址中自动选出一个进行分配。另一种方法是针对MAC地址 分配一个固定的IP地址。而且这两种方法可以并用。</p>
<p>为了检查所要分配的IP地址以及已经分配了的IP地址是否可用， DHCP服务器或DHCP客户端必须具备以下功能：</p>
<ul>
<li>DHCP服务器</li>
</ul>
<p>==在分配IP地址前发送ICMP回送请求包，确认没有返回应答。==</p>
<ul>
<li>DHCP客户端</li>
</ul>
<p>==针对从DHCP那里获得的IP地址发送ARP请求包，确认没有返回应答。==</p>
<p>在获得IP地址之前做这种事先处理可能会耗一点时间，但是可以安全地进行IP地址分配。</p>
<h4 id="dhcp中继代理"><strong>DHCP</strong>中继代理<a hidden class="anchor" aria-hidden="true" href="#dhcp中继代理">#</a></h4>
<p>家庭网络大多都只有一个以太网（无线LAN）的网段，与其连接的主机台数也不会太多。因此，只要有一台DHCP服务器就足以应对IP地址分配的需求，而大多数情况下都由宽带路由器充当这个DHCP的角色。</p>
<p>相比之下，一个企业或学校等较大规模组织机构的网络环境当中，一般会有多个以太网（无线LAN）网段。在这种情况下，若要针对每个网段都设置DHCP服务器将会是个庞大的工程。即使路由器可以分担DHCP的功能，如果网络中有不下100个路由器，就要为100个路由器设置它们各自可分配IP地址的范围，并对这些范围进行后续的变更维护，这将是一个极其耗时和难于管理的工作（DHCP服务器分配的IP地址范围，有时会随着服务器或打印机等固定IP设备的增减而不得不发生变化） 。也就是说将DHCP服务器分设到各个路由器上，于管理和运维都不是件有益的事。</p>
<p>因此，在这类网络环境中，往往需要将DHCP统一管理。具体方法可以使用==DHCP中继代理来实现==。有了DHCP中继代理以后，==对不同网段的IP地址分配也可以由一个DHCP服务器统一进行管理和运维==。</p>
<p>这种方法使得在每个网段架设一个DHCP服务器被取代，==只需在每个网段设置一个DHCP中继代理即可==（DHCP中继代理多数为路由器，不过也有在主机中安装某些软件得以实现的情况） 。==它可以设置DHCP服务器的IP地址==，从而可以在DHCP服务器上为每个网段注册IP地址的分配范围。</p>
<p>DHCP客户端会向DHCP中继代理发送DHCP请求包，而DHCP中继代理在收到这个广播包以后再以单播的形式发给DHCP服务器。服务器端收到该包以后再向DHCP中继代理返回应答，并由DHCP中继代理将此包转发给DHCP客户端（DHCP包中包含发出请求的主机的==MAC地址==。DHCP中继代理正是利用这个MAC地址将包返回给了DHCP客户端） 。由此，==DHCP服务器即使不在同一个链路上也可以实现统一分配和管理IP地址==。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303126.png" alt="image-20220424150633785"  />
</p>
<h3 id="5nat">5.<strong>NAT</strong><a hidden class="anchor" aria-hidden="true" href="#5nat">#</a></h3>
<p>NAT（Network Address Translator， <strong>网络地址转换</strong>）是用于==在本地网络中使用私有地址，在连接互联网时转而使用全局IP地址的技术==。除转换IP地址外，还出现了可以转换TCP、UDP端口号的==NAPT（Network Address Ports Translator）==技术，由此可以实现用一个全局IP地址与多个主机的通信（通常人们提到的NAT，多半是指NAPT。NAPT也叫做IP伪装或MultiNAT）</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303189.png" alt="image-20220424151332267"  />
</p>
<h4 id="nat的工作机制"><strong>NAT</strong>的工作机制<a hidden class="anchor" aria-hidden="true" href="#nat的工作机制">#</a></h4>
<p>如图5.19所示，以10.0.0.10的主机与163.221.120.9的主机进行通信为例。利用NAT，途中的NAT路由器将发送源地址从10.0.0.10转换为全局的IP地址（202.244.174.37）再发送数据。反之，当包从地址163.221.120.9发过来时，目标地址（202.244.174.37）先被转换成私有IP地址10.0.0.10以后再被转发（在TCP或UDP中，由于IP首部中的IP地址还要用于校验和的计算，因此当IP地址发生变化时，也需要相应地将TCP、UDP的首部进行转换） 。</p>
<p>==在NAT（NAPT）路由器的内部，有一张自动生成的用来转换地址的表==。当10.0.0.10向163.221.120.9发送第一个包时生成这张表，并按照表中的映射关系进行处理。</p>
<p>当私有网络内的多台机器同时都要与外部进行通信时，仅仅转换IP地址，人们不免担心全局IP地址是否不够用。这时采用如图5.20所示的包含端口号一起转换的方式==（NAPT）==可以解决这个问题。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303241.png" alt="image-20220424172722451"  />
</p>
<p>在使用TCP或UDP的通信当中，只有目标地址、源地址、目标端口、源端口以及协议类型（TCP还是UDP）五项内容都一致时才被认为是同一个通信连接。此时所使用的正是NAPT。</p>
<p>图5.20中，主机163.221.120.9的端口号是80，LAN中有两个客户端10.0.0.10和10.0.0.11同时进行通信，并且这两个客户端的本地端口都是1025。此时，仅仅转换IP地址为某个全局地址202.244.174.37，会令转换后的所有数字完全一致。为此，只要将10.0.0.11的端口号转换为1026就可以解决问题。如图5.20所示，生成一个NAPT路由器的转换表，就可以正确地转换地址跟端口的组合，令客户端A、B能同时与服务器之间进行通信。</p>
<h4 id="nat-ptnapt-pt"><strong>NAT-PT</strong>（<strong>NAPT-PT</strong>）<a hidden class="anchor" aria-hidden="true" href="#nat-ptnapt-pt">#</a></h4>
<p>现在很多互联网服务都基于IPv4。如果这些服务不能做到在IPv6中也能正常使用的话，搭建IPv6网络环境的优势也就无从谈起了。 为了解决这个问题，就产生了==NAT-PT（NAPT-PT）==（PT是 Protocol Translatio的缩写。严格来讲NAT-PT用来翻译IP地址，而NATP-PT则是用来翻译IP首部与端口号的） 规范。==NAT-PT是将IPv6的首部转换为IPv4的首部的一种技术==。有了这种技术，那些只有IPv6地址的主机也就能够与IPv4地址的其他主机进行通信了。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303260.png" alt="image-20220424172859517"  />
</p>
<h3 id="6ip隧道">6.<strong>IP</strong>隧道<a hidden class="anchor" aria-hidden="true" href="#6ip隧道">#</a></h3>
<p>在一个如图5.22所示的网络环境里，网络A、B使用IPv6，如果处于中间位置的网络C支持使用IPv4的话，网络A与网络B之间将无法直接进行通信。为了让它们之间正常通信，这时必须得采用IP隧道的功能。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303275.png" alt="image-20220424173246245"  />
</p>
<p>IP隧道中可以将那些从网络A发过来的IPv6的包统和为一个数据， ==再为之追加一个IPv4的首部以后转发给网络C==。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303289.png" alt="image-20220424173307959"  />
</p>
<h3 id="7ip相关技术">7.IP相关技术<a hidden class="anchor" aria-hidden="true" href="#7ip相关技术">#</a></h3>
<h4 id="ip任播"><strong>IP</strong>任播<a hidden class="anchor" aria-hidden="true" href="#ip任播">#</a></h4>
<p>IP任播主要用于报警电话110与消防电话119系统。当人们拨打110或119时，其接收电话并不是只有一个，而是可以拨打到一个区域管辖范围内的所有公安或消防部门。省、市、县、乡等不同级别的区域都各自设置着110与119的急救电话，而且数量极其庞大。这种机制的实现，在互联网上就是IP任播。</p>
<p>==IP任播是指为那些提供同一种服务的服务器配置同一个IP地址，并与最近的服务器进行通信的一种方法（选择哪个服务器由<strong>路由协议</strong>的类型和设置方法决定）==。</p>
<p>在==IP任播==的应用当中最为有名的当属==DNS根域名服务器==。DNS根域名服务器，出于历史原因，对IP地址的分类限制为13种类型。从负载均衡与灾备应对的角度来看，全世界根域名服务器不可能只设置13处。为此，使用IP任播可以让更多的DNS根域名服务器散布到世界的各个角落。因此，当发送一个请求包给DNS根域名服务器时，一个适当区域的IP地址也将被发送出去，从而可以从这个服务器获得应答。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303473.png" alt="image-20220424174836479"  />
</p>
<h2 id="第6章-tcp与udp">第6章 TCP与UDP<a hidden class="anchor" aria-hidden="true" href="#第6章-tcp与udp">#</a></h2>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303498.png" alt="image-20220425101513037"  />
</p>
<p>传输层的TCP和UDP，为了识别自己所传输的数据部分究竟应该发给哪个应用，也设定了这样一个编号。</p>
<p>传输层必须指出这个具体的程序，为了实现这一功能，使用==端口==（注意此处的端口与路由器、交换机等设备上指网卡的端口有所不同）号这样一种识别码。根据端口号就可以识别在传输层上一层的应用层中所要进行处理的具体程序（一个程序可以使用多个端口） 。</p>
<p>TCP/IP的众多应用协议大多以客户端/服务端的形式运行。</p>
<p>作为服务端的程序有必要提前启动，准备接收客户端的请求。否则即使有客户端的请求发过来，也无法做到相应的处理。</p>
<p>这些服务端程序在UNIX系统当中叫做==守护进程==。例如HTTP的服务端程序是httpd（HTTP守护进程），而ssh的服务端程序是sshd（SSH守护进程）。在UNIX中并不需要将这些守护进程逐个启动，而是启动一个可以代表它们接收客户端请求的inetd（互联网守护进程）服务程序即可。它是一种超级守护进程。该超级守护进程收到客户端请求以后会创建（fork）新的进程并转换（exec）为sshd等各个守护进程。</p>
<p><strong>■ TCP</strong></p>
<p>TCP是==面向连接的、可靠的流协议==。流就是指不间断的数据结构， 你可以把它想象成排水管道中的水流。当应用程序采用TCP发送消息时，虽然可以保证发送的顺序，但还是犹如没有任何间隔的数据流发送给接收端（例如，在发送端应用程序发送了10次100字节的消息，那么在接收端，应用程序有可能会收到一个1000字节连续不间断的数据。因此在TCP通信中，发送端应用可以在自己所要发送的消息中设置一个表示长度或间隔的字段信息） 。TCP为提供可靠性传输，实行“顺序控制”或“重发控制”机制。此外还具备“流控制（流量控制）”、“拥塞控制”、提高网络利用率等众多功 能。</p>
<p><strong>■ UDP</strong></p>
<p>UDP是==不具有可靠性的数据报协议==。细微的处理它会交给上层的应用去完成。在UDP的情况下，虽然可以确保发送消息的大小（例如，发送端应用程序发送一个100字节的消息，那么接收端应用程序也会以100字节为长度接收数据。UDP中，消息长度的数据也会发送到接收端，因此在发送的消息中不需要设置一个表示消息长度或间隔的字段信息。然而，UDP不具备可靠传输。所以，==发送端发出去的消息在网络传输途中一旦丢失，接收端将收不到这个消息==） ，却不能保证消息一定会到达。因此，应用有时会根据自己的需要进行重发处理。</p>
<p>TCP用于在传输层有必要实现可靠传输的情况。由于它是面向有连接并具备顺序控制、重发控制等机制的，所以它可以为应用提供可靠传输。</p>
<p>而在一方面，UDP主要用于那些对高速传输和实时性有较高要求的通信或广播通信。我们举一个通过IP电话进行通话的例子。如果使用TCP，数据在传送途中如果丢失会被重发，但这样无法流畅地传输通话人的声音，会导致无法进行正常交流。而采用UDP，它不会进行重发处理。从而也就不会有声音大幅度延迟到达的问题。即使有部分数据丢失，也只是会影响某一小部分的通话（在实时传送动画或声音时，途中一小部分网络的丢包可能会导致画面或声音的短暂停顿甚至出现混乱。 但在实际使用当中，这一点干扰并无大碍） 。此外，在多播与广播通信中也使用UDP而不是TCP。RIP（7.4节）、DHCP（5.5节）等基于广播的协议也要依赖于UDP。</p>
<img src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303514.png" alt="image-20220425103437036" style="zoom:80%;" /> 
<h3 id="1端口号">1.端口号<a hidden class="anchor" aria-hidden="true" href="#1端口号">#</a></h3>
<p>数据链路和IP中的地址，分别指的是MAC地址和IP地址。前者用来识别同一链路中不同的计算机，后者用来识别TCP/IP网络中互连的主机和路由器。在传输层中也有这种类似于地址的概念，那就是端口号。端口号用来识别同一台计算机中进行通信的不同应用程序。因此，它也被称为程序地址。</p>
<p>==仅凭目标端口识别某一个通信是远远不够的。==</p>
<p>因此，TCP/IP或UDP/IP通信中通常采用5个信息来识别（这个信息可以在Unix或Windows系统中通过netstat -n 命令显示） 一个通信。它们是==“源IP地址”、“目标IP地址”、“协议号”、“源端口号”、“目标端口号”==。只要其中某一项不同，则被认为是其他通信。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303534.png" alt="image-20220425104154808"  />
</p>
<p><strong>端口号如何确定</strong></p>
<p><strong>■</strong> 标准既定的端口号</p>
<p>这种方法也叫静态方法。它是指每个应用程序都有其指定的端口号。但并不是说可以随意使用任何一个端口号。每个端口号都有其对应的使用目的。例如，HTTP、TELNET、FTP等广为使用的应用协议中所使用的端口号就是固定的。这些端口号也被称之为知名端口号（Well-Known Port Number）。</p>
<p><strong>■</strong> 时序分配法</p>
<p>第二种方法也叫时序（或动态的）分配法。此时，服务端有必要确定监听端口号，但是接受服务的客户端没必要确定端口号。</p>
<p>在这种方法下，客户端应用程序可以完全不用自己设置端口号，而全权交给操作系统进行分配。操作系统可以为每个应用程序分配互不冲突的端口号。例如，每需要一个新的端口号时，就在之前分配号码的基础上加1。这样，操作系统就可以动态地管理端口号了。==根据这种动态分配端口号的机制，即使是同一个客户端程序发起的多个TCP连接，识别这些通信连接的5部分数字也不会全部相同==。</p>
<h3 id="2udp">2.<strong>UDP</strong><a hidden class="anchor" aria-hidden="true" href="#2udp">#</a></h3>
<p>UDP是User Datagram Protocol（用户数据报协议）的缩写。</p>
<p>UDP不提供复杂的控制机制，利用IP提供面向无连接的通信服务。 并且它是将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制。</p>
<p>即使是出现网络拥堵的情况下，UDP也无法进行流量控制等避免网络拥塞的行为。此外，传输途中即使出现丢包，UDP也不负责重发。甚至当出现包的到达顺序乱掉时也没有纠正的功能。如果需要这些细节控 制，那么不得不交由采用UDP的应用程序去处理（拥塞控制）。</p>
<p>由于UDP面向无连接，它可以随时发送数据。再加上UDP本身的处理既简单又高效，因此经常用于以下几个方面：</p>
<ul>
<li>包总量较少的通信（DNS、SNMP等）</li>
<li>视频、音频等多媒体通信（即时通信）</li>
<li>限定于LAN等特定网络中的应用通信</li>
<li>广播通信（广播、多播）</li>
</ul>
<h3 id="3tcp">3.TCP<a hidden class="anchor" aria-hidden="true" href="#3tcp">#</a></h3>
<p>TCP与UDP的区别相当大。它充分地实现了数据传输时各种控制功能，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在UDP中都没有。此外，TCP作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费（由于UDP没有连接控制，所以即使对端从一开始就不存在或中途退出网络，数据包还是能够发送出去。（当ICMP错误返回时，有时也实现了不再发送的机制）） 。</p>
<p><strong>TCP的特点及其目的</strong></p>
<p>为了通过IP数据报实现可靠性传输，需要考虑很多事情，例如数据的破坏、丢包、重复以及分片顺序混乱等问题。如不能解决这些问题，也就无从谈起可靠传输。</p>
<p>TCP通过==检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输。==</p>
<h4 id="通过序列号与确认应答提高可靠性"><strong>通过序列号与确认应答提高可靠性</strong><a hidden class="anchor" aria-hidden="true" href="#通过序列号与确认应答提高可靠性">#</a></h4>
<p>在TCP中，当发送端的数据到达接收主机时，接收端主机会返回一个已收到消息的通知。这个消息叫做确认应答（ACK（ACK（Positive Acknowled-gement）意指已经接收） ）。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303719.png" alt="image-20220425105722225"  />
</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303738.png" alt="image-20220425105732033"  />
</p>
<img src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303754.png" alt="image-20220425105745758" style="zoom:80%;" /> 
<p>此外，也有可能因为一些其他原因导致确认应答延迟到达，在源主机重发数据以后才到达的情况也履见不鲜。此时，源发送主机只要按照机制重发数据即可。但是对于目标主机来说，这简直是一种“灾难”。它会反复收到相同的数据。而为了对上层应用提供可靠的传输，必须得放弃重复的数据包。为此，就必须引入一种机制，它能够识别是否已经接 收数据，又能够判断是否需要接收。</p>
<p>上述这些==确认应答处理、重发控制以及重复控制等功能都可以通过序列号实现==。序列号是按顺序给发送数据的每一个字节（8位字节）都标上号码的编号（序列号的初始值并非为0。而是在建立连接以后由随机数生成。而后面的计算则是对每一字节加一） 。接收端查询接收数据TCP首部中的序列号和数据的长度，将自己下一步应该接收的序号作为确认应答返送回去。就这样，通过序列号和确认应答号，TCP可以实现可靠传输。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303776.png" alt="image-20220425105913853"  />
</p>
<h4 id="重发超时如何确定"><strong>重发超时如何确定</strong><a hidden class="anchor" aria-hidden="true" href="#重发超时如何确定">#</a></h4>
<p>TCP要求不论处在何种网络环境下都要提供高性能通信，并且无论网络拥堵情况发生何种变化，都必须保持这一特性。为此，它在每次发包时都会计算往返时间（Round Trip Time也叫RTT。是指报文段的往返时间。） 及其偏差（RTT时间波动的值、方差。有时也叫抖动。） 。将这个往返时间和偏差相加重发超时的时间，就是比这个总和要稍大一点的值。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303867.png" alt="image-20220425110446942"  />
</p>
<p>数据被重发之后若还是收不到确认应答，则进行再次发送。此时，等待确认应答的时间将会以2倍、4倍的指数函数延长。</p>
<h4 id="连接管理">连接管理<a hidden class="anchor" aria-hidden="true" href="#连接管理">#</a></h4>
<p>UDP是一种面向无连接的通信协议，因此不检查对端是否可以通信，直接将UDP包发送出去。TCP与此相反，它会在数据通信之前，通过TCP首部发送一个SYN包作为建立连接的请求等待确认应答（TCP中发送第一个SYN包的一方叫做客户端，接收这个的一方叫做服务端） 。如果对端发来确认应答，则认为可以进行数据通信。如果对端的确认应答未能到达，就不会进行数据通信。此外，在通信结束时会进行断开连接的处理（FIN包）。</p>
<p>可以使用TCP首部用于控制的字段来管理TCP连接（也叫控制域） 。==一个连接的建立与断开，正常过程至少需要来回发送7个包才能完成（建立一个TCP连接需要发送3个包。这个过 程也称作**“三次握手”**==） 。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303996.png" alt="image-20220425110805285"  />
</p>
<h4 id="tcp以段为单位发送数据"><strong>TCP以段为单位发送数据</strong><a hidden class="anchor" aria-hidden="true" href="#tcp以段为单位发送数据">#</a></h4>
<p>在建立TCP连接的同时，也可以确定发送数据包的单位，我们也可以称其为==“最大消息长度”（MSS：Maximum Segment Size）==。</p>
<p>TCP在传送大量数据时，是以MSS的大小将数据进行分割发送。进行重发时也是以MSS为单位。</p>
<p>MSS是在三次握手的时候，在两端主机之间被计算得出。两端的主机在发出建立连接的请求时，会在TCP首部中写入MSS选项，告诉对方自己的接口能够适应的MSS的大小（为附加MSS选项，TCP首部将不再是20字节，而是4字节的整数倍。如图6.13所示的+4。） 。然后会在两者之间选择一个较小的值投入使用。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303015.png" alt="image-20220425111107606"  />
</p>
<h4 id="利用窗口控制提高速度">利用窗口控制提高速度<a hidden class="anchor" aria-hidden="true" href="#利用窗口控制提高速度">#</a></h4>
<p>TCP以1个段为单位，每发一个段进行一次确认应答的处理。这样的传输方式有一个缺点。那就是，包的往返时间越长通信性能就越低。</p>
<p>为解决这个问题，TCP引入了窗口这个概念。即使在往返时间较长的情况下，它也能控制网络性能的下降。图6.15所示，确认应答不再是以每个分段，而是以更大的单位进行确认时，转发时间将会被大幅度的缩短。也就是说，发送端主机，==在发送了一个段以后不必要一直等待确认应答，而是继续发送==。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303031.png" alt="image-20220425111729454"  />
</p>
<p>==窗口大小就是指无需等待确认应答而可以继续发送数据的最大值==。图6.15中，窗口大小为4个段。</p>
<p>这个机制实现了使用大量的缓冲区，通过对多个段同时进行确认应答的功能。</p>
<p>如图6.16所示，发送数据中高亮圈起的部分正是前面所提到的窗口。在这个窗口内的数据即便没有收到确认应答也可以发送出去。此外，从该窗口中能看到的数据因其某种数据已在传输中丢失，所以发送端才能收到确认应答，这种情况也需进行重发。为此，==发送端主机在等到确认应答返回之前，必须在缓冲区中保留这部分数据==。</p>
<p>收到确认应答的情况下，将窗口滑动到确认应答中的序列号的位置。这样可以顺序地将多个段同时发送提高通信性能。这种机制也被称为==滑动窗口控制==。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303233.png" alt="image-20220425111922680"  />
</p>
<h4 id="窗口控制与重发控制">窗口控制与重发控制<a hidden class="anchor" aria-hidden="true" href="#窗口控制与重发控制">#</a></h4>
<p>在使用窗口控制中，如果出现段丢失该怎么办？</p>
<p>首先，我们先考虑确认应答未能返回的情况。在这种情况下，==数据已经到达对端，是不需要再进行重发的==。然而，在没有使用窗口控制的时候，没有收到确认应答的数据都会被重发。而使用了窗口控制，就如图6.17所示，某些确认应答即便丢失也无需重发。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303251.png" alt="image-20220425112355378"  />
</p>
<p>其次，我们来考虑一下某个报文段丢失的情况。如图6.18所示，接收主机如果收到一个自己应该接收的序号以外的数据时，会针对当前为止收到数据返回确认应答（==不过即使接收端主机收到的包序号并不连续，也不会将数据丢弃而是暂时保存至缓冲区中==） 。</p>
<p>如图6.18所示。==当某一报文段丢失后，发送端会一直收到序号为1001的确认应答==，这个确认应答好像在提醒发送端“我想接收的是从1001开始的数据”。因此，在窗口比较大，又出现报文段丢失的情况下，同一个序号的确认应答将会被重复不断地返回。而发送端主机如果连续3次收到同一个确认应答（之所以连续收到3次而不是两次的理由是因为，即使数据段的序号被替换两次也不会触发重发机制） ，就会将其所对应的数据进行重发。这种机制比之前提到的超时管理更加高 效，因此也被称作==高速重发控制==。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303268.png" alt="image-20220425112538817"  />
</p>
<h4 id="流控制">流控制<a hidden class="anchor" aria-hidden="true" href="#流控制">#</a></h4>
<p>TCP提供一种机制可以让发送端根据接收端的实际接收能力控制发送的数据量。这就是所谓的==流控制==。它的具体操作是，接收端主机向发送端主机通知自己可以接收数据的大小，于是发送端会发送不超过这个限度的数据。该大小限度就被称==窗口大小==。在前面6.4.6节中所介绍的窗口大小的值就是由接收端主机决定的。</p>
<p>TCP首部中，专门有一个字段用来通知窗口大小。接收主机将自己可以接收的缓冲区大小放入这个字段中通知给发送端。这个字段的值越大，说明网络的吞吐量越高。 不过，接收端的这个缓冲区一旦面临数据溢出时，窗口大小的值也 会随之被设置为一个更小的值通知给发送端，从而控制数据发送量。也就是说，发送端主机会根据接收端主机的指示，对发送数据的量进行控制。这也就形成了一个完整的==TCP流控制（流量控制）==。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303287.png" alt="image-20220425141238649"  />
</p>
<p>如图6.19所示，当接收端收到从3001号开始的数据段后其缓冲区即满，不得不暂时停止接收数据。之后，在收到发送窗口更新通知后通信才得以继续进行。如果这个窗口的更新通知在传送途中丢失，可能会导致无法继续通信。为避免此类问题的发生，发送端主机会时不时的发送一个叫做窗口探测的数据段，此数据段仅含一个字节以获取最新的窗口大小信息。</p>
<h4 id="拥塞控制">拥塞控制<a hidden class="anchor" aria-hidden="true" href="#拥塞控制">#</a></h4>
<p>有了TCP的窗口控制，收发主机之间即使不再以一个数据段为单位发送确认应答，也能够连续发送大量数据包。然而，如果在通信刚开始时就发送大量数据，也可能会引发其他问题。</p>
<p>一般来说，计算机网络都处在一个共享的环境。因此也有可能会因为其他主机之间的通信使得网络拥堵。在网络出现拥堵时，如果突然发送一个较大量的数据，极有可能会导致整个网络的瘫痪。</p>
<p>TCP为了防止该问题的出现，在通信一开始时就会通过一个叫做==慢启动==的算法得出的数值，对发送数据量进行控制。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303479.png" alt="image-20220425141923587"  />
</p>
<h4 id="提高网络利用率的规范">提高网络利用率的规范<a hidden class="anchor" aria-hidden="true" href="#提高网络利用率的规范">#</a></h4>
<p><strong>■ Nagle</strong>算法</p>
<p>该算法是指发送端即使还有应该发送的数据，但如果这部分数据很少的话，则进行延迟发送的一种处理机制。具体来说，就是仅在下列任意一种条件下才能发送数据。如果两个条件都不满足，那么暂时等待一段时间以后再进行数据发送。</p>
<ul>
<li>已发送的数据都已经收到确认应答时</li>
<li>可以发送最大段长度（MSS）的数据时</li>
</ul>
<p><strong>■</strong> 延迟确认应答</p>
<p>接收数据的主机如果每次都立刻回复确认应答的话，可能会返回一个较小的窗口。那是因为刚接收完数据，缓冲区已满。当某个接收端收到这个小窗口的通知以后，会以它为上限发送数据，从而又降低了网络的利用率（这其实是窗口控制特有的问题，专门术语叫做糊涂窗口综合征（SWS：Silly Window Syndrome）） 。为 此，引入了一个方法，那就是==收到数据以后并不立即返回确认应答，而是延迟一段时间的机制==。</p>
<ul>
<li>在没有收到2×最大段长度的数据为止不做确认应答（根据操作系统的不同，有时也有不论数据大小，只要收到两个包就即刻返回确认应答的情况）</li>
<li>其他情况下，最大延迟0.5秒发送确认应答（如果延迟多于0.5秒可能会导致发送端重发数据） （很多操作系统设置为0.2秒左右（这个时间越小、CPU的负荷会越高，性能也下降。反之，这个时间越长，越有可能触发发送主机的重发处理，而窗口为只有1个数据段的时候，性能也会下降） ）</li>
</ul>
<p>事实上，大可不必为每一个数据段都进行一次确认应答。TCP采用滑动窗口的控制机制，因此通常确认应答少一些也无妨。TCP文件传输中，绝大多数是每两个数据段返回一次确认应答。</p>
<img src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303498.png" alt="image-20220425143020701" style="zoom:80%;" /> 
<p><strong>■</strong> 捎带应答</p>
<p>根据应用层协议，发送出去的消息到达对端，对端进行处理以后， 会返回一个回执。</p>
<p>在此类通信当中，==TCP的确认应答和回执数据可以通过一个包发送==。这种方式叫做捎带应答。通过这种机制，可以使收发的数据量减少。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303524.png" alt="image-20220425143202034"  />
</p>
<h3 id="4其他传输层协议">4.其他传输层协议<a hidden class="anchor" aria-hidden="true" href="#4其他传输层协议">#</a></h3>
<p><strong>UDP-Lite</strong></p>
<p><strong>SCTP</strong></p>
<p><strong>DCCP</strong></p>
<h3 id="5udp首部的格式">5.<strong>UDP</strong>首部的格式<a hidden class="anchor" aria-hidden="true" href="#5udp首部的格式">#</a></h3>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303544.png" alt="image-20220425150020771"  />
</p>
<p><strong>■</strong> 校验和（<strong>Checksum</strong>）</p>
<p>校验和是为了提供可靠的UDP首部和数据而设计。在计算校验和时，如图6.25所示，附加在UDP伪首部与UDP数据报之前。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303561.png" alt="image-20220425150047113"  />
</p>
<p>==<strong>■</strong> 校验和计算中计算<strong>UDP</strong>伪首部的理由==</p>
<p>为什么在进行校验和计算时，也要计算UDP伪首部呢？关于这个问题，与6.2节中所介绍的内容有所关联。</p>
<p>TCP/IP中识别一个进行通信的应用需要5大要素，它们分别为“源IP地址”、“目标IP地址”、“源端口”、“目标端口”、“协议号”。然而，在UDP的首部中只包含它们当中的两项（源端口和目标端口），余下的3项都包含在IP首部里。</p>
<p>假定其他3项的信息被破坏会产生什么样的后果呢？很显然，这极有可能会导致应该收包的应用收不到包，不该收到包的应用却收到了包。</p>
<p>为了避免这类问题，有必要验证一个通信中必要的5项识别码是否正确。为此，在校验和的计算中就引入了伪首部的概念。</p>
<p>此外，IPv6中的IP首部没有校验和字段。TCP或UDP通过伪首部，得以对5项数字进行校验，从而实现即使在IP首部并不可靠的情况下仍然能够提供可靠的通信传输。</p>
<h3 id="6tcp首部格式">6.<strong>TCP</strong>首部格式<a hidden class="anchor" aria-hidden="true" href="#6tcp首部格式">#</a></h3>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303574.png" alt="image-20220425150139578"  />
</p>
<p><strong>■</strong> 序列号（<strong>Sequence Number</strong>）</p>
<p>字段长32位。序列号（有时也叫序号）是指发送数据的位置。每发送一次数据，就累加一次该数据字节数的大小。</p>
<p><strong>■</strong> 控制位（<strong>Control Flag</strong>）</p>
<p>字段长为8位，每一位从左至右分别为CWR、ECE、URG、ACK、PSH、RST、SYN、FIN。这些控制标志也叫做控制位。当它们对应位上的值为1时，具体含义如图6.27所示。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303839.png" alt="image-20220425150446401"  />
</p>
<ul>
<li>CWR（Congestion Window Reduced）</li>
</ul>
<p>CWR标志（关于CWR标志的设定请参考5.8.4节。） 与后面的ECE标志都用于IP首部的ECN字段。ECE标志为1时，则通知对方已将拥塞窗口缩小。</p>
<ul>
<li>ECE（ECN-Echo）</li>
</ul>
<p>ECE标志（关于ECE标志的设定请参考5.8.4节。） 表示ECN-Echo。置为1会通知通信对方，从对方到这边的网络有拥塞。在收到数据包的IP首部中ECN为1时将TCP首部中的ECE设置为1。</p>
<ul>
<li>URG（Urgent Flag）</li>
</ul>
<p>该位为1时，表示包中有需要紧急处理的数据。对于需要紧急处理的数据，会在后面的紧急指针中再进行解释。</p>
<ul>
<li>ACK（Acknowledgement Flag）</li>
</ul>
<p>该位为1时，确认应答的字段变为有效。TCP规定除了最初建立连接时的SYN包之外该位必须设置为1。</p>
<ul>
<li>PSH（Push Flag）</li>
</ul>
<p>该位为1时，表示需要将受到的数据立刻传给上层应用协议。PSH为0时，则不需要立即传而是先进行缓存。</p>
<ul>
<li>RST（Reset Flag）</li>
</ul>
<p>该位为1时表示TCP连接中出现异常必须强制断开连接。例如，一个没有被使用的端口即使发来连接请求，也无法进行通信。此时就可以返回一个RST设置为1的包。此外，程序宕掉或切断电源等原因导致主机重启的情况下，由于所有的连接信息将全部被初始化，所以原有的TCP通信也将不能继续进行。这种情况下，如果通信对方发送一个设置为1的RST包，就会使通信强制断开连接。</p>
<ul>
<li>SYN（Synchronize Flag）</li>
</ul>
<p>用于建立连接。SYN为1表示希望建立连接，并在其序列号的字段进行序列号初始值的设定（Synchronize本身有同步的意思。也就意味着建立连接的双方，序列号和确认应答号要保持同步） 。</p>
<ul>
<li>FIN（Fin Flag）</li>
</ul>
<p>该位为1时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换FIN位置为1的TCP段。每个主机又对对方的FIN包进行确认应答以后就可以断开连接。不过，主机收到FIN设置为1的TCP段以后不必马上回复一个FIN包，而是可以等到缓冲区中的所有数据都因已成功发送而被自动删除之后再发。</p>
<p><strong>■</strong> 校验和（<strong>Checksum</strong>）</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303852.png" alt="image-20220425151257086"  />
</p>
<p>TCP的校验和与UDP相似，区别在于TCP的校验和无法关闭。</p>
<p>==<strong>■</strong> 使用校验和的目的是什么？==</p>
<p>有噪声干扰的通信途中如果出现位错误，可以由数据链路的FCS检查出来。那么为什么TCP或UDP中也需要校验和呢？</p>
<p>其实，相比检查噪声影响导致的错误，TCP与UDP的校验和更是一种==进行路由器内存故障或程序漏洞导致的数据是否被破坏的检查==。</p>
<p>有过C语言编程经验的人都知道，如果指针使用不当，极有可能会破坏内存中的数据结构。路由器的程序中也可能会存在漏洞，或程序异常宕掉的可能。在互联网中发送数据包要经由好多个路由器，一旦在发送途中的某一个路由器发生故障，经过此路由器的包、协议首部或数据就极有可能被破坏。即使在这种情况下，TCP或UDP如果能够提供校验和计算，也可以判断协议首部和数据是否被破坏。</p>
<p><strong>■</strong> 窗口大小与吞吐量</p>
<p>TCP通信的最大吞吐量由窗口大小和往返时间决定。假定最大吞吐量为Tmax ，窗口大小为W，往返时间是RTT的话，那么最大吞吐量的公式如下：</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303866.png" alt="image-20220425151745859"  />
</p>
<p>假设窗口为65535字节，RTT为0.1秒，那么最大吞吐量Tmax 如下：</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303880.png" alt="image-20220425151739528"  />
</p>
<p>以上公式表示1个TCP连接所能传输的最大吞吐量为5.2Mbps。如果建立两个以上连接同时进行传输时，这个公式的计算结果则表示==每个连接的最大吞吐量==。也就是说，==在TCP中，与其使用一个连接传输数据，使用多个连接传输数据会达到更高的网络吞吐量==。==在Web浏览器中一般会通过同时建立4个左右连接来提高吞吐量==</p>
<h2 id="第7章-路由协议">第7章 路由协议<a hidden class="anchor" aria-hidden="true" href="#第7章-路由协议">#</a></h2>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303895.png" alt="image-20220425205724561"  />
</p>
<p>互联网是由路由器连接的网络组合而成的。为了能让数据包正确达地到达目标主机，路由器必须在途中进行正确地转发。这种向“正确的方向”转发数据所进行的处理就叫做==路由控制或路由==。</p>
<p>路由器根据==路由控制表（Routing Table）==转发数据包。它根据所收到的数据包中目标主机的IP地址与路由控制表的比较得出下一个应该接收的路由器。因此，这个过程中路由控制表的记录一定要正确无误。但凡出现错误，数据包就有可能无法到达目标主机。</p>
<h3 id="1静态路由与动态路由">1.<strong>静态路由与动态路由</strong><a hidden class="anchor" aria-hidden="true" href="#1静态路由与动态路由">#</a></h3>
<p>静态路由是指事先设置好路由器和主机中并将路由信息固定的一种方法。而动态路由是指让路由协议在运行过程中自动地设置路由控制信息的一种方法。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303002.png" alt="image-20220425210314510"  />
</p>
<p>动态路由如图7.2所示，会给相邻路由器发送自己已知的网络连接信息，而这些信息又像接力一样依次传递给其他路由器，直至整个网络都了解时，路由控制表也就制作完成了。而此时也就可以正确转发IP数据包了（图7.2中的传输，只有在没有循环的情况下才能很好地运行。例如路由器C和路由器D之间如果有连接，那么将无法正常工作） 。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303060.png" alt="image-20220425210516508"  />
</p>
<h3 id="2路由控制范围">2.路由控制范围<a hidden class="anchor" aria-hidden="true" href="#2路由控制范围">#</a></h3>
<p>随着IP网络的发展，想要对所有网络统一管理是不可能的事。因此，人们根据路由控制的范围常使用==IGP（Interior Gateway Protocol，外部网关协议）和EGP（Exterior Gateway Protocol，内部网关协议）==（EGP是特定的路由协议名称，请不要与其他同名词汇混淆） 两种类型的路由协议。</p>
<h4 id="自治系统与路由协议"><strong>自治系统与路由协议</strong><a hidden class="anchor" aria-hidden="true" href="#自治系统与路由协议">#</a></h4>
<p>企业内部网络的管理方针，往往由该企业组织内部自行决定。因此每个企业或组织机构对网络管理和运维的方法都不尽相同。为了提高自己的销售额和生产力，各家企业和组织机构都会相应购入必要的机械设备、构建合适的网络以及采用合理的运维体制。在这种环境下，可以对 公司以外的人士屏蔽企业内部的网络细节，更不必对这些细节上的更新 请求作出回应。这好比我们的日常生活，每个人对家庭内部的私事，都不希望过多暴露给外界，听从外界指挥。</p>
<p>==制定自己的路由策略，并以此为准在一个或多个网络群体中采用的小型单位叫做自治系统（AS：Autonomous System）或路由选择域（Routing Domain）==。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303131.png" alt="image-20220426100104651"  />
</p>
<p>==自治系统（路由选择域）内部动态路由采用的协议是域内路由协议，即IGP。而自治系统之间的路由控制采用的是域间路由协议，即 EGP。==</p>
<p>IGP中还可以使用==RIP（Routing Information Protocol，路由信息协议）、RIP2、OSPF（Open Shortest Path First，开放式最短路径优先）等众多协议。与之相对，EGP使用的BGP（Border Gateway Protocol，边界网关协议）协议==。</p>
<h3 id="3路由算法">3.路由算法<a hidden class="anchor" aria-hidden="true" href="#3路由算法">#</a></h3>
<p>路由控制有各种各样的算法，其中最具代表性的有两种，是==距离向量（Distance-Vector）算法==和==链路状态（Link-State）算法==。</p>
<h4 id="距离向量算法">距离向量算法<a hidden class="anchor" aria-hidden="true" href="#距离向量算法">#</a></h4>
<p>距离向量算法（DV）是指根据距离（代价（Metric是指转发数据 时衡量路由控制中距离和成本的一种指标。在距离向量算法中，代价相当于所要经过的路由器的个数） ）和方向决定目标网络或目标主机位置的一种方法。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303173.png" alt="image-20220426101054493"  />
</p>
<p>路由器之间可以互换目标网络的方向及其距离的相关信息，并以这些信息为基础制作路由控制表。这种方法在处理上比较简单，不过由于只有距离和方向的信息，所以当网络构造变得分外复杂时，在获得稳定的路由信息之前需要消耗一定时间（也叫做==路由收敛==） ，也极易发生路由循环等问题。</p>
<h4 id="链路状态算法">链路状态算法<a hidden class="anchor" aria-hidden="true" href="#链路状态算法">#</a></h4>
<p>链路状态算法是路由器在了解网络整体连接状态的基础上生成路由控制表的一种方法。该方法中，==每个路由器必须保持同样的信息才能进行正确的路由选择==。</p>
<p>距离向量算法中每个路由器掌握的信息都不相同。通往每个网络所耗的距离（代价）也根据路由器的不同而不同。因此，该算法的一个缺点就是不太容易判断每个路由器上的信息是否正确。</p>
<p>而链路状态算法中所有路由器持有相同的信息。对于任何一台路由器，网络拓扑都完全一样。因此，只要某一台路由器与其他路由器保持同样的路由控制信息，就意味着该路由器上的路由信息是正确的。</p>
<p>为了实现上述机制，链路状态算法付出的代价就是如何从网络代理获取路由信息表。这一过程相当复杂，特别是在一个规模巨大而又复杂的网络结构中，管理和处理代理信息需要高速CPU处理能力和大量的内存（为此，==OSPF==正致力于将网络分割为不同的区域，以减少路由控制信息） 。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303190.png" alt="image-20220426101234755"  />
</p>
<h4 id="主要路由协议">主要路由协议<a hidden class="anchor" aria-hidden="true" href="#主要路由协议">#</a></h4>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303205.png" alt="image-20220426101245166"  />
</p>
<h3 id="4rip">4.<strong>RIP</strong><a hidden class="anchor" aria-hidden="true" href="#4rip">#</a></h3>
<p>==RIP（Routing Information Protocol）是距离向量型的一种路由协议==，广泛用于LAN。被BSD UNIX作为标准而提供的routed（在UNIX系统上的一个守护进程。该进程实现了RIP协议） 采用了RIP，因此RIP得到了迅速的普及。</p>
<p><strong>广播路由控制信息</strong></p>
<p>RIP将路由控制信息定期（30秒一次）向全网广播。如果没有收到路由控制信息，连接就会被断开。不过，这有可能是由于丢包导致的，因此RIP规定等待5次。如果等了6次（180秒）仍未收到路由信息，才会真正关闭连接。</p>
<h4 id="根据距离向量确定路由"><strong>根据距离向量确定路由</strong><a hidden class="anchor" aria-hidden="true" href="#根据距离向量确定路由">#</a></h4>
<p>RIP基于距离向量算法决定路径。距离（Metrics）的单位为“跳数”。跳数是指所经过的路由器的个数。RIP希望尽可能少通过路由器将数据包转发到目标IP地址，如图7.7所示。根据距离向量生成距离向量表，再抽出较小的路由生成最终的路由控制表。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303220.png" alt="image-20220426104141132"  />
</p>
<p><strong>使用子网掩码时的RIP处理（没看明白）</strong></p>
<p>RIP虽然不交换子网掩码信息，但可以用于使用子网掩码的网络环境。不过在这种情况下需要注意以下几点：</p>
<ul>
<li>从接口的IP地址对应分类得出网络地址后，与根据路由控制信息流过此路由器的包中的IP地址对应的分类得出的网络地址进行比较。 如果两者的网络地址相同，那么就以接口的网络地址长度为准。</li>
<li>如果两者的网络地址不同，那么以IP地址的分类所确定的网络地址长度为准。</li>
</ul>
<p>例如，路由器的接口地址为192.168.1.33/27。很显然，这是一个C类地址，因此按照IP地址分类它的网络地址为192.168.1.33/24。与192.168.1.33/24相符合的IP地址，其网络地址长度都被视为27位。除此之外的地址，则采用每个地址的分类所确定的网络地址长度。</p>
<p>因此，采用RIP进行路由控制的范围内必须注意两点：一是，因IP地址的分类而产生不同的网络地址时；二是，构造网络地址长度不同的网络环境时。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303418.png" alt="image-20220426104305782"  />
</p>
<h4 id="rip中路由变更时的处理"><strong>RIP</strong>中路由变更时的处理<a hidden class="anchor" aria-hidden="true" href="#rip中路由变更时的处理">#</a></h4>
<p>RIP的基本行为可归纳为如下两点：</p>
<ul>
<li>将自己所知道的路由信息定期进行广播。</li>
<li>一旦认为网络被断开，数据将无法流过此路由器，其他路由器也就可以得知网络已经断开。</li>
</ul>
<p>不过，这两点不论哪种方式都存在一些问题。</p>
<p>如图7.9，路由器A将网络A的连接信息发送给路由器B，路由器B又将自己掌握的路由信息在原来的基础上加1跳后发送给路由器A和路由器C。假定这时与网络A发生了故障。</p>
<p>路由器A虽然觉察到自己与网络A的连接已经断开，无法将网络A的信息发送给路由器B，但是它会收到路由器B曾经获知的消息。这就使得路由器A误认为自己的信息还可以通过路由器B到达网络A。</p>
<p>==像这样收到自己发出去的消息，这个问题被称为无限计数（Counting to Infinity）==。</p>
<p>为了尽可能解决这个问题，人们提出了==“毒性逆转”（Poisoned Reverse）==和==“触发更新”（Triggered Update）==两种方法。</p>
<p>==毒性逆转==是指当网络中发生链路被断开的时候，不是不再发送这个消息，而是将这个无法通信的消息传播出去。即发送一个距离为16的消息。==触发更新==是指当路由信息发生变化时，不等待30秒而是立刻发送出去的一种方法。有了这两种方法，在链路不通时，可以迅速传送消息以使路由信息尽快收敛。</p>
<h4 id="rip2"><strong>RIP2</strong><a hidden class="anchor" aria-hidden="true" href="#rip2">#</a></h4>
<p>RIP2的意思是RIP第二版。它是在RIP使用过程中总结了经验的基础上进行改良后的一种协议。第二版与第一版的工作机制基本相同，不过仍有如下几个新的特点。</p>
<p><strong>■</strong> 使用多播</p>
<p>RIP中当路由器之间交换路由信息时采用广播的形式，然而在RIP2中改用了多播。这样不仅减少了网络的流量，还缩小了对无关主机的影响。</p>
<p><strong>■</strong> 支持子网掩码</p>
<p>与OSPF类似的，RIP2支持在其交换的路由信息中加入子网掩码信息。</p>
<p><strong>■</strong> 路由选择域</p>
<p>与OSPF的区域类似，在同一个网络中可以使用逻辑上独立的多个RIP。</p>
<p><strong>■</strong> 外部路由标志</p>
<p>通常用于把从BGP等获得的路由控制信息通过RIP传递给AS内。</p>
<p><strong>■</strong> 身份验证密钥</p>
<p>与OSPF一样，RIP包中携带密码。只有在自己能够识别这个密码时才接收数据，否则忽略这个RIP包。</p>
<h3 id="5ospf"><strong>5.OSPF</strong><a hidden class="anchor" aria-hidden="true" href="#5ospf">#</a></h3>
<h4 id="ospf是链路状态型路由协议"><strong>OSPF</strong>是链路状态型路由协议<a hidden class="anchor" aria-hidden="true" href="#ospf是链路状态型路由协议">#</a></h4>
<p>OSPF为链路状态型路由器。路由器之间交换链路状态生成网络拓扑信息，然后再根据这个拓扑信息生成路由控制表。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303436.png" alt="image-20220426111110804"  />
</p>
<p>RIP的路由选择，要求途中所经过的路由器个数越少越好。与之相比，OSPF可以给每条链路（实际上，可以为连到该数据链路（子网）的网卡设置一个代价。而这个代价只用于发送端，接收端不需要考虑） ==赋予一个权重==（也可以叫做代价），==并始终选择一个权重最小的路径作为最终路由==。也就是说OSPF以每个链路上的代价为度量标准，始终选择一个总的代价最小的一条路径。如图7.14对比所示，==RIP是选择路由器个数最少的路径，而OSPF是选择总的代价较小的路径==。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303586.png" alt="image-20220426111118924"  />
</p>
<h4 id="ospf基础知识"><strong>OSPF</strong>基础知识<a hidden class="anchor" aria-hidden="true" href="#ospf基础知识">#</a></h4>
<p>在OSPF中，把==连接到同一个链路的路由器称作相邻路由器（Neighboring Router）==。在一个相对简单的网络结构中，例如每个路由器仅跟一个路由器相互连接时（在专线网络中，路由器之间采用PPP相连） ，相邻路由器之间可以交换路由信息。但是在一个比较复杂的网络中，例如在同一个链路中加入了以太网或FDDI等路由器时，就不需要在所有相邻的路由器之间都进行控制信息的交换，而是确定一个==指定路由器（Designated Router）==，并以它为中心交换（邻接路由器中相互交换路由信息的关系叫做邻接（Adjancency）） 路由信息即可。</p>
<p>在OSPF中，根据作用的不同可以分为5种类型的包。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303601.png" alt="image-20220426111235028"  />
</p>
<p>通过==发送问候（HELLO）包确认是否连接==。每个路由器为了同步路由控制信息，利用==数据库描述（Database Description）包相互发送路由摘要信息和版本信息==。如果版本比较老，则首先==发出一个链路状态请求（Link State Request）包请求路由控制信息==，然后由==链路状态更新（Link State Update）包接收路由状态信息==，最后再通过==链路状态确认（Link State ACK Packet）包通知大家本地已经接收到路由控制信息==。 有了这样一个机制以后，OSPF不仅可以大大地减少网络流量，还可以达到迅速更新路由信息的目的。</p>
<h4 id="ospf工作原理概述"><strong>OSPF</strong>工作原理概述<a hidden class="anchor" aria-hidden="true" href="#ospf工作原理概述">#</a></h4>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303619.png" alt="image-20220426111447554"  />
</p>
<p>链路状态更新包所要传达的消息大致分为两类：一是网络LSA（Network Link State Advertisement，网络链路状态通告） ， 另一个是路由器LSA（Router Link State Advertisement，路由器链路状态通告） 。</p>
<p>==网络LSA是以网络为中心生成的信息，表示这个网络都与哪些路由器相连接。而路由器LSA是以路由器为中心生成的信息，表示这个路由器与哪些网络相连接。==</p>
<p>如果这两种信息 主要采用OSPF发送，每个路由器就都可以生成一个可以表示网络结构的链路状态数据库。可以根据这个数据库、采用Dijkstra算法生成相应的路由控制表。</p>
<h4 id="将区域分层化进行细分管理">将区域分层化进行细分管理<a hidden class="anchor" aria-hidden="true" href="#将区域分层化进行细分管理">#</a></h4>
<p>链路状态型路由协议的潜在问题在于，当网络规模越来越大时，表示链路状态的拓扑数据库就变得越来越大，路由控制信息的计算也就越困难。==OSPF为了减少计算负荷，引入了区域的概念==。</p>
<p>区域是指将连接在一起的网络和主机划分成小组，使一个自治系统（AS）内可以拥有多个区域。不过具有多个区域的==自治系统必须要有一个主干区域==（主干区域的ID为0。逻辑上只允许它有1个，可实际在物理上又可以划分为多个） （Backbone Area），并且所有其他区域必须都与这个主干区域相连接。</p>
<p>连接区域与主干区域的路由器称作==区域边界路由器==；而区域内部的路由器叫做==内部路由器==；只与主干区域内连接的路由器叫做==主干路由器==；与外部相连接的路由器就是==AS边界路由器==。</p>
<p>每个区域内的路由器都持有==本区域网络拓扑的数据库==。然而，==关于区域之外的路径信息，只能从区域边界路由器那里获知它们的距离==。区域边界路由器也不会将区域内的链路状态信息全部原样发送给其他区域，==只会发送自己到达这些路由器的距离信息==，内部路由器所持有的网络拓扑数据库就会明显变小。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303639.png" alt="image-20220426111911543"  />
</p>
<h3 id="6bgp">6.<strong>BGP</strong><a hidden class="anchor" aria-hidden="true" href="#6bgp">#</a></h3>
<p>==BGP（Border Gateway Protocol），边界网关协议是连接不同组织机构（或者说连接不同自治系统）的一种协议。因此，它属于外部网关协议（EGP）==。具体划分，它主要用于ISP之间相连接的部分。只有BGP、RIP和OSPF共同进行路由控制，才能够进行整个互联网的路由控制。</p>
<h4 id="bgp与as号"><strong>BGP</strong>与<strong>AS</strong>号<a hidden class="anchor" aria-hidden="true" href="#bgp与as号">#</a></h4>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303657.png" alt="image-20220426114157374"  />
</p>
<p>ISP、区域网络等会将每个网络域编配成一个个自治系统（AS： Autonomous System）进行管理。它们==为每个自治系统分配一个16比特的AS编号==。</p>
<p>BGP就是根据这个编号进行相应的路由控制。</p>
<p>有了AS编号的域，就相当于有了自己一个独立的“国家”。==AS的代表可以决定AS内部的网络运营和相关决策==。与其他AS相连的时候，可 以像一位“外交官”一样签署合约再进行连接（也叫对接（Peering）） 。</p>
<h4 id="bgp是路径向量协议"><strong>BGP</strong>是路径向量协议<a hidden class="anchor" aria-hidden="true" href="#bgp是路径向量协议">#</a></h4>
<p>==根据BGP交换路由控制信息的路由器叫做BGP扬声器==。BGP扬声器为了在AS之间交换BGP信息，必须与所有AS建立对等的BGP连接。</p>
<p>BGP中数据包送达目标网络时，会生成一个中途经过所有AS的编号列表。==这个表格也叫做AS路径信息访问列表（AS Path List）==。如果针对同一个目标地址出现多条路径时，BGP会从AS路径信息访问列表中选择一个较短的路由。</p>
<p>在AS路径信息访问列表中不仅包含转发方向和距离，还涵盖了途径所有AS的编号。因此==它不是一个距离向量型协议==。此外，对网络构造仅用一元化表示，因此也==不属于链路状态型协议==。==像BGP这种根据所要经过的路径信息访问列表进行路由控制的协议属于路径向量（Path Vector）型协议==。作为距离向量型的RIP协议，因为无法检测出环路， 所以可能发生无限计数的问题（路由进入稳定状态需要一定时间、网络跳数不可超过15等限制，导致无法应用于大型的网络等问题） 。==而路径向量型由于能够检测出环路，避免了无线计数的问题，所以令网络更容易进入一个稳定的状态。同时，它还有支持策略路由（策略路由控制是指在发送数据包时，可以选择或指定所要通过的AS的意思。） 的优势==。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303676.png" alt="image-20220426114609140"  />
</p>
<h3 id="7mpls">7.<strong>MPLS</strong><a hidden class="anchor" aria-hidden="true" href="#7mpls">#</a></h3>
<p>现如今，在转发IP数据包的过程中除了使用路由技术外，还在使用标记交换技术。路由技术基于IP地址中最长匹配原则进行转发，而==标记交换则对每个IP包都设定一个叫做“标记”的值，然后根据这个“标记”再进行转发。标记交换技术中最具代表性的当属多协议标记交换技术，即MPLS（Multi Protocol Label Switching）==。</p>
<p>由于==基于标记的转发通常无法在路由器上进行==，所以MPLS也就无法被整个互联网采用。如图7.22所示，它的转发处理方式甚至与IP网也有所不同。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303942.png" alt="image-20220426141537662"  />
</p>
<h4 id="mpls的网络基本动作"><strong>MPLS</strong>的网络基本动作<a hidden class="anchor" aria-hidden="true" href="#mpls的网络基本动作">#</a></h4>
<p>MPLS网络中实现MPLS功能的路由器叫做==标记交换路由器（LSR，Label Switching Router）==。特别是与外部网路连接的那部分LSR叫做==标记边缘路由器（LER，Label Edge Router）==。MPLS正是在LER上对数据包进行追加标记和删除标记的操作。</p>
<p>如图7.23展示了数据从以太网的IP网开始经过MPLS网再发送给其他IP网的整个转发过程。数据包在进入MPLS时，在其IP首部的前面被追加了32比特的垫片头（其中包含20比特的标记值）（有时也可能会被追加多个垫片头） 。MPLS网络内，根据垫片头中的标记进一步进行转发。当数据离开MPLS时，垫片头就被去除。在此我们称==附加标记转发的动作为Push，替换标记转发的动作为Swap，去掉标记转发的动作为Pop==。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303956.png" alt="image-20220426141800706"  />
</p>
<p>MPLS中目标地址和数据包（它们被称作FEC（Forward-ing Equivalence Class），是指具有相同特性的报文） 都要通过由标记决定的同一个路径，这个路径叫做==标记交换路径（LSP，Label Switch Path）==。LSP又可以划分为一对一连接的点对点LSP，和一对多绑定的合并LSP两类。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303973.png" alt="image-20220426141923192"  />
</p>
<h4 id="mpls的优点"><strong>MPLS</strong>的优点<a hidden class="anchor" aria-hidden="true" href="#mpls的优点">#</a></h4>
<p>MPLS的优势可归纳为两点。==第一个是转发速度快==。通常，路由器转发IP数据包时，首先要对目标地址和路由控制表中可变长的网络地址进行比较，然后从中选出最长匹配的路径才能进行转发。MPLS则不然。==它使用固定长度的标记信息，使得处理更加简单，可以通过高速的硬件实现转发==（现在的路由器也更趋向于硬件化） 。此外，相比互联网中的主干路由器需要保存大量路由表才能进行处理的现状，==MPLS只需要设置必要的几处信息即可，所要处理的数据量也大幅度减少。==而且除了IPv4、IPv6之外，针对其他协议，MPLS仍然可以实现高速转发。</p>
<p>第二个优势在于==利用标记生成虚拟的路径，并在它的上面实现IP等数据包的通信==。基于这些特点，被称之为“尽力而为”的IP网也可以提供基于MPLS的通信质量控制、带宽保证和VPN等功能。</p>
<h2 id="第8章-应用协议">第8章 应用协议<a hidden class="anchor" aria-hidden="true" href="#第8章-应用协议">#</a></h2>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303992.png" alt="image-20220501170703154"  />
</p>
<h3 id="1远程登录">1.远程登录<a hidden class="anchor" aria-hidden="true" href="#1远程登录">#</a></h3>
<p>实现从自己的本地计算机登录到网络另一端计算功能的应用就叫做远程登录。</p>
<p>远程登录主要使用TELNET和SSH（Secure SHell） 两种协议。</p>
<p><strong>TELNET</strong></p>
<p>TELNET利用TCP的一条连接，通过这一条连接向主机发送文字命令并在主机上执行。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303007.png" alt="image-20220501171755290"  />
</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303199.png" alt="image-20220501171834231"  />
</p>
<p>TELNET客户端通常与目标主机的23号端口建立连接，并与监听这个端口的服务端程序telnetd进行交互。当然，也可以与其他的TCP端口号连接，只要在该端口上有监听程序能够处理telnet请求即可。</p>
<p>在一般的telnet命令：</p>
<p>telnet主机名 TCP端口号TCP端口号为21时可以连接到FTP（8.3节）应用，为25时可以连接到SMTP（8.4.4节），为80时可连接到HTTP（8.5节），为110时可连接到POP3（8.4.5节）。如此看来，每个服务器都有相应的端口号在等待连接。</p>
<p>因此，以下两个命令可以视为相同：</p>
<p><code>ftp 主机名 </code></p>
<p><code>telnet 主机名 21 </code></p>
<p><strong>SSH</strong></p>
<p>SSH是加密的远程登录系统。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303220.png" alt="image-20220501171959451"  />
</p>
<h3 id="2文件传输">2.文件传输<a hidden class="anchor" aria-hidden="true" href="#2文件传输">#</a></h3>
<p><strong>FTP的工作机制概要</strong></p>
<p>FTP是通过怎样的机制才得以实现文件传输的呢？</p>
<p>==它使用两条TCP连接：一条用来控制，另一条用于数据（文件）的传输。==</p>
<p>==用于控制的TCP连接主要在FTP的控制部分使用。==例如登录用户名和密码的验证、发送文件的名称、发送方式的设置。利用这个连接，可以通过ASCII码字符串发送请求和接收应答。==在这个连接上无法发送数据，数据需要一个专门的TCP进行连接==。</p>
<p>==FTP控制用的连接使用的是TCP21号端口。==在TCP21号端口上进行文件GET（RETR）、PUT（STOR）、以及文件一览（LIST）等操作时，==每次都会建立一个用于数据传输的TCP连接==。数据的传输和文件一览表的传输正是在这个新建的连接上进行。当数据传送完毕之后，传输数据的这条连接也会被断开，然后会在控制用的连接上继续进行命令或应答的处理。</p>
<p>==数据传输用的TCP连接通常使用端口20。==不过可以用PORT命令修改为其他的值。最近，出于安全的考虑，普遍在数据传输用的端口号中使用随机数进行分配。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303239.png" alt="image-20220501172707458"  />
</p>
<h3 id="3电子邮件">3.电子邮件<a hidden class="anchor" aria-hidden="true" href="#3电子邮件">#</a></h3>
<p><strong>电子邮件的工作机制</strong></p>
<p>提供电子邮件服务的协议叫做==SMTP（Simple Mail Transfer Protocol）==。SMTP为了实现高效发送邮件内容，在其传输层使用了TCP协议。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303257.png" alt="image-20220501173514587"  />
</p>
<p>在技术上改变了以往直接在发送端与接收端主机之间建立TCP连接的机制，而引进了一种==一直会连接电源的邮件服务器。==</p>
<p>发送和接收端通过邮件服务器进行收发邮件。接收端从邮件服务器接收邮件时使用POP3（Post Office Protocol）协议。</p>
<p>==电子邮件的机制由3部分组成，它们分别是邮件地址，数据格式以及发送协议。==</p>
<h4 id="邮件地址">邮件地址<a hidden class="anchor" aria-hidden="true" href="#邮件地址">#</a></h4>
<p>使用电子邮件时需要拥有的地址叫做邮件地址。它就相当于通信地址和姓名。互联网中电子邮件地址的格式如下：</p>
<p><code>名称@通信地址 </code></p>
<p>例如，<code>master@tcpip.kusa.ac.jp</code>中的<code>master</code>为名称，<code>tcpip.kusa.ac.jp</code>为地址。电子邮件的地址和域名的构造相同。此处，kusa.ac.jp表示域名，tcpip则表示master接收邮件的主机名称或为发送邮件所用的子网名称。</p>
<p>现在，电子邮件的发送地址由DNS进行管理。DNS中注册有邮件地址及其作为发送地址时对应的邮件服务器的域名。这些映射信息被称作==MX记录==。例如，kusa.ac.jp的MX（Mail Exchange）记录中指定了mailserver.kusa.ac.jp。于是任何==发给以kusa.ac.jp结尾的地址的邮件都将被发送到mailserver.kusa.ac.jp服务器==。就这样，根据MX记录中指定的邮件服务器，可以管理不同邮件地址与特定邮件服务器之间的映射关系。</p>
<h4 id="mime"><strong>MIME</strong><a hidden class="anchor" aria-hidden="true" href="#mime">#</a></h4>
<p>很长一段时间里，互联网中的电子邮件只能处理文本格式的（由文字组成的信息。过去的电子邮件，就日本来说人们只能发送7比特 JIS编码的信息。） 邮件。不过现在，电子邮件所能发送的数据类型已被扩展到==MIME（Multipurpose Internet Mail Extensions，通用互联网邮件扩充==，广泛用于互联网并极大地扩展了数据格式，还可以用于WWW和NetNews中） ，可以发送静态图像、动画、声音、程序等各种形式的数据。鉴于MIME规定了应用消息的格式，因此==在OSI参考模型中它相当于第6层表示层==。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303450.png" alt="image-20220501175544285"  />
</p>
<h4 id="smtp"><strong>SMTP</strong><a hidden class="anchor" aria-hidden="true" href="#smtp">#</a></h4>
<p>SMTP是发送电子邮件的协议。它使用的是TCP的25号端口。SMTP建立一个TCP连接以后，在这个连接上进行控制和应答以及数据的发送。客户端以文本的形式发出请求，服务端返回一个3位数字的应答。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303471.png" alt="image-20220501175757124"  />
</p>
<h4 id="pop"><strong>POP</strong><a hidden class="anchor" aria-hidden="true" href="#pop">#</a></h4>
<p>前一节提到的SMTP是发送邮件的协议，即，==SMTP是想要发送邮件的计算机向接收邮件的计算机发送电子邮件的一种协议==。在以UNIX工作站为主的互联网初期，这种机制没有什么问题，但是后来用个人电脑连接互联网的环境中就出现很多不便之处。</p>
<p>个人电脑不可能长时间处于开机状态。只有用户在使用时才会开机。在这种情况下，人们希望一开机就能接收到邮件。然而SMTP没有这种处理机制。==SMTP的一个不利之处就在于它支持的是发送端主机的行为，而不是根据接收端的请求发送邮件==。</p>
<p>为了解决这个问题，就引入了POP协议。如图8.14所示，该协议是==一种用于接收电子邮件的协议==。==发送端的邮件根据SMTP协议将被转发给一直处于插电状态的POP服务器。客户端再根据POP协议从POP服务器接收对方发来的邮件。==在这个过程中，为了防止他人盗窃邮件内容，还要进行用户验证。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303489.png" alt="image-20220501180127341"  />
</p>
<h4 id="imap"><strong>IMAP</strong><a hidden class="anchor" aria-hidden="true" href="#imap">#</a></h4>
<p>IMAP（Internet Message Access Protocol） 与POP类似，也是接收电子邮件的协议。==在POP中邮件由客户端进行管理，而在IMAP中邮件则由服务器进行管理==。使用IMAP时，可以不必从服务器上下载所有的邮件也可以阅读。由于IMAP是在服务器端处理MIME信息，所以它可以实现当某一封邮件含有10个附件时“只下载其中的第7个附件”的功能（在POP中无法下载某个特定的附件。因此想要确认附件时就不得不下载邮件中所有的附件） 。</p>
<p>有了IMAP人们就可以通过个人电脑、公司的电脑、笔记本电脑以及智能手机等连接到IMAP服务器以后进行收发邮件。由此，在公司下载的电子邮件就不必在笔记本电脑和智能手机上转来转去（不过笔记本电脑和智能手机必须能够连上IMAP服务器才行） 。IMAP确实为使用多种异构终端的人们提供了非常便利的环境。</p>
<h3 id="4www"><strong>4.WWW</strong><a hidden class="anchor" aria-hidden="true" href="#4www">#</a></h3>
<p>==万维网（WWW，World Wide Web）==是将互联网中的信息以超文本（超文本用以显示文本及与文本相关的内容） 形式展现的系统。也叫做Web。可以显示WWW信息的客户端软件叫做Web浏览器（Web浏览器（Web Browser），有时也简称为浏览器） 。</p>
<p>WWW定义了3个重要的概念，它们分别是访问信息的手段与位置==（URI，Uniform Resource Identifier）==、信息的表现形式==（HTML， HyperText Markup Language）==以及信息转发==（HTTP，HyperText Transfer Protocol）==等操作。</p>
<h4 id="uri"><strong>URI</strong><a hidden class="anchor" aria-hidden="true" href="#uri">#</a></h4>
<p>URI是==Uniform Resource Identifier==的缩写，用于标识资源。URI是一种可以用于WWW之外的高效的识别码，它被用于主页地址（也被叫做URL（Uniform Resource Locator））、电子邮件、电话号码等各种组合中。</p>
<p>==URI所表示的组合叫方案（Scheme）==</p>
<p>在众多URI的Scheme中WWW主要用其中的==http和https表示Web页的位置和访问Web页的方法==。</p>
<p>URI的http方案的具体格式如下：</p>
<p>http://主机名/路径</p>
<p>http://主机名：端口号/路径</p>
<p>http://主机名：端口号/路径？访问内容#部分信息</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303507.png" alt="image-20220501181214526"  />
</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303524.png" alt="image-20220501181256908"  />
</p>
<h4 id="html"><strong>HTML</strong><a hidden class="anchor" aria-hidden="true" href="#html">#</a></h4>
<p>HTMP是记述Web页的一种语言（数据格式）。它可以指定浏览器中显示的文字、文字的大小和颜色。此外，不仅可以对图像或动画进行相关设置，还可以设置音频内容。</p>
<p>如果把它对应到OSI参考模型，那么可以认为HTML属于WWW的==表示层==（HTML不仅用于WWW，有时还用于电子邮件）</p>
<h4 id="http"><strong>HTTP</strong><a hidden class="anchor" aria-hidden="true" href="#http">#</a></h4>
<p>当用户在浏览器的地址栏里输入所要访问Web页的URI以后，HTTP的处理即会开始。HTTP中默认使用80端口。它的工作机制，首先是客户端向服务器的80端口建立一个TCP连接，然后在这个TCP连接上进行请求和应答以及数据报文的发送。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303765.png" alt="image-20220501181644554"  />
</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303781.png" alt="image-20220501181707755"  />
</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303800.png" alt="image-20220501181722334"  />
</p>
<h4 id="javascriptcgicookie"><strong>JavaScript</strong>、<strong>CGI</strong>、<strong>Cookie</strong><a hidden class="anchor" aria-hidden="true" href="#javascriptcgicookie">#</a></h4>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303819.png" alt="image-20220501182146971"  />
</p>
<h3 id="5网络管理">5.网络管理<a hidden class="anchor" aria-hidden="true" href="#5网络管理">#</a></h3>
<h4 id="snmp"><strong>SNMP</strong><a hidden class="anchor" aria-hidden="true" href="#snmp">#</a></h4>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303841.png" alt="image-20220501183004131"  />
</p>
<p>SNMP中管理端叫做管理器（Manager，网络监控终端），被管理端叫做代理（路由器、交换机等）（SNMPv3中管理器和代理都叫做实体 （Entity）） 。决定管理器与代理之间的通信中所要交互信息的正是SNMP。SNMP中如果将MIB（==SNMP中交互的信息是MIB（Management Information Base）==。MIB是在树形结构的数据库中为每个项目附加编号的一种信息结构） 看做代理所管理的信息在数据库中的值，那么它可以新增一个值。</p>
<h2 id="第9章-网络安全">第9章 网络安全<a hidden class="anchor" aria-hidden="true" href="#第9章-网络安全">#</a></h2>
<h3 id="1网络安全构成要素">1.网络安全构成要素<a hidden class="anchor" aria-hidden="true" href="#1网络安全构成要素">#</a></h3>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303070.png" alt="image-20220501184508452"  />
</p>
<h4 id="防火墙"><strong>防火墙</strong><a hidden class="anchor" aria-hidden="true" href="#防火墙">#</a></h4>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303091.png" alt="image-20220501184519674"  />
</p>
<h4 id="ids入侵检测系统"><strong>IDS（入侵检测系统）</strong><a hidden class="anchor" aria-hidden="true" href="#ids入侵检测系统">#</a></h4>
<h4 id="反病毒个人防火墙"><strong>反病毒/个人防火墙</strong><a hidden class="anchor" aria-hidden="true" href="#反病毒个人防火墙">#</a></h4>
<h3 id="2加密技术基础">2.加密技术基础<a hidden class="anchor" aria-hidden="true" href="#2加密技术基础">#</a></h3>
<p>为了防止信息的泄露、实现机密数据的传输，出现了各种各样的加密技术。加密技术分布与OSI参考模型的各个阶层一样，相互协同保证通信。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303107.png" alt="image-20220501184735825"  />
</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303127.png" alt="image-20220501184812493"  />
</p>
<h4 id="对称密码体制与公钥密码体制">对称密码体制与公钥密码体制<a hidden class="anchor" aria-hidden="true" href="#对称密码体制与公钥密码体制">#</a></h4>
<p>加密是指利用某个值（密钥）对明文的数据通过一定的算法变换成加密（密文）数据的过程。它的逆反过程叫做解密。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303144.png" alt="image-20220501185049197"  />
</p>
<p>==加密和解密使用相同的密钥叫做对称加密方式。反之，如果在加密和解密过程中分别使用不同的密钥（公钥和私钥）则叫做公钥加密方式。==</p>
<p>对称加密方式包括AES（Advanced Encryption Standard）、 DES（Data Encryption Standard）等加密标准，而公钥加密方法中包括RSA、DH（Diffie-Hellman）、椭圆曲线等加密算法。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303338.png" alt="image-20220501185100952"  />
</p>
<h4 id="身份认证技术">身份认证技术<a hidden class="anchor" aria-hidden="true" href="#身份认证技术">#</a></h4>
<h3 id="3安全协议">3.安全协议<a hidden class="anchor" aria-hidden="true" href="#3安全协议">#</a></h3>
<h4 id="ipsec与vpn"><strong>IPsec</strong>与<strong>VPN</strong><a hidden class="anchor" aria-hidden="true" href="#ipsec与vpn">#</a></h4>
<p>以前，为了防止信息泄露，对机密数据的传输一般不使用互联网等公共网络（Public Network），而是使用由专线连接的私有网络（Private Network）。从而在物理上杜绝了窃听和篡改数据的可能。然而，专线的造价太高是一个不可回避的问题。</p>
<p>为了解决此类问题，人们想出了在互联网上构造一个==虚拟的私有网络==。即VPN（Virtual Private Network，虚拟专用网） 。互联网中采用加密和认证技术可以达到“即使读取到数据也无法读懂”、“检查是否被篡改”等功效。VPN正是一种利用这两种技术打造的网络。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303353.png" alt="image-20220501190115409"  />
</p>
<p>在构建VPN时，最常被使用的是==IPsec==。它是指在IP首部的后面追加==“封装安全有效载荷”（ESP，Encapsulating Security Payload。）和“认证首部”（AH，Authentication Header。）== ，从而对此后的数据进行加密，不被盗取者轻易解读。</p>
<p>==在发包的时候附加上述两个首部==，可以在收包时根据首部对数据进行解密，恢复成原始数据。由此，加密后的数据不再被轻易破解，即使在途中被篡改，也能够被及时检测。</p>
<p>基于这些功能，VPN的使用者就可以不必设防地使用一个安全的网络环境。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303369.png" alt="image-20220501190208946"  />
</p>
<h4 id="tlsssl与https"><strong>TLS/SSL</strong>与<strong>HTTPS</strong><a hidden class="anchor" aria-hidden="true" href="#tlsssl与https">#</a></h4>
<p>Web中可以通过TLS/SSL（Transport Layer Security/Secure Sockets Layer。由网景公司最早提出的名称叫SSL，标准化以后被称作TLS。有时两者统称为SSL） 对HTTP通信进行加密。==使用TLS/SSL的HTTP通信叫做HTTPS通信==。==HTTPS中采用<strong>对称加密方式</strong>。而在<strong>发送其公共密钥时采用的则是公钥加密方式</strong>==（对称加密虽然速度快，但是密钥管理是巨大的挑战。公钥加密密钥管理相对简单，但是处理速度非常慢。TLS/SSL将两者进行取长补短令加密过程达到了极好的效果。由于谁都可以发送公钥，使得密钥管理更为简单） 。</p>
<p><img loading="lazy" src="https://blog-images-1301988137.cos.ap-nanjing.myqcloud.com/blog/2207/202308012303387.png" alt="image-20220501190527593"  />
</p>
<p>确认公钥是否正确主要使用认证中心（CA（Certificate Authority） ）签发的证书，而主要的认证中心的信息已经嵌入到浏览器的出厂设置中。如果Web浏览器中尚未加入某个认证中心，那么会在页面上提示一个警告信息。此时，判断认证中心合法与否就要由用户自己决定了。</p>
<h4 id="ieee8021x"><strong>IEEE802.1X</strong><a hidden class="anchor" aria-hidden="true" href="#ieee8021x">#</a></h4>
<p>IEEE802.1X是==为了能够接入LAN交换机和无线LAN接入点而对用户进行认证的技术==。并且它只允许被认可的设备才能访问网络。虽然它是一个提供数据链路层控制的规范，但是与TCP/IP关系紧密。一般，由客户端终端、AP（无线基站）或2层交换机以及认证服务器组成。</p>


  </div>

  <footer class="post-footer">
    
<nav class="paginav">
  <a class="prev" href="https://chance7bin.github.io/posts/basic/os-lab/%E5%AE%9E%E9%AA%8C1-%E7%86%9F%E6%82%89%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83/">
    <span class="title">« 上一页</span>
    <br>
    <span>实验1 熟悉实验环境</span>
  </a>
  <a class="next" href="https://chance7bin.github.io/posts/basic/os/%E4%B8%80%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8/">
    <span class="title">下一页 »</span>
    <br>
    <span>一、内核启动</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://chance7bin.github.io/">Binb&#39;s Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
